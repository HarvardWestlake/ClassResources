<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Singly Linked List — Memory Visualizer</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Source+Sans+Pro:wght@400;500;600;700&display=swap" rel="stylesheet">
  <link rel="stylesheet" href="../../../math/widgets/shared/styles.css" />

  <style>
    :root{
      --baseline-cols: 10;
      --baseline-rows: 5;
      --gap: 6px;
      --grid-max-width: 420px;
      --cell-font-scale: 0.38;
    }

    .memory-grid {
      --cols: var(--baseline-cols);
      display: grid;
      grid-template-columns: repeat(var(--cols), 1fr);
      gap: var(--gap);
      max-width: var(--grid-max-width);
      margin: 0 auto;
      padding: 0.35rem;
      border-radius: 8px;
      background: #fff;
      position: relative;
      transition: box-shadow 0.2s ease;
      max-height: 70vh;
    }

    .cell {
      position: relative;
      background: #e0e0e0;
      border-radius: 4px;
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
      font-weight: 600;
      color: #000;
      user-select: none;
      border: 1px solid #d0d0d0;
      transition: background-color 0.15s ease, transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }

    /* Occupied memory cell (has a Node) */
    .cell.allocated {
      background: #ebf3ff;
      border-color: #0b84f3;
    }

    /* The current targeted memory cell */
    .cell.current {
      box-shadow: 0 0 0 3px #F0B800 inset, 0 0 12px rgba(240,184,0,0.7);
      animation: pulse 0.8s ease-in-out infinite alternate;
    }
    @keyframes pulse {
      from { transform: scale(1); }
      to   { transform: scale(0.98); }
    }

    .content {
      width: 100%;
      height: 100%;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 2px;
      text-align: center;
      line-break: anywhere;
      word-break: break-word;
      font-size: 12px;
    }

    /* Overlay for arrows and walker */
    .grid-wrap {
      position: relative;
      width: 100%;
      max-width: var(--grid-max-width);
      margin: 0 auto;
    }
    #arrowLayer {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      overflow: visible;
    }
    .walker {
      position: absolute;
      width: 14px;
      height: 14px;
      background: #0b84f3;
      border: 2px solid #fff;
      border-radius: 3px;
      box-shadow: 0 0 6px rgba(11,132,243,0.6);
      pointer-events: none;
      transform: translate(-9999px, -9999px);
      transition: transform 0.25s ease-in-out;
      z-index: 3;
    }

    .inline-inputs { display:flex; align-items:center; gap:0.4rem; flex-wrap:wrap; }
    .inline-inputs input[type="text"],
    .inline-inputs input[type="number"] {
      padding: 0.35rem 0.5rem;
      border: 1px solid #ccc;
      border-radius: 4px;
      min-width: 120px;
      font-size: 0.9rem;
    }

    .metrics { display:grid; grid-template-columns: repeat(3, auto); gap:0.75rem 1rem; font-size:0.92rem; margin-top:0.25rem; }
    .status { margin-top:0.4rem; min-height:1.4rem; font-size:0.92rem; }

    .legend .row { display:flex; align-items:center; gap:0.5rem; }
    .legend .key { display:flex; align-items:center; gap:0.4rem; }
    .legend .box { width:14px; height:14px; border-radius:3px; border:1px solid #999; }
    .legend .box.unused { background:#e0e0e0; border-color:#d0d0d0; }
    .legend .box.alloc  { background:#ebf3ff; border-color:#0b84f3; }
    .legend .focus { border:2px solid #F0B800; width:14px; height:14px; border-radius:3px; }

    .inspector { font-family: ui-monospace, Consolas, Menlo, monospace; background:#f8f9fa; padding:0.5rem; border-radius:6px; border:1px solid #eee; }
  </style>
</head>
<body>
  <div class="container">
    <a href="../../../index.html" class="back-link">← Back to Code Widgets</a>
    <h1>Singly Linked List — Memory Visualizer</h1>

    <div class="controls-container">
      <aside class="sidebar">
        <div class="controls">
          <div class="control inline">
            <button id="createBtn" class="widget-action-button">Create new list</button>
          </div>

          <div class="control">
            <div class="inline-inputs">
              <label for="nodeValue"><strong>Value</strong></label>
              <input id="nodeValue" type="text" placeholder="e.g. 7 or 'cat'" />
              <button id="prependBtn" class="widget-action-button">prepend()</button>
              <button id="appendBtn" class="widget-action-button">append()</button>
            </div>
          </div>

          <div class="control">
            <div class="inline-inputs">
              <label for="containsValue"><strong>Value</strong></label>
              <input id="containsValue" type="text" placeholder="value to search" />
              <button id="containsBtn" class="widget-action-button">contains()</button>
            </div>
          </div>

          <div class="control inline">
            <button id="traverseBtn" class="widget-action-button">traverse()</button>
            <button id="toStringBtn" class="widget-action-button">toString()</button>
          </div>

          <div class="control">
            <label for="speedSlider">Animation speed (steps per second): <span id="speedLabel">2</span></label>
            <input id="speedSlider" type="range" min="0.25" max="5" step="0.25" value="2" />
          </div>

          <div class="legend">
            <h3>Legend</h3>
            <div class="row"><div class="key"><span class="box unused"></span> Unused memory</div></div>
            <div class="row"><div class="key"><span class="box alloc"></span> Node allocated</div></div>
            <div class="row"><div class="key"><span class="focus"></span> Current targeted cell</div></div>
          </div>

          <div class="info">
            <h3>List facts</h3>
            <p><strong>Nodes</strong> live anywhere in memory; each stores <code>data</code> and <code>next</code>.</p>
            <p><strong>Traversal</strong> follows <code>next</code> pointers from <em>head</em> to <code>null</code>.</p>
            <div class="metrics">
              <div><strong>Size</strong>: <span id="sizeMetric">0</span></div>
              <div><strong>Head</strong>: <span id="headMetric">null</span></div>
              <div><strong>Growth</strong>: nodes at random addresses</div>
            </div>
            <div class="status" id="status" aria-live="polite"></div>
          </div>

          <div class="info inspector" id="inspector" aria-live="polite">
            Hover a node to inspect its internals.
          </div>

          <div class="control inline">
            <button id="doublyBtn" class="widget-action-button" title="Coming soon">Enable doubly linked list</button>
          </div>
        </div>
      </aside>

      <main class="chartarea">
        <div class="grid-wrap" id="gridWrap">
          <svg id="arrowLayer" xmlns="http://www.w3.org/2000/svg">
            <defs>
              <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="10" refY="3.5" orient="auto" markerUnits="strokeWidth">
                <polygon points="0 0, 10 3.5, 0 7" fill="#0b84f3" />
              </marker>
            </defs>
            <path id="hoverArrow" d="" stroke="#0b84f3" stroke-width="2.5" fill="none" marker-end="url(#arrowhead)" opacity="0"></path>
          </svg>
          <div id="grid" class="memory-grid" aria-label="Program memory grid" style="--cols: var(--baseline-cols);"></div>
          <div id="walker" class="walker" aria-hidden="true"></div>
        </div>
        <div class="output" id="output" aria-live="polite"></div>
      </main>
    </div>
  </div>

  <script>
    (() => {
      // ---------- STATE ----------
      const state = {
        baselineCols: 10,
        baselineRows: 5,
        memoryCapacity: 50, // cells in memory grid
        memory: [],         // array of Node | null
        head: null,         // address (index) or null
        size: 0,
        stepsPerSecond: 2,
        busy: false
      };

      // ---------- DOM ----------
      const grid = document.getElementById('grid');
      const gridWrap = document.getElementById('gridWrap');
      const output = document.getElementById('output');
      const statusEl = document.getElementById('status');
      const inspector = document.getElementById('inspector');
      const arrowLayer = document.getElementById('arrowLayer');
      const hoverArrow = document.getElementById('hoverArrow');
      const walker = document.getElementById('walker');

      const createBtn   = document.getElementById('createBtn');
      const prependBtn  = document.getElementById('prependBtn');
      const appendBtn   = document.getElementById('appendBtn');
      const containsBtn = document.getElementById('containsBtn');
      const traverseBtn = document.getElementById('traverseBtn');
      const toStringBtn = document.getElementById('toStringBtn');
      const doublyBtn   = document.getElementById('doublyBtn');

      const nodeValueInput     = document.getElementById('nodeValue');
      const containsValueInput = document.getElementById('containsValue');

      const speedSlider = document.getElementById('speedSlider');
      const speedLabel  = document.getElementById('speedLabel');

      const sizeMetric = document.getElementById('sizeMetric');
      const headMetric = document.getElementById('headMetric');

      // ---------- UTILITIES ----------
      const sleep = (ms) => new Promise(res => setTimeout(res, ms));
      const stepPause = () => sleep(Math.max(5, 1000 / state.stepsPerSecond));

      const setBusy = (on) => {
        state.busy = on;
        [createBtn, prependBtn, appendBtn, containsBtn, traverseBtn, toStringBtn, doublyBtn,
         nodeValueInput, containsValueInput, speedSlider].forEach(el => el.disabled = on);
      };

      const setStatus = (msg) => { statusEl.textContent = msg || ''; };

      function totalCellsNeeded() {
        const baseline = state.baselineCols * state.baselineRows;
        return Math.max(baseline, state.memoryCapacity);
      }

      function getCells() { return Array.from(grid.querySelectorAll('.cell')); }
      function getCellAt(addr) { return grid.querySelector(`.cell[data-addr="${addr}"]`); }

      function clearCurrent() { getCells().forEach(c => c.classList.remove('current')); }
      function highlightIndex(i) {
        clearCurrent();
        const cells = getCells();
        if (i >= 0 && i < cells.length) {
          cells[i].classList.add('current');
          cells[i].scrollIntoView({ block: 'nearest', inline: 'nearest', behavior: 'smooth' });
        }
      }

      function updateMetrics() {
        sizeMetric.textContent = state.size;
        headMetric.textContent = (state.head == null ? 'null' : String(state.head));
      }

      function updateCellFontSize() {
        const firstCell = grid.querySelector('.cell');
        if (!firstCell) return;
        const w = firstCell.getBoundingClientRect().width || 28;
        const px = Math.max(9, Math.min(24, Math.floor(w * parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--cell-font-scale')))));
        getCells().forEach(cell => {
          const content = cell.querySelector('.content');
          if (content) content.style.fontSize = px + 'px';
        });
      }

      function ensureMemorySize(minCapacity) {
        if (state.memoryCapacity >= minCapacity) return;
        state.memoryCapacity = minCapacity;
        // Extend memory array with nulls
        if (state.memory.length < state.memoryCapacity) {
          state.memory.length = state.memoryCapacity;
        }
      }

      function expandMemoryByOneRow() {
        ensureMemorySize(state.memoryCapacity + state.baselineCols);
      }

      // Render the entire grid based on current state
      function renderGrid() {
        grid.innerHTML = '';
        grid.style.setProperty('--cols', state.baselineCols);

        const total = totalCellsNeeded();
        for (let i = 0; i < total; i++) {
          const cell = document.createElement('div');
          cell.className = 'cell';
          cell.dataset.addr = String(i);
          if (state.memory[i]) cell.classList.add('allocated');

          const content = document.createElement('div');
          content.className = 'content';
          content.textContent = state.memory[i] ? String(state.memory[i].data) : '';
          cell.appendChild(content);

          grid.appendChild(cell);
        }
        updateCellFontSize();
        updateMetrics();
        // Sync arrow layer size to gridWrap box
        queueMicrotask(updateArrowLayerSize);
      }

      function refreshCells() {
        const cells = getCells();
        for (let i = 0; i < cells.length; i++) {
          const content = cells[i].querySelector('.content');
          const has = !!state.memory[i];
          cells[i].classList.toggle('allocated', has);
          content.textContent = has ? String(state.memory[i].data) : '';
        }
        updateCellFontSize();
        updateMetrics();
      }

      // ---------- MEMORY / NODES ----------
      function randomFreeAddress() {
        const free = [];
        for (let i = 0; i < state.memoryCapacity; i++) {
          if (!state.memory[i]) free.push(i);
        }
        if (free.length === 0) {
          expandMemoryByOneRow();
          return randomFreeAddress();
        }
        const idx = Math.floor(Math.random() * free.length);
        return free[idx];
      }

      function createNodeAtRandom(data) {
        const addr = randomFreeAddress();
        state.memory[addr] = { data, next: null };
        state.size += 1;
        return addr;
      }

      function listAddresses() {
        const addrs = [];
        let p = state.head;
        const guard = state.memoryCapacity + 1; // safety
        let steps = 0;
        while (p != null && steps < guard) {
          addrs.push(p);
          const node = state.memory[p];
          if (!node) break;
          p = node.next;
          steps++;
        }
        return addrs;
      }

      // ---------- ARROWS / COORDS ----------
      function updateArrowLayerSize() {
        const r = gridWrap.getBoundingClientRect();
        arrowLayer.setAttribute('width', String(r.width));
        arrowLayer.setAttribute('height', String(r.height));
        arrowLayer.setAttribute('viewBox', `0 0 ${Math.max(1, Math.floor(r.width))} ${Math.max(1, Math.floor(r.height))}`);
      }

      function getCellCenter(addr) {
        const cell = getCellAt(addr);
        if (!cell) return null;
        const cr = cell.getBoundingClientRect();
        const wr = gridWrap.getBoundingClientRect();
        const x = (cr.left + cr.right) / 2 - wr.left;
        const y = (cr.top + cr.bottom) / 2 - wr.top;
        return { x, y };
      }

      function clearHoverArrow() {
        hoverArrow.setAttribute('d', '');
        hoverArrow.setAttribute('opacity', '0');
      }

      function drawHoverArrow(fromAddr) {
        const node = state.memory[fromAddr];
        if (!node || node.next == null) { clearHoverArrow(); return; }
        const p1 = getCellCenter(fromAddr);
        const p2 = getCellCenter(node.next);
        if (!p1 || !p2) { clearHoverArrow(); return; }
        updateArrowLayerSize();
        const d = `M ${p1.x} ${p1.y} L ${p2.x} ${p2.y}`;
        hoverArrow.setAttribute('d', d);
        hoverArrow.setAttribute('opacity', '1');
      }

      // ---------- WALKER (Traversal cursor) ----------
      function placeWalkerAt(addr) {
        const c = getCellCenter(addr);
        if (!c) return;
        walker.style.transform = `translate(${Math.round(c.x - 7)}px, ${Math.round(c.y - 7)}px)`;
      }

      async function moveWalkerTo(addr) {
        const c = getCellCenter(addr);
        if (!c) return;
        const dur = Math.max(80, Math.floor(800 / state.stepsPerSecond));
        walker.style.transition = `transform ${dur}ms ease-in-out`;
        walker.style.transform = `translate(${Math.round(c.x - 7)}px, ${Math.round(c.y - 7)}px)`;
        await sleep(dur);
      }

      function hideWalker() {
        walker.style.transform = 'translate(-9999px, -9999px)';
      }

      // ---------- OPERATIONS ----------
      async function opCreate() {
        if (state.busy) return;
        setBusy(true);
        try {
          state.memoryCapacity = state.baselineCols * state.baselineRows;
          state.memory = new Array(state.memoryCapacity).fill(null);
          state.head = null;
          state.size = 0;
          setStatus('Initialized an empty list.');
          clearHoverArrow();
          hideWalker();
          renderGrid();
        } finally { setBusy(false); }
      }

      async function opPrepend() {
        if (state.busy) return;
        setBusy(true);
        try {
          if (!state.memory || state.memory.length === 0) await opCreate();
          let val = nodeValueInput.value;
          if (val.trim() === '') val = String(state.size);
          const addr = createNodeAtRandom(val);
          state.memory[addr].next = state.head;
          state.head = addr;
          setStatus(`prepend(${JSON.stringify(val)}) @ addr ${addr}`);
          renderGrid();
          highlightIndex(addr);
          await stepPause();
          clearCurrent();
          nodeValueInput.value = '';
        } finally { setBusy(false); }
      }

      async function opAppend() {
        if (state.busy) return;
        setBusy(true);
        try {
          if (!state.memory || state.memory.length === 0) await opCreate();
          let val = nodeValueInput.value;
          if (val.trim() === '') val = String(state.size);
          const addr = createNodeAtRandom(val);
          setStatus(`append(${JSON.stringify(val)}) @ addr ${addr}`);

          if (state.head == null) {
            state.head = addr;
            renderGrid();
            highlightIndex(addr);
            await stepPause();
            clearCurrent();
            nodeValueInput.value = '';
            return;
          }

          // Walk to tail (animate walker)
          const path = listAddresses();
          if (path.length) placeWalkerAt(path[0]);
          for (let i = 1; i < path.length; i++) {
            highlightIndex(path[i]);
            await moveWalkerTo(path[i]);
            await stepPause();
          }
          const tail = path[path.length - 1];
          state.memory[tail].next = addr;
          renderGrid();
          highlightIndex(addr);
          await stepPause();
          clearCurrent();
          nodeValueInput.value = '';
        } finally { setBusy(false); }
      }

      async function opContains() {
        if (state.busy) return;
        setBusy(true);
        try {
          const needle = containsValueInput.value;
          if (needle.trim() === '') { setStatus('Enter a value to search for.'); return; }
          if (state.head == null) { setStatus('List is empty.'); return; }
          setStatus(`contains(${JSON.stringify(needle)}) — traverse from head`);
          const path = listAddresses();
          if (path.length) placeWalkerAt(path[0]);
          for (let i = 0; i < path.length; i++) {
            const addr = path[i];
            highlightIndex(addr);
            if (i > 0) await moveWalkerTo(addr);
            await stepPause();
            const node = state.memory[addr];
            if (String(node.data) === needle) {
              setStatus(`Found at addr ${addr}. contains() → true`);
              await stepPause();
              clearCurrent();
              return;
            }
          }
          setStatus('Not found. contains() → false');
          await stepPause();
          clearCurrent();
        } finally { setBusy(false); }
      }

      async function opTraverse() {
        if (state.busy) return;
        setBusy(true);
        try {
          if (state.head == null) { setStatus('List is empty.'); return; }
          setStatus('Traverse from head to null');
          const path = listAddresses();
          if (!path.length) return;
          placeWalkerAt(path[0]);
          highlightIndex(path[0]);
          await stepPause();
          for (let i = 1; i < path.length; i++) {
            await moveWalkerTo(path[i]);
            highlightIndex(path[i]);
            await stepPause();
          }
          clearCurrent();
          setStatus('Traversal complete.');
        } finally { setBusy(false); }
      }

      async function opToString() {
        if (state.busy) return;
        setBusy(true);
        try {
          setStatus('Building string representation: [a -> b -> ...]');
          output.textContent = '';
          const addrs = listAddresses();
          for (let i = 0; i < addrs.length; i++) {
            highlightIndex(addrs[i]);
            await stepPause();
          }
          clearCurrent();
          const vals = addrs.map(a => state.memory[a]?.data);
          output.textContent = '[' + vals.join(' -> ') + ']';
          setStatus('toString() complete.');
        } finally { setBusy(false); }
      }

      // ---------- EVENTS ----------
      createBtn.addEventListener('click', opCreate);
      prependBtn.addEventListener('click', opPrepend);
      appendBtn.addEventListener('click', opAppend);
      containsBtn.addEventListener('click', opContains);
      traverseBtn.addEventListener('click', opTraverse);
      toStringBtn.addEventListener('click', opToString);
      doublyBtn.addEventListener('click', () => {
        setStatus('Doubly linked list mode is coming soon.');
      });

      speedSlider.addEventListener('input', () => {
        state.stepsPerSecond = parseFloat(speedSlider.value);
        speedLabel.textContent = speedSlider.value;
      });

      // Hover inspector + arrow drawing
      grid.addEventListener('mouseover', (e) => {
        const cell = e.target.closest('.cell');
        if (!cell) return;
        const addr = parseInt(cell.dataset.addr || '', 10);
        const node = state.memory[addr];
        if (node) {
          inspector.textContent = `Node@${addr} { data: ${JSON.stringify(node.data)}, next: ${node.next == null ? 'null' : node.next} }`;
          drawHoverArrow(addr);
        } else {
          inspector.textContent = 'Empty cell';
          clearHoverArrow();
        }
      });
      grid.addEventListener('mouseleave', () => {
        inspector.textContent = 'Hover a node to inspect its internals.';
        clearHoverArrow();
      });

      window.addEventListener('resize', () => {
        updateCellFontSize();
        updateArrowLayerSize();
      });

      // ---------- INIT ----------
      (function init() {
        state.memory = new Array(state.memoryCapacity).fill(null);
        renderGrid();
        setStatus('Click “Create new list” then prepend/append nodes. Hover a node to see its internals and an arrow to its next.');
        speedLabel.textContent = speedSlider.value;
        state.stepsPerSecond = parseFloat(speedSlider.value);
      })();
    })();
  </script>
</body>
</html>



