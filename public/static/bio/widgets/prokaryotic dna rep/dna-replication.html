<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>DNA Replication (Prokaryotic) â€“ Step-by-Step</title>
    <link rel="stylesheet" href="replication.css" />
  </head>
  <body>
    <main id="replication-demo">
      <h1> Prokaryotic DNA Replication</h1>
      <div class="stage">
        <svg id="replication-svg" viewBox="0 0 1200 600" role="img" aria-label="DNA double helix visualization">
          <desc>Static depiction of a double helix along the x-axis (no replication bubble)</desc>
          <g id="double-helix"></g>
        </svg>
      </div>
      <div class="controls" aria-label="Replication controls">
        <button id="helicase-start" type="button">Unwind DNA Helix (Helicase)</button>
        <button id="primase-start" type="button" aria-label="Lay down RNA primers (Primase)" style="display:none" disabled>Lay down primers (Primase)</button>
        <span id="helicase-status" aria-hidden="true"></span>
        <span id="primase-status" aria-hidden="true"></span>
        <button id="pol3-start" type="button" style="display:none" disabled>DNA Pol III</button>
        <button id="pol1-start" type="button" aria-label="Replace RNA primers with DNA (DNA Pol I)" style="display:none" disabled>DNA Pol I</button>
        <button id="helicase-reset" type="button" style="display:none">Reset</button>
      </div>

    </main>
    <script>
      (function() {
        const svg = document.getElementById('replication-svg');
        const g = document.getElementById('double-helix');
        if (!svg || !g) return;

        const NS = 'http://www.w3.org/2000/svg';
        const startX = 80;           // left margin
        const endX = 1120;           // right margin
        const centerY = 300;         // axis along x
        const amplitude = 80;        // helical radius (vertical)
        const wavelength = 200;      // length of one turn (px)
        const step = 8;              // sampling resolution (px)
        const basePairEvery = 20;    // spacing between base pairs (px)

        // Helicase animation settings
        const helicaseStartX = startX; // begin at the left edge of the helix
        const helicaseEndX = 1000;
        const helicaseSpeed = 220;   // px per second
        const maxForkSpread = 140;   // maximum additional separation of single strands
        const spreadScale = 140;     // controls how quickly fork opens

        // Primase/primer visualization settings (compressed for clarity)
        const okazakiSpacingPx = 200;
        const primerLengthPx = 40;
        const primerBlockWidth = 28;
        const primerBlockHeight = 12;

        // Elements
        const basepairsGroup = document.createElementNS(NS, 'g');
        basepairsGroup.setAttribute('class', 'basepairs');
        const backboneAPath = document.createElementNS(NS, 'path');
        backboneAPath.setAttribute('class', 'backbone backbone-a');
        const backboneBPath = document.createElementNS(NS, 'path');
        backboneBPath.setAttribute('class', 'backbone backbone-b');
        const templateAPath = document.createElementNS(NS, 'path');
        templateAPath.setAttribute('class', 'template template-a');
        const templateBPath = document.createElementNS(NS, 'path');
        templateBPath.setAttribute('class', 'template template-b');
        // Group for synthesized leading strand (DNA Pol III)
        const pol3Group = document.createElementNS(NS, 'g');
        pol3Group.setAttribute('id', 'pol3-leading');
        // Group for synthesized lagging strand (Okazaki fragments)
        const pol3LagGroup = document.createElementNS(NS, 'g');
        pol3LagGroup.setAttribute('id', 'pol3-lagging');
        // Group for DNA Pol I (primer replacement)
        const pol1Group = document.createElementNS(NS, 'g');
        pol1Group.setAttribute('id', 'pol1');
        // Small connector segments drawn at completion to join unwound strands
        // to the residual helical tail visually
        const junctionTopPath = document.createElementNS(NS, 'path');
        junctionTopPath.setAttribute('class', 'template template-a');
        const junctionBottomPath = document.createElementNS(NS, 'path');
        junctionBottomPath.setAttribute('class', 'template template-b');

        // Group for primers (RNA) and labels
        const primersGroup = document.createElementNS(NS, 'g');
        primersGroup.setAttribute('id', 'primers');

        const topLabel = document.createElementNS(NS, 'text');
        topLabel.setAttribute('class', 'label prime');
        topLabel.textContent = "3'";
        const bottomLabel = document.createElementNS(NS, 'text');
        bottomLabel.setAttribute('class', 'label prime');
        bottomLabel.textContent = "5'";

        const helicase = document.createElementNS(NS, 'polygon');
        helicase.setAttribute('class', 'helicase');
        // Helicase triangle geometry (isosceles, pointing right)
        const helicaseLength = 32; // tip (front) to base distance
        const helicaseHeight = 32; // base height
        function setHelicasePoints(forkX) {
          const xTip = forkX;
          const xBase = forkX - helicaseLength;
          const halfH = helicaseHeight / 2;
          const points = `${xTip},${centerY} ${xBase},${centerY - halfH} ${xBase},${centerY + halfH}`;
          helicase.setAttribute('points', points);
        }
        setHelicasePoints(helicaseStartX);

        // Build initial basepairs and store x on elements
        for (let x = startX; x <= endX; x += basePairEvery) {
          const phase = (2 * Math.PI * (x - startX)) / wavelength;
          const yA = centerY + amplitude * Math.sin(phase);
          const yB = centerY + amplitude * Math.sin(phase + Math.PI);
          const tilt = 8 * Math.cos(phase);
          const ln = document.createElementNS(NS, 'line');
          ln.setAttribute('x1', x);
          ln.setAttribute('y1', yA - tilt);
          ln.setAttribute('x2', x);
          ln.setAttribute('y2', yB + tilt);
          ln.dataset.x = String(x);
          basepairsGroup.appendChild(ln);
        }

        // Easing for fork spread to avoid a sharp corner at the helicase
        function forkOffsetLeft(x, forkX) {
          const dx = forkX - x; // distance behind helicase
          if (dx <= 0) return 0;
          const t = 1 - Math.exp(-dx / spreadScale); // 0 -> 1
          return maxForkSpread * t;
        }

        function buildPaths(forkX) {
          let dBackA = '';
          let dBackB = '';
          let dTempA = '';
          let dTempB = '';
          let startedBackA = false;
          let startedBackB = false;
          let startedTempA = false;
          let startedTempB = false;

          for (let x = startX; x <= endX; x += step) {
            const phase = (2 * Math.PI * (x - startX)) / wavelength;
            const yHelixA = centerY + amplitude * Math.sin(phase);
            const yHelixB = centerY + amplitude * Math.sin(phase + Math.PI);

            if (x < forkX) {
              // Behind helicase: single strands without sinusoidal shape
              const off = forkOffsetLeft(x, forkX);
              const yTop = centerY - off;
              const yBottom = centerY + off;
              if (!startedTempA) { dTempA += 'M ' + x + ' ' + yTop; startedTempA = true; }
              else { dTempA += ' L ' + x + ' ' + yTop; }
              if (!startedTempB) { dTempB += 'M ' + x + ' ' + yBottom; startedTempB = true; }
              else { dTempB += ' L ' + x + ' ' + yBottom; }
            } else {
              // Ahead of helicase: intact double helix
              if (!startedBackA) { dBackA += 'M ' + x + ' ' + yHelixA; startedBackA = true; }
              else { dBackA += ' L ' + x + ' ' + yHelixA; }
              if (!startedBackB) { dBackB += 'M ' + x + ' ' + yHelixB; startedBackB = true; }
              else { dBackB += ' L ' + x + ' ' + yHelixB; }
            }
          }

          return { dBackA, dBackB, dTempA, dTempB };
        }

        function updateBasepairs(forkX) {
          const lines = basepairsGroup.children;
          for (let i = 0; i < lines.length; i++) {
            const ln = lines[i];
            const x = Number(ln.dataset.x || '0');
            // Show base pairs only ahead of helicase; hide at/behind fork
            ln.style.display = x > forkX ? '' : 'none';
          }
        }

        function makePrimer(x, y, isLeading) {
          const ln = document.createElementNS(NS, 'line');
          const half = primerLengthPx / 2;
          ln.setAttribute('x1', String(x - half));
          ln.setAttribute('y1', String(y));
          ln.setAttribute('x2', String(x + half));
          ln.setAttribute('y2', String(y));
          ln.setAttribute('class', 'primer ' + (isLeading ? 'primer-leading' : 'primer-lagging'));
          primersGroup.appendChild(ln);
          return ln;
        }

        function makePrimerRect(xCenter, yCenter, isLeading) {
          const rect = document.createElementNS(NS, 'rect');
          const w = primerBlockWidth;
          const h = primerBlockHeight;
          rect.setAttribute('x', String(xCenter - w / 2));
          rect.setAttribute('y', String(yCenter - h / 2));
          rect.setAttribute('width', String(w));
          rect.setAttribute('height', String(h));
          rect.setAttribute('rx', '3');
          rect.setAttribute('class', 'primer-block ' + (isLeading ? 'primer-block-leading' : 'primer-block-lagging'));
          primersGroup.appendChild(rect);
          return rect;
        }

        // Primase enzyme visualization (cyan oval)
        const primase = document.createElementNS(NS, 'ellipse');
        primase.setAttribute('class', 'primase');
        const primaseRx = 14;
        const primaseRy = 10;
        function setPrimasePosition(xCenter, yCenter) {
          primase.setAttribute('cx', String(xCenter));
          primase.setAttribute('cy', String(yCenter));
          primase.setAttribute('rx', String(primaseRx));
          primase.setAttribute('ry', String(primaseRy));
        }

        function render(forkX) {
          const { dBackA, dBackB, dTempA, dTempB } = buildPaths(forkX);
          backboneAPath.setAttribute('d', dBackA || `M ${startX} ${centerY}`);
          backboneBPath.setAttribute('d', dBackB || `M ${startX} ${centerY}`);
          templateAPath.setAttribute('d', dTempA || `M ${forkX} ${centerY}`);
          templateBPath.setAttribute('d', dTempB || `M ${forkX} ${centerY}`);
          updateBasepairs(forkX);

          // Update 3'/5' labels at the LEFTMOST end of the open fork
          const xLeftEdge = startX;
          const offLeftEdge = forkOffsetLeft(xLeftEdge, forkX);
          topLabel.setAttribute('x', String(xLeftEdge - 22));
          topLabel.setAttribute('y', String(centerY - offLeftEdge - 6));
          bottomLabel.setAttribute('x', String(xLeftEdge - 22));
          bottomLabel.setAttribute('y', String(centerY + offLeftEdge + 14));
        }

        // Create smooth connectors that continue the helix into the unwound strands
        let junctionsAdded = false;
        function addCompletionJunctions(forkX) {
          if (junctionsAdded) return;
          // Compute the exact tip x-position of the unwound strands (last sampled x before fork)
          const eps = 1e-3;
          const k = Math.max(0, Math.floor((forkX - startX - eps) / step));
          const x0 = startX + k * step; // unwound tip
          const x1 = forkX; // helix boundary

          // Unwound strand positions
          const y0Top = centerY - forkOffsetLeft(x0, forkX);
          const y0Bottom = centerY + forkOffsetLeft(x0, forkX);

          // Helix position and slope at the boundary
          const phase = (2 * Math.PI * (x1 - startX)) / wavelength;
          const y1Top = centerY + amplitude * Math.sin(phase);
          const y1Bottom = centerY + amplitude * Math.sin(phase + Math.PI);
          // Continue the helix pattern until it meets the unwound strands
          function yHelixTopAt(x) {
            const ph = (2 * Math.PI * (x - startX)) / wavelength;
            return centerY + amplitude * Math.sin(ph);
          }
          function yHelixBottomAt(x) {
            const ph = (2 * Math.PI * (x - startX)) / wavelength;
            return centerY + amplitude * Math.sin(ph + Math.PI);
          }
          function yUnwoundTopAt(x) {
            return centerY - forkOffsetLeft(x, forkX);
          }
          function yUnwoundBottomAt(x) {
            return centerY + forkOffsetLeft(x, forkX);
          }

          // Find join x for top by searching left from fork for closest intersection
          const searchWidth = 120;
          const dx = Math.max(2, Math.min(6, step));
          let bestTopX = x1, bestTopErr = Infinity, prevX = x1, prevErr = yUnwoundTopAt(x1) - yHelixTopAt(x1);
          for (let x = x1 - dx; x >= Math.max(startX, x1 - searchWidth); x -= dx) {
            const err = yUnwoundTopAt(x) - yHelixTopAt(x);
            if (Math.abs(err) < bestTopErr) { bestTopErr = Math.abs(err); bestTopX = x; }
            // sign change -> interpolate a tighter crossing estimate
            if ((prevErr <= 0 && err >= 0) || (prevErr >= 0 && err <= 0)) {
              const t = prevErr === err ? 0 : prevErr / (prevErr - err);
              const xCross = prevX + t * (x - prevX);
              bestTopX = xCross;
              break;
            }
            prevX = x; prevErr = err;
          }
          // Build helix polyline from fork to join for top
          let dTop = `M ${x1} ${y1Top}`;
          for (let x = x1 - dx; x > bestTopX; x -= dx) {
            dTop += ` L ${x} ${yHelixTopAt(x)}`;
          }
          dTop += ` L ${bestTopX} ${yHelixTopAt(bestTopX)}`;

          // Find join x for bottom similarly
          let bestBottomX = x1, bestBottomErr = Infinity, prevXB = x1, prevErrB = yUnwoundBottomAt(x1) - yHelixBottomAt(x1);
          for (let x = x1 - dx; x >= Math.max(startX, x1 - searchWidth); x -= dx) {
            const err = yUnwoundBottomAt(x) - yHelixBottomAt(x);
            if (Math.abs(err) < bestBottomErr) { bestBottomErr = Math.abs(err); bestBottomX = x; }
            if ((prevErrB <= 0 && err >= 0) || (prevErrB >= 0 && err <= 0)) {
              const t = prevErrB === err ? 0 : prevErrB / (prevErrB - err);
              const xCross = prevXB + t * (x - prevXB);
              bestBottomX = xCross;
              break;
            }
            prevXB = x; prevErrB = err;
          }
          let dBottom = `M ${x1} ${y1Bottom}`;
          for (let x = x1 - dx; x > bestBottomX; x -= dx) {
            dBottom += ` L ${x} ${yHelixBottomAt(x)}`;
          }
          dBottom += ` L ${bestBottomX} ${yHelixBottomAt(bestBottomX)}`;

          junctionTopPath.setAttribute('d', dTop);
          junctionBottomPath.setAttribute('d', dBottom);

          g.appendChild(junctionTopPath);
          g.appendChild(junctionBottomPath);
          junctionsAdded = true;
        }

        // Initial scene: no fork, full helix, helicase parked
        g.appendChild(basepairsGroup);
        g.appendChild(backboneAPath);
        g.appendChild(backboneBPath);
        g.appendChild(templateAPath);
        g.appendChild(templateBPath);
        g.appendChild(pol3Group);
        g.appendChild(primersGroup);
        // Place lagging products above primers for visibility
        g.appendChild(pol3LagGroup);
        // Place Pol I group above primers and Pol III products
        g.appendChild(pol1Group);
        g.appendChild(topLabel);
        g.appendChild(bottomLabel);
        g.appendChild(helicase);
        primase.style.display = 'none';
        g.appendChild(primase);

        render(startX - 1); // ensure entire length is double helix initially

        // Animation
        let animId = null;
        let helicaseX = helicaseStartX;
        let lastTs = null;
        let running = false;

        // Primase state
        let primaseActive = false;
        let primaseEnabled = false;
        let leadingPrimerPlaced = false;
        let laggingPrimersPlaced = false;

        // Pol III state and controls
        const pol3Btn = document.getElementById('pol3-start');
        const pol1Btn = document.getElementById('pol1-start');
        let helicaseCompleted = false;
        let pol3Active = false;
        let pol3Completed = false;
        let pol3AnimId = null;
        let pol3LastTs = null;
        let pol3FrontX = 0;
        let pol3Enzyme = null; // moving enzyme circle

        // Lagging Pol III state
        let pol3LagActive = false;
        let pol3LagCompleted = false;
        let pol3LagAnimId = null;
        let pol3LagLastTs = null;
        let pol3LagFrontX = 0;
        let pol3LagEnzyme = null; // moving enzyme circle (lagging)

        // Pol I state
        let pol1Active = false;
        let pol1Completed = false;
        let pol1AnimId = null;
        let pol1LastTs = null;
        let pol1Enzyme = null; // moving enzyme circle for Pol I

        // Pol III visual/animation constants
        const pol3BlockWidth = 20;
        const pol3BlockHeight = primerBlockHeight;
        const pol3BlockGap = 6;
        const pol3Speed = 280; // px per second
        const pol3Epsilon = 6; // gap from helicase
        const nucleotideColors = ['#10b981', '#ef4444', '#3b82f6', '#a855f7']; // A, T, C, G
        const pol3PathOffset = 10; // push final path further below top template
        const pol3OffsetUnder = 2; // spacing under the template for blocks/enzyme
        // Pol I visual/animation constants
        const pol1Speed = 220; // slightly slower than Pol III
        const pol1LagSpeedFactor = 1.1; // lagging strand runs ~10% faster
        const pol1Color = '#3b82f6'; // blue enzyme fill
        const pol1Stroke = '#1d4ed8'; // blue enzyme stroke

        function updatePol3CTA() {
          if (!pol3Btn) return;
          if (helicaseCompleted && leadingPrimerPlaced && laggingPrimersPlaced) {
            pol3Btn.style.display = '';
            pol3Btn.disabled = false;
          } else {
            pol3Btn.style.display = 'none';
            pol3Btn.disabled = true;
          }
        }

        function hasAnyPrimers() {
          return !!primersGroup.querySelector('rect.primer-block-leading, rect.primer-block-lagging');
        }

        function updatePol1CTA() {
          if (!pol1Btn) return;
          if (pol3Completed && pol3LagCompleted && hasAnyPrimers()) {
            pol1Btn.style.display = '';
            pol1Btn.disabled = false;
          } else {
            pol1Btn.style.display = 'none';
            pol1Btn.disabled = true;
          }
        }

        /* removed: separate lagging CTA (combined into single Pol III button) */

        const primaseBtn = document.getElementById('primase-start');

        function placeLaggingPrimers(forkX) {
          // Place multiple primers on the bottom (lagging) strand behind the helicase
          const epsilon = 4; // small gap from the fork boundary
          const marginLeft = 6; // avoid touching the extreme left edge
          const w = primerBlockWidth;
          const h = primerBlockHeight;
          const offsetTowardCenter = 2; // place just inside toward the fork center
          const xRightEdge = forkX - epsilon;

          let count = 0;
          // Start with a primer whose right edge is just left of the fork
          let xCenter = xRightEdge - (w / 2) - 2;
          // Lay primers every okazakiSpacingPx moving leftward
          while (xCenter - w / 2 > startX + marginLeft) {
            const yBottom = centerY + forkOffsetLeft(xCenter, forkX);
            const yAbove = yBottom - (h / 2) - offsetTowardCenter; // slightly above bottom strand
            makePrimerRect(xCenter, yAbove, false);
            count++;
            xCenter -= okazakiSpacingPx;
          }
          return count;
        }

        function stepAnim(ts) {
          if (!lastTs) lastTs = ts;
          const dt = (ts - lastTs) / 1000; // seconds
          lastTs = ts;

          helicaseX = Math.min(helicaseEndX, helicaseX + helicaseSpeed * dt);
          setHelicasePoints(helicaseX);
          render(helicaseX);

          // Primase remains hidden until helicase completes

          // Primase simplified: no lagging primers in this step

          if (helicaseX >= helicaseEndX) {
            running = false;
            cancelAnimationFrame(animId);
            animId = null;
            // no status text
            const resetBtn = document.getElementById('helicase-reset');
            const startBtn = document.getElementById('helicase-start');
            if (resetBtn && startBtn) {
              resetBtn.style.display = '';
              startBtn.disabled = false;
            }
            // Now reveal and enable Primase
            if (primaseBtn) {
              primaseBtn.style.display = '';
              primaseBtn.disabled = false;
            }
            primaseEnabled = true;
            // Join the remaining helix tail to the unwound strands visually
            addCompletionJunctions(helicaseX);
            helicaseCompleted = true;
            updatePol3CTA();
            return;
          }

          animId = requestAnimationFrame(stepAnim);
        }

        // Controls
        const startBtn = document.getElementById('helicase-start');
        const resetBtn = document.getElementById('helicase-reset');
        startBtn?.addEventListener('click', () => {
          if (running) return;
          running = true;
          // no status text
          startBtn.disabled = true;
          resetBtn.style.display = 'none';
          helicaseX = helicaseStartX;
          lastTs = null;
          // Ensure fork begins at the helicase location
          setHelicasePoints(helicaseX);
          // Keep fully formed helix at t=0; fork appears as motion begins
          render(helicaseX - 1);
          animId = requestAnimationFrame(stepAnim);
        });

        // Primase control
        primaseBtn?.addEventListener('click', () => {
          if (leadingPrimerPlaced && laggingPrimersPlaced) return;
          if (primaseBtn) primaseBtn.disabled = true;

          // Build primer placement positions (leading first, then lagging)
          const xLeftEdge = startX; // leftmost edge of the unwound region
          const yTop = centerY - forkOffsetLeft(xLeftEdge, helicaseX);
          const offsetUnder = 2; // small visual gap below the strand
          const yUnder = yTop + (primerBlockHeight / 2) + offsetUnder;
          const positions = [{ x: xLeftEdge, y: yUnder, leading: true }];
          // lagging primers from near fork moving leftwards
          const laggingPositions = (function() {
            const epsilon = 4;
            const marginLeft = 6;
            const w = primerBlockWidth;
            const h = primerBlockHeight;
            const offsetTowardCenter = 2;
            const xRightEdge = helicaseX - epsilon;
            const arr = [];
            let xCenter = xRightEdge - (w / 2) - 2;
            while (xCenter - w / 2 > startX + marginLeft) {
              const yBottom = centerY + forkOffsetLeft(xCenter, helicaseX);
              const yAbove = yBottom - (h / 2) - offsetTowardCenter;
              arr.push({ x: xCenter, y: yAbove, leading: false });
              xCenter -= okazakiSpacingPx;
            }
            return arr;
          })();
          positions.push(...laggingPositions);

          // Show primase enzyme and place primers sequentially
          primase.style.display = '';
          const delayMs = 600;
          let idx = 0;
          function placeNext() {
            const pos = positions[idx];
            setPrimasePosition(pos.x, pos.y);
            if (pos.leading && !leadingPrimerPlaced) {
              makePrimerRect(pos.x, pos.y, true);
              leadingPrimerPlaced = true;
            } else if (!pos.leading) {
              makePrimerRect(pos.x, pos.y, false);
            }
            idx++;
            if (idx < positions.length) {
              setTimeout(placeNext, delayMs);
            } else {
              primase.style.display = 'none';
              laggingPrimersPlaced = true;
              // no status text
              updatePol3CTA();
            }
          }
          placeNext();
        });

        function getLaggingPrimers() {
          const rects = Array.from(primersGroup.querySelectorAll('rect.primer-block-lagging'));
          const arr = rects.map(r => {
            const x = parseFloat(r.getAttribute('x') || '0');
            const w = parseFloat(r.getAttribute('width') || '0');
            const y = parseFloat(r.getAttribute('y') || '0');
            const h = parseFloat(r.getAttribute('height') || '0');
            return { xLeft: x, xRight: x + w, xCenter: x + w / 2, yCenter: y + h / 2 };
          });
          // Sort right-to-left: nearest to fork first
          arr.sort((a, b) => b.xCenter - a.xCenter);
          return arr;
        }

        // ===== DNA Pol I (Primer Replacement) =====
        let pol1FrontX = 0;

        function ensurePol1Enzyme() {
          if (pol1Enzyme) return pol1Enzyme;
          const c = document.createElementNS(NS, 'circle');
          c.setAttribute('r', String(Math.max(8, pol3BlockHeight / 2 + 6)));
          c.setAttribute('fill', pol1Color);
          c.setAttribute('stroke', pol1Stroke);
          c.setAttribute('stroke-width', '2');
          pol1Group.appendChild(c);
          pol1Enzyme = c;
          return c;
        }

        function updatePol1EnzymeTop(x) {
          if (!pol1Enzyme) return;
          const leadOffsetX = (pol3BlockWidth / 2) + pol3BlockGap + 6;
          const xFront = Math.min(x + leadOffsetX, helicaseEndX - pol3Epsilon);
          const yTop = centerY - forkOffsetLeft(xFront, helicaseEndX);
          const yCenter = yTop + (pol3BlockHeight / 2) + pol3OffsetUnder;
          pol1Enzyme.setAttribute('cx', String(xFront));
          pol1Enzyme.setAttribute('cy', String(yCenter));
          pol1Group.appendChild(pol1Enzyme);
        }

        function updatePol1EnzymeBottom(x) {
          if (!pol1Enzyme) return;
          const leadOffsetX = (pol3BlockWidth / 2) + pol3BlockGap + 6;
          const xFront = Math.max(x - leadOffsetX, startX + 6);
          const yBottom = centerY + forkOffsetLeft(xFront, helicaseEndX);
          const yCenter = yBottom - (pol3BlockHeight / 2) - pol3OffsetUnder;
          pol1Enzyme.setAttribute('cx', String(xFront));
          pol1Enzyme.setAttribute('cy', String(yCenter));
          pol1Group.appendChild(pol1Enzyme);
        }

        function makePol1BlockTop(xCenter, idx) {
          const rect = document.createElementNS(NS, 'rect');
          const yTop = centerY - forkOffsetLeft(xCenter, helicaseEndX);
          const yCenter = yTop + (pol3BlockHeight / 2) + pol3OffsetUnder;
          rect.setAttribute('x', String(xCenter - pol3BlockWidth / 2));
          rect.setAttribute('y', String(yCenter - pol3BlockHeight / 2));
          rect.setAttribute('width', String(pol3BlockWidth));
          rect.setAttribute('height', String(pol3BlockHeight));
          rect.setAttribute('rx', '3');
          rect.setAttribute('class', 'pol1-block');
          const color = nucleotideColors[idx % nucleotideColors.length];
          rect.setAttribute('fill', color);
          rect.setAttribute('style', 'fill: ' + color);
          pol1Group.appendChild(rect);
          return rect;
        }

        function makePol1BlockBottom(xCenter, idx) {
          const rect = document.createElementNS(NS, 'rect');
          const yBottom = centerY + forkOffsetLeft(xCenter, helicaseEndX);
          const yCenter = yBottom - (pol3BlockHeight / 2) - pol3OffsetUnder;
          rect.setAttribute('x', String(xCenter - pol3BlockWidth / 2));
          rect.setAttribute('y', String(yCenter - pol3BlockHeight / 2));
          rect.setAttribute('width', String(pol3BlockWidth));
          rect.setAttribute('height', String(pol3BlockHeight));
          rect.setAttribute('rx', '3');
          rect.setAttribute('class', 'pol1-block');
          const color = nucleotideColors[idx % nucleotideColors.length];
          rect.setAttribute('fill', color);
          rect.setAttribute('style', 'fill: ' + color);
          pol1Group.appendChild(rect);
          return rect;
        }

        function mergePol1PathTop(xLeft, xRight) {
          const overlap = 12; // increased overlap to avoid any seams
          const xs = Math.max(startX, xLeft - overlap);
          const xe = Math.min(helicaseEndX, xRight + overlap);
          const path = document.createElementNS(NS, 'path');
          let d = '';
          let started = false;
          for (let x = xs; x <= xe; x += step) {
            const yTop = centerY - forkOffsetLeft(x, helicaseEndX);
            const y = yTop + pol3PathOffset;
            if (!started) { d += 'M ' + x + ' ' + y; started = true; }
            else { d += ' L ' + x + ' ' + y; }
          }
          path.setAttribute('d', d || `M ${xs} ${centerY}`);
          path.setAttribute('class', 'pol3-path');
          pol3Group.appendChild(path);

          const blocks = pol1Group.querySelectorAll('rect.pol1-block');
          blocks.forEach(b => b.parentNode?.removeChild(b));
        }

        function mergePol1PathBottom(xRight, xLeft) {
          const overlap = 12; // increased overlap to avoid any seams
          const xr = Math.min(helicaseEndX, xRight + overlap);
          const xl = Math.max(startX, xLeft - overlap);
          const path = document.createElementNS(NS, 'path');
          let d = '';
          let started = false;
          const stepSize = Math.max(2, Math.min(6, step));
          for (let x = xr; x >= xl; x -= stepSize) {
            const yBottom = centerY + forkOffsetLeft(x, helicaseEndX);
            const y = yBottom - pol3PathOffset;
            if (!started) { d += 'M ' + x + ' ' + y; started = true; }
            else { d += ' L ' + x + ' ' + y; }
          }
          path.setAttribute('d', d || `M ${xr} ${centerY}`);
          path.setAttribute('class', 'pol3-path');
          pol3LagGroup.appendChild(path);

          const blocks = pol1Group.querySelectorAll('rect.pol1-block');
          blocks.forEach(b => b.parentNode?.removeChild(b));
        }

        // Travel animation for Pol I enzyme between segment starts
        function getPol1EnzymeXY() {
          if (!pol1Enzyme) return { x: 0, y: 0 };
          const cx = parseFloat(pol1Enzyme.getAttribute('cx') || '0');
          const cy = parseFloat(pol1Enzyme.getAttribute('cy') || '0');
          return { x: cx, y: cy };
        }

        function computePol1StartXYForSegment(seg) {
          const leadOffsetX = (pol3BlockWidth / 2) + pol3BlockGap + 6;
          if (seg.type === 'top') {
            const xFront = Math.min(seg.xLeft + leadOffsetX, helicaseEndX - pol3Epsilon);
            const yTop = centerY - forkOffsetLeft(xFront, helicaseEndX);
            const yCenter = yTop + (pol3BlockHeight / 2) + pol3OffsetUnder;
            return { x: xFront, y: yCenter };
          } else {
            const xFront = Math.max(seg.xRight - leadOffsetX, startX + 6);
            const yBottom = centerY + forkOffsetLeft(xFront, helicaseEndX);
            const yCenter = yBottom - (pol3BlockHeight / 2) - pol3OffsetUnder;
            return { x: xFront, y: yCenter };
          }
        }

        function travelPol1To(seg, durationMs, onDone) {
          ensurePol1Enzyme();
          const start = getPol1EnzymeXY();
          const target = computePol1StartXYForSegment(seg);
          const t0 = performance.now();

          function step(now) {
            const t = Math.min(1, (now - t0) / durationMs);
            const x = start.x + (target.x - start.x) * t;
            const y = start.y + (target.y - start.y) * t;
            pol1Enzyme.setAttribute('cx', String(x));
            pol1Enzyme.setAttribute('cy', String(y));
            pol1Group.appendChild(pol1Enzyme);
            if (t < 1) {
              requestAnimationFrame(step);
            } else {
              if (onDone) onDone();
            }
          }

          requestAnimationFrame(step);
        }

        function makePol3Block(xCenter, idx) {
          const rect = document.createElementNS(NS, 'rect');
          const yTop = centerY - forkOffsetLeft(xCenter, helicaseEndX);
          const yCenter = yTop + (pol3BlockHeight / 2) + pol3OffsetUnder;
          rect.setAttribute('x', String(xCenter - pol3BlockWidth / 2));
          rect.setAttribute('y', String(yCenter - pol3BlockHeight / 2));
          rect.setAttribute('width', String(pol3BlockWidth));
          rect.setAttribute('height', String(pol3BlockHeight));
          rect.setAttribute('rx', '3');
          rect.setAttribute('class', 'pol3-block');
          // Color by nucleotide cycling A->T->C->G
          const color = nucleotideColors[idx % nucleotideColors.length];
          rect.setAttribute('fill', color);
          rect.setAttribute('style', 'fill: ' + color);
          pol3Group.appendChild(rect);
          return rect;
        }

        function ensurePol3Enzyme() {
          if (pol3Enzyme) return pol3Enzyme;
          const c = document.createElementNS(NS, 'circle');
          c.setAttribute('r', String(Math.max(8, pol3BlockHeight / 2 + 6)));
          c.setAttribute('fill', '#8b5cf6'); // purple
          c.setAttribute('stroke', '#6d28d9');
          c.setAttribute('stroke-width', '2');
          pol3Group.appendChild(c);
          pol3Enzyme = c;
          return c;
        }

        function updatePol3EnzymePosition(x) {
          if (!pol3Enzyme) return;
          const leadOffsetX = (pol3BlockWidth / 2) + pol3BlockGap + 6; // place in front of newest block
          const xMax = helicaseEndX - pol3Epsilon;
          const xFront = Math.min(x + leadOffsetX, xMax);
          const yTop = centerY - forkOffsetLeft(xFront, helicaseEndX);
          const yCenter = yTop + (pol3BlockHeight / 2) + pol3OffsetUnder;
          pol3Enzyme.setAttribute('cx', String(xFront));
          pol3Enzyme.setAttribute('cy', String(yCenter));
          // Keep enzyme on top of newly added blocks
          pol3Group.appendChild(pol3Enzyme);
        }

        function mergePol3BlocksToPath(xStart, xEnd) {
          // Build a smooth path along the top template slightly below it
          const path = document.createElementNS(NS, 'path');
          let d = '';
          let started = false;
          for (let x = xStart; x <= xEnd; x += step) {
            const yTop = centerY - forkOffsetLeft(x, helicaseEndX);
            const y = yTop + pol3PathOffset; // increased offset under the template
            if (!started) { d += 'M ' + x + ' ' + y; started = true; }
            else { d += ' L ' + x + ' ' + y; }
          }
          path.setAttribute('d', d || `M ${xStart} ${centerY}`);
          path.setAttribute('class', 'pol3-path');
          pol3Group.appendChild(path);

          // Remove all block rects but keep the primer in its own group
          const blocks = pol3Group.querySelectorAll('rect.pol3-block');
          blocks.forEach(b => b.parentNode?.removeChild(b));

          pol3Active = false;
          pol3Completed = true;
          if (pol3Btn) pol3Btn.disabled = true;
          updatePol1CTA();
        }

        function startPol3() {
          if (pol3Active || pol3Completed) return;
          // Determine synthesis bounds
          const xStart = startX + (primerBlockWidth / 2) + pol3BlockGap;
          const xEnd = Math.max(xStart, helicaseEndX - pol3Epsilon);
          pol3FrontX = xStart;
          pol3LastTs = null;
          pol3Active = true;

          // Place blocks progressively as front advances
          let nextBlockCenterX = xStart + (pol3BlockWidth / 2);
          let nextBlockIndex = 0;

          ensurePol3Enzyme();
          updatePol3EnzymePosition(pol3FrontX);

          function stepPol3(ts) {
            if (!pol3LastTs) pol3LastTs = ts;
            const dt = (ts - pol3LastTs) / 1000;
            pol3LastTs = ts;

            pol3FrontX = Math.min(xEnd, pol3FrontX + pol3Speed * dt);

            while (nextBlockCenterX - (pol3BlockWidth / 2) <= pol3FrontX && nextBlockCenterX + (pol3BlockWidth / 2) <= xEnd) {
              makePol3Block(nextBlockCenterX, nextBlockIndex++);
              nextBlockCenterX += pol3BlockWidth + pol3BlockGap;
              // Ensure enzyme renders above newly appended block
              if (pol3Enzyme) pol3Group.appendChild(pol3Enzyme);
            }

            updatePol3EnzymePosition(pol3FrontX);

            if (pol3FrontX >= xEnd) {
              cancelAnimationFrame(pol3AnimId);
              pol3AnimId = null;
              // Remove enzyme when synthesis completes
              if (pol3Enzyme && pol3Enzyme.parentNode) pol3Enzyme.parentNode.removeChild(pol3Enzyme);
              pol3Enzyme = null;
              mergePol3BlocksToPath(xStart, xEnd);
              return;
            }

            pol3AnimId = requestAnimationFrame(stepPol3);
          }

          pol3AnimId = requestAnimationFrame(stepPol3);
        }

        pol3Btn?.addEventListener('click', () => {
          if (pol3Btn) pol3Btn.disabled = true;
          startPol3();
          startPol3Lagging();
        });

        function startPol1() {
          if (pol1Active || pol1Completed) return;
          if (!hasAnyPrimers()) return;
          pol1Active = true;
          pol1LastTs = null;
          ensurePol1Enzyme();

          // Build segment list: leading then lagging
          const segments = [];
          const leadRect = primersGroup.querySelector('rect.primer-block-leading');
          if (leadRect) {
            const x = parseFloat(leadRect.getAttribute('x') || '0');
            const w = parseFloat(leadRect.getAttribute('width') || '0');
            const xLeft = x;
            const xRight = x + w;
            const pol3Start = startX + (primerBlockWidth / 2) + pol3BlockGap;
            const xClampRight = Math.max(xLeft, Math.min(xRight, pol3Start));
            segments.push({ type: 'top', xLeft, xRight: xClampRight, rect: leadRect });
          }
          const lagRects = Array.from(primersGroup.querySelectorAll('rect.primer-block-lagging')).map(r => {
            const x = parseFloat(r.getAttribute('x') || '0');
            const w = parseFloat(r.getAttribute('width') || '0');
            const xCenter = x + w / 2;
            return { rect: r, xLeft: x, xRight: x + w, xCenter };
          }).sort((a, b) => b.xCenter - a.xCenter);
          lagRects.forEach(item => segments.push({ type: 'bottom', xLeft: item.xLeft, xRight: item.xRight, rect: item.rect }));

          let segIndex = 0;

          function runNextSegment() {
            if (segIndex >= segments.length) {
              // done
              pol1Active = false;
              pol1Completed = true;
              if (pol1Enzyme && pol1Enzyme.parentNode) pol1Enzyme.parentNode.removeChild(pol1Enzyme);
              pol1Enzyme = null;
              if (pol1Btn) pol1Btn.disabled = true;
              return;
            }

            const seg = segments[segIndex];
            if (seg.type === 'top') {
              // Move left -> right
              pol1FrontX = seg.xLeft;
              pol1LastTs = null;
              // Remove primer immediately
              if (seg.rect && seg.rect.parentNode) seg.rect.parentNode.removeChild(seg.rect);
              let nextBlockCenterX = seg.xLeft + (pol3BlockWidth / 2);
              let nextBlockIndex = 0;
              function stepTop(ts) {
                if (!pol1LastTs) pol1LastTs = ts;
                const dt = (ts - pol1LastTs) / 1000;
                pol1LastTs = ts;

                pol1FrontX = Math.min(seg.xRight, pol1FrontX + pol1Speed * dt);

                while ((nextBlockCenterX + (pol3BlockWidth / 2) <= pol1FrontX) && (nextBlockCenterX + (pol3BlockWidth / 2) <= seg.xRight)) {
                  makePol1BlockTop(nextBlockCenterX, nextBlockIndex++);
                  nextBlockCenterX += (pol3BlockWidth + pol3BlockGap);
                  if (pol1Enzyme) pol1Group.appendChild(pol1Enzyme);
                }

                updatePol1EnzymeTop(pol1FrontX);

                if (pol1FrontX >= seg.xRight) {
                  cancelAnimationFrame(pol1AnimId);
                  pol1AnimId = null;
                  // merge and remove primer
                  mergePol1PathTop(seg.xLeft, seg.xRight);
                  segIndex++;
                  if (segIndex < segments.length) {
                    const nextSeg = segments[segIndex];
                    const travelMs = nextSeg.type === 'bottom' ? 1000 : 1200;
                    travelPol1To(nextSeg, travelMs, () => runNextSegment());
                  } else {
                    runNextSegment();
                  }
                  return;
                }

                pol1AnimId = requestAnimationFrame(stepTop);
              }
              pol1AnimId = requestAnimationFrame(stepTop);
            } else {
              // bottom: Move right -> left
              pol1FrontX = seg.xRight;
              pol1LastTs = null;
              // Remove primer immediately
              if (seg.rect && seg.rect.parentNode) seg.rect.parentNode.removeChild(seg.rect);
              let nextBlockCenterX = seg.xRight - (pol3BlockWidth / 2);
              let nextBlockIndex = 0;
              function stepBottom(ts) {
                if (!pol1LastTs) pol1LastTs = ts;
                const dt = (ts - pol1LastTs) / 1000;
                pol1LastTs = ts;

                pol1FrontX = Math.max(seg.xLeft, pol1FrontX - (pol1Speed * pol1LagSpeedFactor) * dt);

                while (
                  (nextBlockCenterX - (pol3BlockWidth / 2) >= seg.xLeft) &&
                  (nextBlockCenterX + (pol3BlockWidth / 2) >= pol1FrontX)
                ) {
                  makePol1BlockBottom(nextBlockCenterX, nextBlockIndex++);
                  nextBlockCenterX -= (pol3BlockWidth + pol3BlockGap);
                  if (pol1Enzyme) pol1Group.appendChild(pol1Enzyme);
                }

                updatePol1EnzymeBottom(pol1FrontX);

                if (pol1FrontX <= seg.xLeft) {
                  cancelAnimationFrame(pol1AnimId);
                  pol1AnimId = null;
                  mergePol1PathBottom(seg.xRight, seg.xLeft);
                  segIndex++;
                  if (segIndex < segments.length) {
                    const nextSeg = segments[segIndex];
                    const travelMs = nextSeg.type === 'bottom' ? 1000 : 1200;
                    travelPol1To(nextSeg, travelMs, () => runNextSegment());
                  } else {
                    runNextSegment();
                  }
                  return;
                }

                pol1AnimId = requestAnimationFrame(stepBottom);
              }
              pol1AnimId = requestAnimationFrame(stepBottom);
            }
          }

          runNextSegment();
        }

        pol1Btn?.addEventListener('click', () => {
          if (pol1Btn) pol1Btn.disabled = true;
          startPol1();
        });

        function ensurePol3LagEnzyme() {
          if (pol3LagEnzyme) return pol3LagEnzyme;
          const c = document.createElementNS(NS, 'circle');
          c.setAttribute('r', String(Math.max(8, pol3BlockHeight / 2 + 6)));
          c.setAttribute('class', 'pol3-lag-enzyme');
          c.setAttribute('fill', '#8b5cf6');
          c.setAttribute('stroke', '#6d28d9');
          c.setAttribute('stroke-width', '2');
          pol3LagGroup.appendChild(c);
          pol3LagEnzyme = c;
          return c;
        }

        function updatePol3LagEnzymePosition(x) {
          if (!pol3LagEnzyme) return;
          const leadOffsetX = (pol3BlockWidth / 2) + pol3BlockGap + 6;
          const xMin = startX + 6;
          const xFront = Math.max(x - leadOffsetX, xMin);
          const yBottom = centerY + forkOffsetLeft(xFront, helicaseEndX);
          const yCenter = yBottom - (pol3BlockHeight / 2) - pol3OffsetUnder;
          pol3LagEnzyme.setAttribute('cx', String(xFront));
          pol3LagEnzyme.setAttribute('cy', String(yCenter));
          pol3LagGroup.appendChild(pol3LagEnzyme);
        }

        function makeLagBlock(xCenter, idx) {
          const rect = document.createElementNS(NS, 'rect');
          const yBottom = centerY + forkOffsetLeft(xCenter, helicaseEndX);
          const yCenter = yBottom - (pol3BlockHeight / 2) - pol3OffsetUnder;
          rect.setAttribute('x', String(xCenter - pol3BlockWidth / 2));
          rect.setAttribute('y', String(yCenter - pol3BlockHeight / 2));
          rect.setAttribute('width', String(pol3BlockWidth));
          rect.setAttribute('height', String(pol3BlockHeight));
          rect.setAttribute('rx', '3');
          rect.setAttribute('class', 'pol3-lag-block');
          const color = nucleotideColors[idx % nucleotideColors.length];
          rect.setAttribute('fill', color);
          rect.setAttribute('style', 'fill: ' + color);
          pol3LagGroup.appendChild(rect);
          return rect;
        }

        function mergeLagBlocksToPath(xRight, xLeft) {
          const path = document.createElementNS(NS, 'path');
          let d = '';
          let started = false;
          const stepSize = Math.max(2, Math.min(6, step));
          for (let x = xRight; x >= xLeft; x -= stepSize) {
            const yBottom = centerY + forkOffsetLeft(x, helicaseEndX);
            const y = yBottom - pol3PathOffset;
            if (!started) { d += 'M ' + x + ' ' + y; started = true; }
            else { d += ' L ' + x + ' ' + y; }
          }
          path.setAttribute('d', d || `M ${xRight} ${centerY}`);
          path.setAttribute('class', 'pol3-path');
          pol3LagGroup.appendChild(path);

          // Remove all lagging block rects for this fragment (group currently contains only those)
          const blocks = pol3LagGroup.querySelectorAll('rect.pol3-lag-block');
          blocks.forEach(b => b.parentNode?.removeChild(b));
        }

        function startPol3Lagging() {
          if (pol3LagActive || pol3LagCompleted) return;
          const primers = getLaggingPrimers();
          if (!primers.length) return;
          pol3LagActive = true;

          ensurePol3LagEnzyme();

          const leftClamp = startX + 10;
          let fragmentIndex = 0;

          function synthesizeNextFragment() {
            if (fragmentIndex >= primers.length) {
              // done
              pol3LagActive = false;
              pol3LagCompleted = true;
              if (pol3LagEnzyme && pol3LagEnzyme.parentNode) pol3LagEnzyme.parentNode.removeChild(pol3LagEnzyme);
              pol3LagEnzyme = null;
              updatePol1CTA();
              return;
            }

            const curr = primers[fragmentIndex];
            const next = primers[fragmentIndex + 1];
            const gap = pol3BlockGap;
            const xRightBound = Math.max(leftClamp + gap, curr.xLeft - gap);
            const xLeftBound = next ? Math.max(leftClamp, next.xRight + gap) : leftClamp;

            /* no status readout */

            pol3LagFrontX = xRightBound;
            pol3LagLastTs = null;

            let nextBlockCenterX = xRightBound - (pol3BlockWidth / 2);
            let nextBlockIndex = 0;

            updatePol3LagEnzymePosition(pol3LagFrontX);

            function stepFragment(ts) {
              if (!pol3LagLastTs) pol3LagLastTs = ts;
              const dt = (ts - pol3LagLastTs) / 1000;
              pol3LagLastTs = ts;

              pol3LagFrontX = Math.max(xLeftBound, pol3LagFrontX - pol3Speed * dt);

              while (
                (nextBlockCenterX - (pol3BlockWidth / 2) >= xLeftBound) &&
                (nextBlockCenterX + (pol3BlockWidth / 2) >= pol3LagFrontX)
              ) {
                makeLagBlock(nextBlockCenterX, nextBlockIndex++);
                nextBlockCenterX -= (pol3BlockWidth + pol3BlockGap);
                if (pol3LagEnzyme) pol3LagGroup.appendChild(pol3LagEnzyme);
              }

              updatePol3LagEnzymePosition(pol3LagFrontX);

              if (pol3LagFrontX <= xLeftBound) {
                cancelAnimationFrame(pol3LagAnimId);
                pol3LagAnimId = null;
                // merge this fragment and advance
                mergeLagBlocksToPath(xRightBound, xLeftBound);
                fragmentIndex++;
                synthesizeNextFragment();
                return;
              }

              pol3LagAnimId = requestAnimationFrame(stepFragment);
            }

            pol3LagAnimId = requestAnimationFrame(stepFragment);
          }

          synthesizeNextFragment();
        }

        /* removed: separate lagging start button listener (combined into single Pol III button) */

        resetBtn?.addEventListener('click', () => {
          if (animId) cancelAnimationFrame(animId);
          animId = null;
          running = false;
          // no status text
          // Restore full double helix
          render(startX - 1);
          setHelicasePoints(helicaseStartX);
          // Remove completion junctions if present
          if (junctionsAdded) {
            if (junctionTopPath.parentNode) junctionTopPath.parentNode.removeChild(junctionTopPath);
            if (junctionBottomPath.parentNode) junctionBottomPath.parentNode.removeChild(junctionBottomPath);
            junctionsAdded = false;
          }
          startBtn.disabled = false;
          resetBtn.style.display = 'none';

          // Clear primers and primase state
          while (primersGroup.firstChild) primersGroup.removeChild(primersGroup.firstChild);
          primaseActive = false;
          primaseEnabled = false;
          leadingPrimerPlaced = false;
          laggingPrimersPlaced = false;
          primase.style.display = 'none';
          if (primaseBtn) { primaseBtn.disabled = true; primaseBtn.style.display = 'none'; }

          // Clear Pol III visuals and state
          while (pol3Group.firstChild) pol3Group.removeChild(pol3Group.firstChild);
          helicaseCompleted = false;
          pol3Active = false;
          pol3Completed = false;
          if (pol3AnimId) cancelAnimationFrame(pol3AnimId);
          pol3AnimId = null;
          pol3LastTs = null;
          pol3Enzyme = null;
          if (pol3Btn) { pol3Btn.disabled = true; pol3Btn.style.display = 'none'; }

          // Clear Lagging Pol III visuals and state
          while (pol3LagGroup.firstChild) pol3LagGroup.removeChild(pol3LagGroup.firstChild);
          pol3LagActive = false;
          pol3LagCompleted = false;
          if (pol3LagAnimId) cancelAnimationFrame(pol3LagAnimId);
          pol3LagAnimId = null;
          pol3LagLastTs = null;
          pol3LagEnzyme = null;
          /* removed: separate lagging button/status reset */

          // Clear Pol I visuals and state
          while (pol1Group.firstChild) pol1Group.removeChild(pol1Group.firstChild);
          pol1Active = false;
          pol1Completed = false;
          if (pol1AnimId) cancelAnimationFrame(pol1AnimId);
          pol1AnimId = null;
          pol1LastTs = null;
          pol1Enzyme = null;
          if (pol1Btn) { pol1Btn.disabled = true; pol1Btn.style.display = 'none'; }
        });
      })();
    </script>
    <script src="consent.js"></script>
  </body>
  </html>


