<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latin Text Analyzer</title>
    <style>
        :root {
            --hw-cream: #f5f2ea;
            --hw-white: #ffffff;
            --hw-red: #b3072c;
            --hw-red-dark: #8c0522;
            --hw-dark: #1f1f1f;
            --hw-muted: #716458;
            --hw-border: #e4ddd1;
            --hw-border-strong: #d6cbb9;
            --hw-shadow: 0 32px 80px rgba(60, 44, 33, 0.12);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Work Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--hw-cream);
            color: var(--hw-dark);
            min-height: 100vh;
            padding: 32px 24px 64px;
            line-height: 1.6;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .top-bar {
            max-width: 1200px;
            margin: 0 auto 32px;
            padding: 16px 28px;
            border-radius: 20px;
            background: var(--hw-white);
            border: 1px solid var(--hw-border);
            box-shadow: var(--hw-shadow);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .brand {
            font-weight: 700;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            font-size: 0.95rem;
            color: var(--hw-red);
        }

        .nav-links {
            display: flex;
            gap: 28px;
        }

        .nav-link {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--hw-muted);
            position: relative;
            padding-bottom: 4px;
            transition: color 0.2s ease;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -6px;
            width: 0;
            height: 2px;
            background: var(--hw-red);
            transition: width 0.2s ease;
        }

        .nav-link:hover {
            color: var(--hw-dark);
        }

        .nav-link:hover::after,
        .nav-link.active::after {
            width: 100%;
        }

        .page-container {
            max-width: 1120px;
            margin: 0 auto;
        }

        .container {
            background: var(--hw-white);
            border-radius: 28px;
            padding: 48px 56px 56px;
            box-shadow: var(--hw-shadow);
            border: 1px solid var(--hw-border);
        }

        .page-intro {
            text-align: center;
            margin-bottom: 44px;
        }

        .user-directions {
            background-color: #f8f9fa;
            border: 2px solid #e9ecef;
            border-radius: 8px;
            padding: 20px;
            margin: 20px auto;
            max-width: 800px;
            text-align: left;
        }

        .user-directions p {
            margin: 10px 0;
            line-height: 1.6;
        }

        .user-directions p:first-child {
            margin-top: 0;
        }

        .user-directions p:last-child {
            margin-bottom: 0;
        }

        .eyebrow {
            display: inline-block;
            font-size: 0.75rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            font-weight: 700;
            color: var(--hw-red);
            margin-bottom: 18px;
        }

        h1 {
            font-size: 2.85rem;
            font-weight: 800;
            color: var(--hw-dark);
            margin-bottom: 12px;
        }

        .subtitle {
            max-width: 640px;
            margin: 0 auto;
            color: var(--hw-muted);
            font-size: 1.05rem;
        }

        .section {
            margin-bottom: 32px;
        }

        .section-title {
            font-size: 0.8rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: var(--hw-red);
            font-weight: 700;
            margin-bottom: 14px;
        }

        .mode-buttons {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 28px;
            font-size: 0.95rem;
            border-radius: 999px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border: 1px solid var(--hw-border-strong);
            background: var(--hw-white);
            color: var(--hw-dark);
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 160px;
        }

        button:hover {
            border-color: var(--hw-red);
            color: var(--hw-red);
            box-shadow: 0 12px 26px rgba(30, 21, 15, 0.12);
        }

        button:disabled {
            background: #ebe2d4;
            border-color: #ded4c3;
            color: #a99c8d;
            cursor: not-allowed;
            box-shadow: none;
        }

        button:disabled:hover {
            color: #a99c8d;
            border-color: #ded4c3;
        }

        .mode-button {
            background: var(--hw-white);
            color: var(--hw-muted);
        }

        .mode-button:hover {
            background: rgba(179, 7, 44, 0.08);
        }

        .mode-button.active,
        .mode-button[aria-pressed="true"] {
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            box-shadow: 0 16px 30px rgba(179, 7, 44, 0.25);
        }

        .mode-button.active:hover {
            color: var(--hw-white);
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 14px 18px;
            border: 1px solid var(--hw-border-strong);
            border-radius: 18px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background: var(--hw-white);
            color: var(--hw-dark);
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--hw-red);
            box-shadow: 0 0 0 4px rgba(179, 7, 44, 0.14);
        }

        textarea {
            resize: vertical;
            min-height: 140px;
            font-family: 'Georgia', serif;
            line-height: 1.68;
            border-radius: 22px;
        }

        #latin-input.overlay-active {
            color: transparent;
            caret-color: transparent;
        }

        #latin-input.overlay-active::selection {
            background: transparent;
            color: transparent;
        }

        .latin-input-wrapper {
            position: relative;
        }

        #latin-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 14px 18px;
            border-radius: 22px;
            font-size: 1rem;
            font-family: 'Georgia', serif;
            line-height: 1.68;
            pointer-events: none;
            background: transparent;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }

        .token {
            cursor: pointer;
            padding: 2px 0;
            border-radius: 4px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .token.highlight {
            font-weight: 600;
        }

        .token:hover {
            background: rgba(179, 7, 44, 0.12);
        }

        .word-count {
            text-align: right;
            font-size: 0.85rem;
            color: var(--hw-muted);
            margin-top: 6px;
            letter-spacing: 0.04em;
        }

        .input-warning {
            color: var(--hw-red);
            font-size: 0.9rem;
            margin-top: 6px;
            min-height: 20px;
            font-weight: 600;
        }

        #examine-btn {
            margin: 24px auto 8px;
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            box-shadow: 0 22px 40px rgba(179, 7, 44, 0.25);
            min-width: 220px;
        }

        #examine-btn:hover {
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
            color: var(--hw-white);
        }

        .analysis-output {
            background: #fbfaf7;
            border-radius: 22px;
            padding: 28px;
            margin-top: 24px;
            border: 1px solid var(--hw-border);
        }

        #group-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            margin-top: 18px;
        }

        .swatch {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }

        .dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        #rendered-text {
            background: var(--hw-white);
            padding: 20px 24px;
            border-radius: 20px;
            margin-top: 18px;
            font-family: 'Georgia', serif;
            line-height: 1.82;
            border: 1px solid var(--hw-border);
        }

        .grammar-section {
            margin-top: 24px;
        }

        .grammar-item {
            background: var(--hw-white);
            padding: 16px 18px;
            margin-bottom: 12px;
            border-radius: 16px;
            border: 1px solid var(--hw-border);
            box-shadow: 0 8px 18px rgba(25, 17, 12, 0.08);
        }

        .grammar-name {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--hw-red);
            margin-right: 10px;
            display: inline-block;
        }

        .grammar-text {
            color: var(--hw-muted);
            font-style: italic;
        }

        .translation-input {
            border: 1px solid var(--hw-border-strong);
        }

        .translation-correct {
            border-color: #2f9e44 !important;
            background: #effaf0;
        }

        .translation-incorrect {
            border-color: var(--hw-red) !important;
            background: #fef2f4;
        }

        #check-translation-btn {
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            margin-top: 22px;
            box-shadow: 0 16px 28px rgba(179, 7, 44, 0.22);
        }

        #check-translation-btn:hover {
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
            color: var(--hw-white);
        }

        .translation-feedback {
            margin-top: 14px;
            font-weight: 600;
            min-height: 24px;
            color: var(--hw-muted);
        }

        .tooltip {
            position: fixed;
            background: rgba(30, 21, 15, 0.94);
            color: var(--hw-white);
            padding: 14px 18px;
            border-radius: 14px;
            font-size: 0.9rem;
            line-height: 1.55;
            z-index: 1000;
            pointer-events: auto;  /* NEW - ALLOWS CLICKING LINKS */
            max-width: 320px;
            box-shadow: 0 20px 40px rgba(30, 21, 15, 0.28);
        }
        .tooltip a {
    color: #fde047;
    text-decoration: underline;
    cursor: pointer;
}

.tooltip a:hover {
    color: #fef08a;
}

        .tooltip strong {
            color: var(--hw-white);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hint {
            color: #bab1a6;
            font-size: 0.88rem;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 900px) {
            body {
                padding: 24px 18px 48px;
            }

            .top-bar {
                flex-direction: column;
                gap: 14px;
                align-items: flex-start;
                padding: 18px 22px;
            }

            .nav-links {
                gap: 18px;
                flex-wrap: wrap;
            }

            .container {
                padding: 36px 24px 44px;
            }

            h1 {
                font-size: 2.3rem;
            }
        }
    </style>
</head>
<body>
    <header class="top-bar">
        <div class="brand">Harvard-Westlake</div>
        <nav class="nav-links" aria-label="Primary navigation">
            <a href="#latin-analyzer" class="nav-link active">Home</a>
        </nav>
    </header>
    <main class="page-container" id="latin-analyzer">
        <div class="container">
            <div class="page-intro">
                <h1>Latin Text Analyzer</h1>
                <div class="user-directions">
                    <p><strong>Welcome!</strong> This website will help you translate sentences that are in Latin!</p>
                    <p>First, type in the lines that you need help translating. Click "Examine!" and then you can take your mouse and hover over words to know the definition, case, number, and gender of the word. Words that are highlighted with the same color indicate different translation chunks in which you can break down the sentence(s) and translate them. Any complex grammar will be listed below the lines where you typed the Latin. You can try typing your translation of those lines of Latin in the "Your translation" box and then click "Check Translation". The website will then tell you if your translation is correct or not.</p>
                    <p><strong>Note:</strong> This website works better for simpler Latin sentences! When asking for help with more complex Latin lines such as that from Caesar or Vergil please don't expect the website's analysis to be 100% accurate!</p>
                </div>
            </div>

            <!-- Author Input -->
            <div class="section" id="author-section">
                <label class="section-title" for="author-input">Author (Optional)</label>
                <input type="text" id="author-input" placeholder="e.g., Vergil, Caesar, Ovid">
            </div>

            <!-- Latin Input -->
            <div class="section" id="latin-section" hidden>
                <label class="section-title" for="latin-input">Latin Text · Max 50 Words</label>
                <div class="latin-input-wrapper">
                    <textarea id="latin-input" placeholder="Enter your Latin text here..."></textarea>
                    <div id="latin-overlay" aria-hidden="true"></div>
                </div>
                <div class="word-count" id="word-count">0/50 words</div>
                <div class="input-warning" id="input-warning"></div>
            </div>

            <!-- Examine Button -->
            <button id="examine-btn" disabled>Examine Text</button>

            <!-- Analysis Output -->
            <div class="analysis-output" id="analysis-output" hidden>
                <div class="section-title">Translation Chunks</div>
                <div id="rendered-text"></div>
            </div>

            <!-- Grammar Section -->
            <div class="grammar-section section" id="grammar-section" hidden>
                <div class="section-title">Advanced Grammar Detected</div>
                <div id="grammar-list"></div>
            </div>

            <!-- Translation Section -->
            <div class="section" id="translation-section" hidden>
                <label class="section-title" for="translation-input">Your Translation</label>
                <textarea id="translation-input" class="translation-input" placeholder="Enter your English translation..."></textarea>
                <button id="check-translation-btn">Check Translation</button>
                <div class="translation-feedback" id="translation-feedback"></div>
            </div>

            <div id="mobile" aria-hidden="true"></div>
        </div>
    </main>

    <script>
// Latin Translator Logic
// Version: 2024-11-09-v33 - Implemented Translation Chunks system (replaces grammatical groups)
    console.log('Latin Translator loaded - Version 2024-11-09-v33');
(function() {
    const authorSection = document.getElementById('author-section');
    const authorInput = document.getElementById('author-input');
    const latinSection = document.getElementById('latin-section');
    const latinInput = document.getElementById('latin-input');
    const latinOverlay = document.getElementById('latin-overlay');
    const wordCount = document.getElementById('word-count');
    const inputWarning = document.getElementById('input-warning');
    const examineBtn = document.getElementById('examine-btn');
    const analysisOutput = document.getElementById('analysis-output');
    const renderedText = document.getElementById('rendered-text');
    const grammarSection = document.getElementById('grammar-section');
    const grammarList = document.getElementById('grammar-list');
    const translationSection = document.getElementById('translation-section');
    const translationInput = document.getElementById('translation-input');
    const checkTranslationBtn = document.getElementById('check-translation-btn');
    const translationFeedback = document.getElementById('translation-feedback');

    const STATE = {
        lastValidLatin: '',
        overlayActive: false,
        tokens: [],
        groups: [],
        grammar: [],
        baselineEnglish: []
    };

    const COLOR_PALETTE = [
        '#fde047', '#60a5fa', '#34d399', '#f472b6', '#fb923c', '#a78bfa', '#f87171', '#22d3ee',
        '#fcd34d', '#93c5fd', '#6ee7b7', '#f9a8d4', '#fdba74', '#c4b5fd', '#fca5a5', '#67e8f9',
        '#fef08a', '#bfdbfe', '#a7f3d0', '#fbcfe8', '#fed7aa', '#ddd6fe', '#fecaca', '#a5f3fc'
    ];

    // Initialize UI
    latinSection.hidden = false;
    examineBtn.disabled = latinInput.value.trim().length === 0;

    function resetAnalysisState() {
        analysisOutput.hidden = true;
        grammarSection.hidden = true;
        translationSection.hidden = true;
        translationInput.value = '';
        translationFeedback.textContent = '';
        translationInput.classList.remove('translation-correct', 'translation-incorrect');
    }

    // Input handling with 50-word cap
    function tokenizeForCount(text) {
        const matches = text.match(/\p{L}+[\p{L}\-]*|\d+/gu) || [];
        return matches;
    }

    function updateWordCount() {
        const tokens = tokenizeForCount(latinInput.value);
        wordCount.textContent = `${tokens.length}/50 words`;
        examineBtn.disabled = tokens.length === 0;
    }

    function enforceCap(e) {
        const tokens = tokenizeForCount(latinInput.value);
        if (tokens.length > 50) {
            inputWarning.textContent = 'Limit is 50 words. Extra input was not added.';
            latinInput.value = STATE.lastValidLatin;
            setTimeout(() => inputWarning.textContent = '', 2000);
        } else {
            STATE.lastValidLatin = latinInput.value;
        }
        updateWordCount();
        if (STATE.overlayActive) hideOverlayForEditing();
        // Reset button to Examine! on any edit
        examineBtn.textContent = 'Examine!';
        examineBtn.disabled = tokenizeForCount(latinInput.value).length === 0;
    }

    latinInput.addEventListener('input', enforceCap);
    latinInput.addEventListener('focus', hideOverlayForEditing);

    // Examine -> analyze -> Ready
    examineBtn.addEventListener('click', async () => {
        if (examineBtn.disabled) return;
        examineBtn.disabled = true;
        examineBtn.textContent = 'Analyzing…';
        const text = latinInput.value;
        await new Promise(r => setTimeout(r, 30));
        const analysis = await analyzeWithAPI(text, {
            author: (authorInput.value || '').trim()
        });
        STATE.tokens = analysis.tokens;
        STATE.groups = analysis.groups;
        STATE.grammar = analysis.grammar;
        STATE.baselineEnglish = analysis.baselineEnglish;

        renderOverlay(text, STATE.tokens, STATE.groups);
        renderGrammar(STATE.grammar);

        analysisOutput.hidden = false;
        grammarSection.hidden = false;
        translationSection.hidden = false;
        examineBtn.textContent = 'Examine!';
        examineBtn.disabled = false;
        STATE.overlayActive = true;
    });

    // Tooltips
    const tooltip = createTooltip();

    function createTooltip() {
        const el = document.createElement('div');
        el.className = 'tooltip';
        el.style.display = 'none';
        document.body.appendChild(el);
        return el;
    }

// Add state tracking for sticky tooltips
let isTooltipSticky = false;
let currentStickyToken = null;

function showTooltip(html, x, y, sticky = false) {
    tooltip.innerHTML = html;
    tooltip.style.left = Math.max(12, x + 12) + 'px';
    tooltip.style.top = Math.max(12, y + 12) + 'px';
    tooltip.style.display = 'block';
    isTooltipSticky = sticky;
}

function hideTooltip(force = false) {
    // NEVER hide if the user is about to click a link
    if (document.querySelector('.tooltip a:hover')) {
        return;
    }
    
    if (isTooltipSticky && !force) {
        return; // Don't hide if sticky unless forced
    }
    tooltip.style.display = 'none';
    isTooltipSticky = false;
    currentStickyToken = null;
}

    // Overlay rendering
    function renderOverlay(rawText, tokens, groups) {
        // Build a map from token index to group/color and tooltip
        const tokenMeta = new Map();
        const palette = COLOR_PALETTE;

        // Detect sentence boundaries (periods followed by space/newline)
        const sentenceBoundaries = [];
        for (let i = 0; i < tokens.length - 1; i++) {
            const t = tokens[i];
            const next = tokens[i + 1];
            const between = rawText.slice(t.end, next.start);
            if (/\.\s/.test(between) || /\.\n/.test(between)) {
                sentenceBoundaries.push(i);
            }
        }

        // Assign groups to sentences
        const groupsWithSentence = groups.map((g, idx) => {
            const firstTokenIdx = g.tokens[0];
            let sentenceNum = 0;
            for (let i = 0; i < sentenceBoundaries.length; i++) {
                if (firstTokenIdx > sentenceBoundaries[i]) {
                    sentenceNum = i + 1;
                }
            }
            return { ...g, sentenceNum, originalIdx: idx };
        });

        // Assign colors per sentence (reset color index for each sentence)
        // Each sentence starts with a different color than the previous sentence ended with
        const colorIndexBySentence = new Map();
        let lastUsedColorIdx = -1; // Track the last color used in previous sentence

        groupsWithSentence.forEach(g => {
            if (!colorIndexBySentence.has(g.sentenceNum)) {
                // Starting a new sentence - ensure first color is different from last sentence's last color
                let startColorIdx = 0;
                if (lastUsedColorIdx !== -1) {
                    // Start with the next color in sequence to ensure visual separation
                    startColorIdx = (lastUsedColorIdx + 1) % palette.length;
                }
                colorIndexBySentence.set(g.sentenceNum, startColorIdx);
            }

            const colorIdx = colorIndexBySentence.get(g.sentenceNum);
            const color = palette[colorIdx % palette.length];

            g.tokens.forEach(ti => {
                tokenMeta.set(ti, {
                    color: color,
                    name: g.name
                });
            });

            // Increment color index for this sentence
            const nextColorIdx = (colorIdx + 1) % palette.length;
            colorIndexBySentence.set(g.sentenceNum, nextColorIdx);
            lastUsedColorIdx = colorIdx; // Track last used color
        });

        // Replace words with spans in order using regex
        let idx = 0;
        const overlayParts = [];
        const renderedParts = [];
        const regex = /\p{L}+[\p{L}\-]*/gu;
        let lastIndex = 0;
        let m;
        while ((m = regex.exec(rawText)) !== null) {
            const [word] = m;
            const spaceBefore = escapeHtml(rawText.slice(lastIndex, m.index));
            overlayParts.push(spaceBefore);
            renderedParts.push(spaceBefore);
           
            const t = tokens[idx] || null;
            const meta = tokenMeta.get(idx);
            const tooltipHtml = buildTooltipHtml(t);
           
            // For overlay: NO background highlighting, just tooltips
            overlayParts.push(`<span class="token" data-ti="${idx}">${escapeHtml(word)}</span>`);
           
            // For rendered text (Translation Chunks): WITH background highlighting
            const style = meta ? `style="background:${meta.color}33"` : '';
            const cls = meta ? 'token highlight' : 'token';
            renderedParts.push(`<span class="${cls}" data-ti="${idx}" ${style}>${escapeHtml(word)}</span>`);
           
            attachTokenHover(idx, tooltipHtml);
            idx++;
            lastIndex = regex.lastIndex;
        }
        const finalText = escapeHtml(rawText.slice(lastIndex));
        overlayParts.push(finalText);
        renderedParts.push(finalText);
       
        latinOverlay.innerHTML = overlayParts.join('');
        latinOverlay.style.display = 'block';
        latinOverlay.style.pointerEvents = 'auto';
        latinOverlay.setAttribute('aria-hidden', 'false');
        latinInput.classList.add('overlay-active');
        STATE.overlayActive = true;

        // Also render a read-only copy below for accessibility with highlighting
        renderedText.innerHTML = renderedParts.join('');
        bindRenderedTextTooltips();
    }

    function hideOverlayForEditing() {
        if (!STATE.overlayActive) return;
        latinOverlay.style.display = 'none';
        latinOverlay.style.pointerEvents = 'none';
        latinOverlay.setAttribute('aria-hidden', 'true');
        latinInput.classList.remove('overlay-active');
        STATE.overlayActive = false;
        hideTooltip();
        examineBtn.textContent = 'Examine!';
        examineBtn.disabled = tokenizeForCount(latinInput.value).length === 0;
    }

    function bindRenderedTextTooltips() {
    renderedText.querySelectorAll('.token').forEach(el => {
        const ti = Number(el.getAttribute('data-ti'));
        const t = STATE.tokens[ti];
        const html = buildTooltipHtml(t);
        
        el.addEventListener('mouseenter', (e) => {
            if (!isTooltipSticky) {
                showTooltip(html, e.clientX, e.clientY);
            }
        });
        
        el.addEventListener('mousemove', (e) => {
            if (!isTooltipSticky) {
                showTooltip(html, e.clientX, e.clientY);
            }
        });
        
        el.addEventListener('mouseleave', () => {
            if (!isTooltipSticky) {
                hideTooltip();
            }
        });
        
        el.addEventListener('click', (e) => {
            e.stopPropagation();
            if (currentStickyToken === el) {
                // Clicking same token - unstick
                hideTooltip(true);
            } else {
                // Make this tooltip sticky
                currentStickyToken = el;
                showTooltip(html, e.clientX, e.clientY, true);
            }
        });
        
        el.setAttribute('tabindex', '0');
        el.addEventListener('focus', (e) => showTooltip(html, e.clientX || 0, e.clientY || 0));
        el.addEventListener('blur', hideTooltip);
    });
}

    function attachTokenHover(index, html) {
        // Defer until after insert by event delegation on overlay
        // We'll add one-time listener to overlay
        if (!latinOverlay._bound) {
            latinOverlay.addEventListener('mouseover', tokenHoverHandler);
            latinOverlay.addEventListener('mousemove', tokenHoverHandler);
            latinOverlay.addEventListener('mouseout', tokenHoverOut);
            latinOverlay.addEventListener('click', tokenHoverHandler);
            latinOverlay._bound = true;
        }
    }

    function tokenHoverHandler(e) {
    const target = e.target.closest('.token');
    if (!target) {
        if (!isTooltipSticky) hideTooltip();
        return;
    }
    const ti = Number(target.getAttribute('data-ti'));
    const t = STATE.tokens[ti];
    if (!t) return;
    const html = buildTooltipHtml(t);
    
    if (e.type === 'click') {
        e.stopPropagation();
        if (currentStickyToken === target) {
            hideTooltip(true);
        } else {
            currentStickyToken = target;
            showTooltip(html, e.clientX, e.clientY, true);
        }
    } else if (!isTooltipSticky) {
        showTooltip(html, e.clientX, e.clientY);
    }
}

function tokenHoverOut() {
    if (!isTooltipSticky) {
        hideTooltip();
    }
}

    function buildTooltipHtml(t) {
    if (!t) return '';
    let def = t.definition || 'Unknown';

    // Check if definition is unknown/missing
    const isUnknown = !def || def === 'Unknown' || def === 'unknown' || def === t.normalized || def === t.original;

    if (isUnknown) {
        // Create a link to Latin-is-Simple
        const searchWord = encodeURIComponent(t.original);
        const url = `https://www.latin-is-simple.com/en/vocabulary/search/?q=${searchWord}`;
        def = `<a href="${url}" target="_blank" style="color: #fde047; text-decoration: underline;">Search on Latin-is-Simple →</a>`;
    } else {
        // Clean up the definition
        def = def.replace(/^[fmn]\.?\s+/i, '');
        def = def.replace(/^[,;\s]+/, '');
        def = escapeHtml(def);
    }
    
    const pos = t.pos || 'Unknown';
    let extra = '';
    if (pos === 'noun') {
        extra = t.features.case ? `, case: ${t.features.case}` : '';
    } else if (pos === 'verb') {
        extra = t.features.tense ? `, tense: ${t.features.tense}` : '';
    } else if (pos === 'adjective') {
        extra = '';
    } else if (pos === 'gerundive') {
        extra = t.features.case ? `, case: ${t.features.case}` : '';
    } else if (pos === 'participle') {
        extra = t.features.tense ? `, tense: ${t.features.tense}` : '';
    }
    
    return `<strong>${escapeHtml(t.original)}</strong><br>${def}<br><span class="hint">${pos}${extra}</span>`;
}

    // Legend removed - Translation Chunks don't need labels

    function renderGrammar(grammar) {
        grammarList.innerHTML = '';
        if (!grammar.length) {
            const none = document.createElement('div');
            none.className = 'grammar-item';
            none.innerHTML = `<span class="grammar-name">None detected</span><span class="grammar-text"></span>`;
            grammarList.appendChild(none);
            return;
        }
        grammar.forEach(g => {
            const div = document.createElement('div');
            div.className = 'grammar-item';
            const name = document.createElement('span');
            name.className = 'grammar-name';
            name.textContent = g.name + ':';
            const text = document.createElement('span');
            text.className = 'grammar-text';
            text.textContent = `"${g.text}"`;
            div.appendChild(name);
            div.appendChild(text);
            grammarList.appendChild(div);
        });
    }

    // Semantic antonym/contradiction dictionary for translation validation
    const SEMANTIC_OPPOSITES = {
        'good': ['bad', 'evil', 'wicked', 'poor', 'terrible', 'awful', 'horrible'],
        'bad': ['good', 'excellent', 'wonderful', 'great', 'fine', 'nice'],
        'great': ['small', 'tiny', 'little', 'minor', 'insignificant'],
        'large': ['small', 'tiny', 'little', 'petite'],
        'small': ['large', 'big', 'great', 'huge', 'enormous', 'giant'],
        'long': ['short', 'brief'],
        'short': ['long', 'tall', 'lengthy'],
        'high': ['low', 'short'],
        'low': ['high', 'tall'],
        'new': ['old', 'ancient', 'aged'],
        'old': ['new', 'young', 'recent', 'modern'],
        'many': ['few', 'little', 'scarce'],
        'few': ['many', 'numerous', 'multiple'],
        'all': ['none', 'nothing'],
        'none': ['all', 'everything', 'some'],
        'first': ['last', 'final'],
        'last': ['first', 'initial'],
        'beautiful': ['ugly', 'hideous', 'repulsive'],
        'ugly': ['beautiful', 'pretty', 'handsome'],
        'brave': ['cowardly', 'fearful', 'timid'],
        'strong': ['weak', 'feeble', 'frail'],
        'weak': ['strong', 'powerful', 'mighty'],
        'happy': ['sad', 'unhappy', 'miserable', 'depressed'],
        'sad': ['happy', 'joyful', 'cheerful', 'glad'],
        'joyful': ['sad', 'sorrowful', 'miserable'],
        'famous': ['unknown', 'obscure'],
        'known': ['unknown', 'unfamiliar'],
        'unknown': ['known', 'famous', 'familiar'],
        'true': ['false', 'untrue', 'fake'],
        'false': ['true', 'genuine', 'real'],
        'just': ['unjust', 'unfair'],
        'holy': ['unholy', 'profane', 'evil'],
        'sacred': ['profane', 'secular'],
        'free': ['enslaved', 'bound', 'captive'],
        'heavy': ['light', 'weightless'],
        'light': ['heavy', 'dark'],
        'hard': ['soft', 'easy'],
        'soft': ['hard', 'firm', 'rigid'],
        'fast': ['slow', 'sluggish'],
        'slow': ['fast', 'quick', 'swift', 'rapid'],
        'wise': ['foolish', 'stupid', 'unwise'],
        'foolish': ['wise', 'smart', 'intelligent'],
        'divine': ['mortal', 'human', 'earthly'],
        'human': ['divine', 'godly'],
        'public': ['private', 'personal'],
        'private': ['public', 'common'],
        'eternal': ['temporary', 'mortal', 'fleeting'],
        'love': ['hate', 'loathe', 'despise'],
        'hate': ['love', 'adore', 'cherish'],
        'war': ['peace'],
        'peace': ['war', 'conflict', 'battle'],
        'life': ['death'],
        'death': ['life', 'birth'],
        'day': ['night'],
        'night': ['day'],
        'light': ['darkness', 'dark'],
        'dark': ['light', 'bright'],
        'friend': ['enemy', 'foe'],
        'enemy': ['friend', 'ally'],
        'master': ['slave', 'servant'],
        'slave': ['master', 'lord', 'free'],
        'hope': ['despair', 'hopelessness'],
        'courage': ['cowardice', 'fear'],
        'virtue': ['vice', 'evil'],
        'glory': ['shame', 'disgrace'],
        'joy': ['sorrow', 'grief', 'sadness'],
        'pain': ['pleasure', 'comfort'],
        'always': ['never'],
        'never': ['always', 'forever'],
        'often': ['rarely', 'seldom'],
        'well': ['badly', 'poorly'],
        'badly': ['well', 'nicely'],
        'come': ['go', 'leave'],
        'go': ['come', 'arrive', 'stay'],
        'arrive': ['depart', 'leave'],
        'give': ['take', 'receive'],
        'take': ['give'],
        'open': ['close', 'shut'],
        'close': ['open'],
        'up': ['down'],
        'down': ['up'],
        'in': ['out'],
        'out': ['in'],
        'before': ['after'],
        'after': ['before'],
        'with': ['without'],
        'without': ['with']
    };

    // Stop words that don't carry much semantic meaning
    const STOP_WORDS = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'am', 'be', 'been',
        'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might',
        'can', 'to', 'of', 'in', 'on', 'at', 'by', 'for', 'from', 'with', 'about', 'as', 'into',
        'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'again',
        'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'both',
        'each', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same',
        'so', 'than', 'too', 'very', 'just', 'but', 'if', 'or', 'because', 'while', 'who', 'which',
        'this', 'that', 'these', 'those', 'my', 'your', 'his', 'her', 'its', 'our', 'their']);

    // Translation evaluation with sophisticated grammatical analysis
    checkTranslationBtn.addEventListener('click', () => {
        const userTranslation = translationInput.value || '';
       
        if (!STATE.tokens || STATE.tokens.length === 0) {
            translationFeedback.textContent = 'Run Examine! first to analyze the Latin.';
            return;
        }

        // Perform sophisticated structural analysis
        const result = advancedTranslationCheck(STATE.tokens, userTranslation);
       
        translationInput.classList.toggle('translation-correct', result.isCorrect);
        translationInput.classList.toggle('translation-incorrect', !result.isCorrect);
       
        // Determine validation type for feedback
        const validationType = result.validationType || 'structural';
        translationFeedback.textContent = result.isCorrect ?
            `Correct (${validationType} match) ✔` :
            `Not quite — ${result.reason} ✘`;
    });

    function advancedTranslationCheck(latinTokens, englishText) {
        // Parse Latin sentence structure
        const latinStructure = parseLatinStructure(latinTokens);
       
        // Parse English sentence structure  
        const englishStructure = parseEnglishStructure(englishText);
       
        // Check if this is a complex multi-clause sentence
        // Complex sentences have: relative pronouns, multiple finite verbs, or many clauses
        const hasRelativePronouns = latinTokens.some(t => {
            const word = t.normalized.toLowerCase();
            return ['qui', 'quae', 'quod', 'quem', 'quam', 'quorum', 'quarum', 'quibus', 'quo', 'qua'].includes(word);
        });
       
        const multipleVerbs = latinStructure.allVerbs && latinStructure.allVerbs.length > 2;
        const longSentence = latinTokens.length > 15;
       
        // For complex sentences, use semantic validation instead of strict structural validation
        if (hasRelativePronouns && (multipleVerbs || longSentence)) {
            const result = semanticValidation(latinTokens, englishText, englishStructure);
            result.validationType = 'semantic';
            return result;
        }
       
        // For simple sentences, use strict structural validation
        const result = validateStructuralMatch(latinStructure, englishStructure);
        result.validationType = 'structural';
        return result;
    }
   
    function semanticValidation(latinTokens, englishText, englishStructure) {
        // Extract key Latin words (nouns, verbs, adjectives)
        let latinKeyWords = latinTokens
            .filter(t => ['noun', 'verb', 'adjective', 'pronoun'].includes(t.pos))
            .map(t => normalizeWord(t.definition || ''))
            .filter(w => w && w !== 'unknown');

        if (englishStructure.prepositionalPhrases && englishStructure.prepositionalPhrases.length) {
            englishStructure.prepositionalPhrases.forEach(phrase => {
                phrase.split(/\s+/).forEach(part => {
                    const normalized = normalizeWord(part);
                    if (normalized && !STOP_WORDS.has(normalized)) {
                        latinKeyWords.push(normalized);
                    }
                });
            });
        }
       
        // Extract English words
        const englishWords = (englishStructure.allWords || [])
            .map(w => normalizeWord(w))
            .filter(w => !STOP_WORDS.has(w));
       
        // Check what percentage of Latin key words appear in English
        let matchCount = 0;
        for (const latinWord of latinKeyWords) {
            // Check if this Latin word (or a related form) appears in English
            const found = englishWords.some(engWord => {
                return wordsMatch(latinWord, engWord);
            });
            if (found) {
                matchCount++;
            }
        }
       
        const coverage = latinKeyWords.length > 0 ? matchCount / latinKeyWords.length : 0;
       
        // Require at least 60% coverage for complex sentences (more lenient)
        if (coverage >= 0.6) {
            return { isCorrect: true, reason: '' };
        } else {
            return {
                isCorrect: false,
                reason: `incomplete translation (only ${Math.round(coverage * 100)}% of key words translated)`
            };
        }
    }

    // Helper function to determine verb person and number from ending
    function getVerbPersonNumber(verbToken) {
        const word = verbToken.normalized;
        const original = verbToken.original;
       
        // Check endings in order of specificity (most specific first)
       
        // First person plural: -mus ending
        if (/mus$/i.test(word)) {
            return { person: 1, number: 'plural', expectedSubject: 'we' };
        }
       
        // Second person plural: -tis ending
        if (/tis$/i.test(word)) {
            return { person: 2, number: 'plural', expectedSubject: 'you' };
        }
       
        // Third person plural: -nt ending
        if (/nt$/i.test(word)) {
            return { person: 3, number: 'plural', expectedSubject: 'they' };
        }
       
        // Third person singular: -t ending (but not -nt which was already checked)
        if (/t$/i.test(word) && !/nt$/i.test(word)) {
            return { person: 3, number: 'singular', expectedSubject: 'he/she/it' };
        }
       
        // Second person singular: -s ending (not -us, -is, -mus, -tis)
        if (/s$/i.test(word) && !/us$/i.test(word) && !/is$/i.test(word) && !/mus$/i.test(word) && !/tis$/i.test(word)) {
            return { person: 2, number: 'singular', expectedSubject: 'you' };
        }
       
        // First person singular: -o or -m endings (standard Latin present active indicative)
        // This catches all regular -o ending verbs (amo, constituo, puto, video, etc.)
        if (/[om]$/i.test(word)) {
            return { person: 1, number: 'singular', expectedSubject: 'I' };
        }
       
        // Default to third person singular for unknown
        return { person: 3, number: 'singular', expectedSubject: 'he/she/it' };
    }

    function parseLatinStructure(tokens) {
        const structure = {
            subject: null,
            subjectModifiers: [],
            verb: null,
            object: null,
            objectModifiers: [],
            prepositionalPhrases: [],
            hasInfinitive: false,
            isIndirectStatement: false,
            isDirectSpeech: false,
            infinitiveSubject: null,
            infinitiveVerb: null,
            infinitiveObject: null,
            mainVerbPerson: null,
            mainVerbNumber: null,
            mainVerbExpectedSubject: null,
            allNouns: [],
            allVerbs: [],
            allInfinitives: [],
            prepositionalTokenIndices: new Set()
        };
        const prepTokenIndices = structure.prepositionalTokenIndices;

        // First pass: identify all nouns, verbs, infinitives, and simple prepositional phrases
        tokens.forEach((token, idx) => {
            token.originalStart = token.start;
            token.originalEnd = token.end;
            if (token.pos === 'noun' || token.pos === 'pronoun' || token.pos === 'proper-noun') {
                structure.allNouns.push({ token, idx, case: token.features.case });
            }
            if (token.pos === 'verb') {
                if (token.features.tense === 'infinitive') {
                    structure.allInfinitives.push({ token, idx, definition: token.definition });
                    structure.hasInfinitive = true;
                } else {
                    structure.allVerbs.push({ token, idx, definition: token.definition });
                }
            }
        });

   

        // NOW collect prepositional phrases (after case disambiguation)
        tokens.forEach((token, idx) => {
            if (token.pos === 'preposition') {
                const phraseEntries = [{ token, idx }];
                // Collect ALL tokens that are part of the prepositional phrase
                // CRITICAL: Stop if we encounter a NOMINATIVE noun (subjects are never in prep phrases!)
                for (let j = idx + 1; j < tokens.length; j++) {
                    const next = tokens[j];
                   
                    // Stop if we hit another preposition or a finite verb (unless it's a gerundive/participle)
                    if (next.pos === 'preposition') break;
                    if (next.pos === 'verb' && next.features.tense !== 'infinitive') break;
                    if (next.pos === 'conjunction') break;
                   
                    // CRITICAL CHECK: If this is a noun/pronoun with UNAMBIGUOUS NOMINATIVE case, stop!
                    // Nominative nouns are NEVER part of prepositional phrases - they're subjects
                    // IMPORTANT: Use negative lookahead to only match "nom" not followed by "/" (to exclude "nom/acc")
                    if ((next.pos === 'noun' || next.pos === 'pronoun' || next.pos === 'proper-noun') &&
                        next.features.case && /^nom(?!\/)/.test(next.features.case)) {
                        // Found unambiguous nominative noun - this is the subject of the main clause, stop here
                        console.log(`[PREP PHRASE] Stopping at nominative noun: "${next.word}" (case: ${next.features.case})`);
                        break;
                    }
                   
                    // Include if it's a noun, pronoun, adjective, gerundive, or participle
                 // Include if it's a noun, pronoun, adjective, gerundive, or participle
                 if (next.pos === 'noun' ||
                        next.pos === 'pronoun' ||
                        next.pos === 'proper-noun' ||
                        next.pos === 'adjective' ||
                        next.pos === 'gerundive' ||
                        next.pos === 'participle') {
                        phraseEntries.push({ token: next, idx: j });
                        // If we just added a gerundive, stop here - it's typically the last word
                        if (next.pos === 'gerundive') {
                            break;
                        }
                        // Continue collecting for other parts of speech
                    } else {
                        // Hit something that's definitely not part of the phrase
                        break;
                    }
                }
                const phraseDefs = phraseEntries
                    .map(entry => {
                        const t = entry.token;
                        return (t.definition && t.definition !== 'unknown') ? t.definition : (t.original || t.normalized);
                    })
                    .filter(Boolean);
                if (phraseEntries.length > 1) {
                    structure.prepositionalPhrases.push({
                        tokens: phraseEntries.map(entry => entry.token),
                        english: phraseDefs.join(' ')
                    });
                    phraseEntries.forEach(entry => prepTokenIndices.add(entry.idx));
                }
            }
        });

        // CASE DISAMBIGUATION: Refine ambiguous case assignments for nouns in prepositional phrases
        // This fixes the bug where "res" in "ad eas res" was being treated as nominative
        // when it should be accusative (object of preposition "ad")
        for (const noun of structure.allNouns) {
            if (prepTokenIndices.has(noun.idx) && noun.case) {
                console.log(`[PREP CASE DEBUG] Checking noun "${noun.token.word}" in prep phrase, case: ${noun.case}`);
                // Find which prepositional phrase this noun is in
                for (const phrase of structure.prepositionalPhrases) {
                    const phraseIndices = phrase.tokens.map((t, i) => {
                        // Find index of this token in the original tokens array
                        return tokens.findIndex(tok => tok === t);
                    });
                   
                    if (phraseIndices.includes(noun.idx)) {
                        // Get the preposition (first token in phrase)
                        const prep = phrase.tokens[0];
                        const prepWord = (prep.normalized || prep.word).toLowerCase();
                        console.log(`[PREP CASE DEBUG] Found in phrase starting with "${prepWord}"`);
                       
                        // Check which case this preposition governs
                        const accusativePreps = ['ad', 'ante', 'apud', 'circa', 'circum', 'cis', 'citra',
                            'contra', 'erga', 'extra', 'infra', 'inter', 'intra', 'iuxta', 'ob', 'per',
                            'pone', 'post', 'praeter', 'prope', 'propter', 'secundum', 'supra', 'trans',
                            'ultra', 'versus', 'adversus'];
                        const ablativePreps = ['a', 'ab', 'abs', 'absque', 'cum', 'coram', 'de', 'e', 'ex',
                            'prae', 'pro', 'sine', 'tenus', 'clam', 'palam'];
                       
                        // If the case is ambiguous (contains both nom and acc), disambiguate it
                        if (/nom.*acc|acc.*nom/.test(noun.case)) {
                            console.log(`[PREP CASE DEBUG] Case is ambiguous, testing preposition type`);
                            if (accusativePreps.includes(prepWord)) {
                                // This noun must be accusative (object of preposition)
                                const oldCase = noun.case;
                                noun.case = noun.case.replace(/nom\/|\/nom|nom /g, '').replace(/\s+/g, ' ').trim();
                                if (!noun.case.includes('acc')) {
                                    noun.case = 'acc ' + noun.case.replace('acc', '').trim();
                                }
                                console.log(`[PREP CASE DEBUG] Changed "${noun.token.word}" from "${oldCase}" to "${noun.case}"`);
                            } else if (ablativePreps.includes(prepWord)) {
                                // This noun must be ablative
                                const oldCase = noun.case;
                                noun.case = noun.case.replace(/nom\/|\/nom|nom |acc\/|\/acc|acc /g, '').replace(/\s+/g, ' ').trim();
                                if (!noun.case.includes('abl')) {
                                    noun.case = 'abl ' + noun.case;
                                }
                                console.log(`[PREP CASE DEBUG] Changed "${noun.token.word}" from "${oldCase}" to "${noun.case}"`);
                            }
                        }
                        // Also handle "nom/acc" format without ".*"
                        else if (noun.case === 'nom/acc pl' || noun.case === 'nom/acc sg') {
                            console.log(`[PREP CASE DEBUG] Case is exactly "nom/acc", testing preposition type`);
                            if (accusativePreps.includes(prepWord)) {
                                const oldCase = noun.case;
                                noun.case = noun.case.replace('nom/', '');
                                noun.token.features.case = noun.case;
                                console.log(`[PREP CASE DEBUG] Changed "${noun.token.word}" from "${oldCase}" to "${noun.case}"`);
                            } else if (ablativePreps.includes(prepWord)) {
                                const oldCase = noun.case;
                                noun.case = noun.case.replace('nom/acc', 'abl');
                                console.log(`[PREP CASE DEBUG] Changed "${noun.token.word}" from "${oldCase}" to "${noun.case}"`);
                            }
                        } else {
                            console.log(`[PREP CASE DEBUG] Case "${noun.case}" doesn't match ambiguous patterns, skipping`);
                        }
                        break;
                    }
                }
            }
        }
        // MOVED: Early disambiguation now happens AFTER prep phrase collection
        // This prevents "res" from being marked nominative before the phrase "ad eas res" is identified
        console.log(`[EARLY DISAMBIGUATION] Checking ${structure.allNouns.length} nouns for ambiguous cases`);
        for (const noun of structure.allNouns) {
            // Skip if already in a prep phrase - don't disambiguate
            if (prepTokenIndices.has(noun.idx)) {
                console.log(`[EARLY DISAMBIGUATION] Skipping "${noun.token.word}" - in prep phrase`);
                continue;
            }
           
            // Only process ambiguous nom/acc cases
            if (noun.case && /nom.*acc|acc.*nom/i.test(noun.case)) {
                console.log(`[EARLY DISAMBIGUATION] Found ambiguous noun: "${noun.token.word}" (case: ${noun.case})`);
                // Check if there's a verb in the sentence
                const hasVerb = structure.allVerbs.length > 0;
               
                if (hasVerb) {
                    // Find the main verb (first non-infinitive verb)
                    let mainVerbIdx = -1;
                    for (const verb of structure.allVerbs) {
                        mainVerbIdx = verb.idx;
                        break;
                    }
                   
                    // Heuristic: If noun comes before the verb OR after a passive verb, prefer nominative
                    const isBeforeVerb = mainVerbIdx !== -1 && noun.idx < mainVerbIdx;
                   
                    // Check if verb is passive (common passive endings)
                    let isPassiveVerb = false;
                    if (mainVerbIdx !== -1) {
                        const verbWord = tokens[mainVerbIdx].normalized;
                        isPassiveVerb = /(or|ris|tur|mur|mini|ntur|bar|baris|batur|bamur|bor|beris|bitur)$/i.test(verbWord);
                    }
                   
                    const isAfterPassiveVerb = mainVerbIdx !== -1 && noun.idx > mainVerbIdx && isPassiveVerb;
                   
                    // If positioned like a subject, disambiguate to nominative
                    if (isBeforeVerb || isAfterPassiveVerb) {
                        // Remove accusative from the case, keep only nominative
                        const oldCase = noun.case;
                        noun.case = noun.case.replace(/\/acc|acc\/|acc /gi, '').replace(/\s+/g, ' ').trim();
                        if (!noun.case.includes('nom')) {
                            noun.case = 'nom ' + noun.case.replace('acc', '').trim();
                        }
                        // CRITICAL: Update the original token's case, not just the copy!
                        noun.token.features.case = noun.case;
                        console.log(`[EARLY DISAMBIGUATION] "${noun.token.word}" changed from "${oldCase}" to "${noun.case}" (subject position)`);
                    } else {
                        // Otherwise, likely an object - disambiguate to accusative
                        const oldCase = noun.case;
                        noun.case = noun.case.replace(/\/nom|nom\/|nom /gi, '').replace(/\s+/g, ' ').trim();
                        if (!noun.case.includes('acc')) {
                            noun.case = 'acc ' + noun.case;
                        }
                        // CRITICAL: Update the original token's case, not just the copy!
                        noun.token.features.case = noun.case;
                        console.log(`[EARLY DISAMBIGUATION] "${noun.token.word}" changed from "${oldCase}" to "${noun.case}" (object position)`);
                    }
                }
            }
        }

        // HEAD VERBS that take indirect statement (acc + inf)
        const indirectStatementVerbs = new Set(['say', 'think', 'believe', 'see', 'hear', 'know',
            'perceive', 'learn', 'report', 'tell', 'show', 'teach', 'feel', 'understand', 'hope']);
       
        // IMPERSONAL VERBS that take acc + inf
        const impersonalVerbs = new Set(['be necessary', 'be fitting', 'please', 'be proper']);
       
        // COMMAND/PERMISSION VERBS that take acc + inf
        const commandVerbs = new Set(['order', 'command', 'forbid', 'allow', 'permit', 'force', 'compel']);

        // Check if we have an infinitive construction
        if (structure.hasInfinitive && structure.allInfinitives.length > 0) {
            const infIdx = structure.allInfinitives[0].idx;
           
            // Find the main finite verb
            let mainVerb = null;
            let mainVerbIdx = -1;
            for (const v of structure.allVerbs) {
                if (v.idx < infIdx) {  // Verb before infinitive
                    mainVerb = v;
                    mainVerbIdx = v.idx;
                    break;
                }
            }

            // Check if main verb is an indirect statement head
            if (mainVerb) {
                const mainVerbDef = normalizeWord(mainVerb.definition || '');
                const isIndirectHead = indirectStatementVerbs.has(mainVerbDef) ||
                                      impersonalVerbs.has(mainVerbDef) ||
                                      commandVerbs.has(mainVerbDef);

                if (isIndirectHead) {
                    structure.isIndirectStatement = true;
                   
                    // Main verb of the sentence
                    structure.verb = mainVerb;
                   
                    // Detect person and number of main verb
                    const personInfo = getVerbPersonNumber(mainVerb.token);
                    structure.mainVerbPerson = personInfo.person;
                    structure.mainVerbNumber = personInfo.number;
                    structure.mainVerbExpectedSubject = personInfo.expectedSubject;
                   
                    // Find subject of infinitive (accusative before infinitive)
                    let accBeforeInf = null;
                    let secondAcc = null;
                   
                    for (const noun of structure.allNouns) {
                        if (noun.case && /acc/i.test(noun.case)) {
                            if (noun.idx > mainVerbIdx && noun.idx < infIdx) {
                                // Accusative between main verb and infinitive = subject of infinitive
                                if (!accBeforeInf) {
                                    accBeforeInf = noun;
                                } else {
                                    secondAcc = noun;
                                }
                            } else if (noun.idx > infIdx) {
                                // Accusative after infinitive = object of infinitive
                                secondAcc = noun;
                            }
                        }
                    }
                   
                    if (accBeforeInf) {
                        structure.infinitiveSubject = {
                            token: accBeforeInf.token,
                            idx: accBeforeInf.idx,
                            definition: accBeforeInf.token.definition
                        };
                        structure.subject = structure.infinitiveSubject; // For translation checking
                    }
                   
                    structure.infinitiveVerb = structure.allInfinitives[0];
                   
                    if (secondAcc) {
                        structure.infinitiveObject = {
                            token: secondAcc.token,
                            idx: secondAcc.idx,
                            definition: secondAcc.token.definition
                        };
                        structure.object = structure.infinitiveObject;
                    }
                   
                    // Find subject of main verb (nominative, if any)
                    for (const noun of structure.allNouns) {
                        if (noun.case && /nom/i.test(noun.case)) {
                            if (noun.idx < mainVerbIdx) {
                                // This would be subject of main verb, but we focus on infinitive clause
                                break;
                            }
                        }
                    }
                }
            }
        }

        // Check for direct speech (reporting verb + finite verb, no infinitive)
        // e.g., "inquit, 'orator sum'" = He says, "I am an orator"
        let isDirectSpeech = false;
        if (!structure.hasInfinitive && structure.allVerbs.length > 1) {
            // Check if first verb is a reporting verb
            const firstVerb = structure.allVerbs[0];
            const firstVerbDef = normalizeWord(firstVerb.definition || '');
           
            // Check if definition contains any reporting verb (not exact match)
            const isReportingVerb = Array.from(indirectStatementVerbs).some(verb =>
                firstVerbDef.includes(verb)
            );
           
            if (isReportingVerb) {
                // Check if second verb is a finite form of "sum" (common in direct speech)
                const secondVerb = structure.allVerbs[1];
                const secondVerbWord = secondVerb.token.normalized;
                if (/^(sum|es|est|sumus|estis|sunt)$/i.test(secondVerbWord)) {
                    isDirectSpeech = true;
                    structure.isDirectSpeech = true;
                    // For direct speech, use the reporting verb as the main verb
                    structure.verb = firstVerb;
                    // Don't validate the structure of the quoted speech
                }
            }
        }

        // If NOT an indirect statement and NOT direct speech, use traditional parsing
        if (!structure.isIndirectStatement && !isDirectSpeech) {
            // Find nominative noun as subject
            console.log(`[SUBJECT SEARCH] Looking for nominative subject among ${structure.allNouns.length} nouns`);
            for (const noun of structure.allNouns) {
                console.log(`[SUBJECT SEARCH] Checking noun "${noun.token.word}": case="${noun.case}", inPrep=${prepTokenIndices.has(noun.idx)}, def="${noun.token.definition}"`);
                if (prepTokenIndices.has(noun.idx)) {
                    console.log(`[SUBJECT SEARCH] Skipping "${noun.token.word}" - in prepositional phrase`);
                    continue;
                }
                // FIXED: Accept "nom" even if followed by slash (e.g., "nom/abl sg")
if (noun.case && /nom/i.test(noun.case) && noun.token.definition && noun.token.definition !== 'unknown')  {
    structure.subject = {
        token: noun.token,
        idx: noun.idx,
        definition: noun.token.definition
    };
    console.log(`[SUBJECT SEARCH] SELECTED "${noun.token.original}" as subject (case: ${noun.case}, def: ${noun.token.definition})`);
    break; // Take first nominative with definition
} else {
    console.log(`[SUBJECT SEARCH] Rejected "${noun.token.original}" - nomTest=${/nom/i.test(noun.case)}, hasDef=${!!(noun.token.definition && noun.token.definition !== 'unknown')}`);
}
            }

            // Find accusative noun as object
            for (const noun of structure.allNouns) {
                if (prepTokenIndices.has(noun.idx)) continue;
                if (noun.case && /acc/i.test(noun.case)) {
                    // Skip if this accusative is already used as infinitive subject
                    if (structure.infinitiveSubject && noun.idx === structure.infinitiveSubject.idx) {
                        continue;
                    }
                    structure.object = {
                        token: noun.token,
                        idx: noun.idx,
                        definition: noun.token.definition
                    };
                    break; // Take first accusative
                }
            }

            // Find main finite verb
            if (structure.allVerbs.length > 0) {
                structure.verb = structure.allVerbs[0];
            }
        }

        // Identify modifiers (adjectives near subject and object)
        tokens.forEach((token, idx) => {
            if (token.pos === 'adjective' || token.pos === 'gerundive') {
                // Check if it modifies the subject
                if (structure.subject && Math.abs(idx - structure.subject.idx) <= 2) {
                    if (token.features.case && structure.subject.token.features.case &&
                        sameCaseBucket(token.features.case, structure.subject.token.features.case)) {
                        structure.subjectModifiers.push({ token, idx, definition: token.definition });
                    }
                }
                // Check if it modifies the object
                if (structure.object && Math.abs(idx - structure.object.idx) <= 2) {
                    if (token.features.case && structure.object.token.features.case &&
                        sameCaseBucket(token.features.case, structure.object.token.features.case)) {
                        structure.objectModifiers.push({ token, idx, definition: token.definition });
                    }
                }
            }
        });

        console.log('[DEBUG] All nouns:', structure.allNouns.map(n =>
    `${n.token.word} (case: ${n.case}, def: ${n.token.definition})`
));
console.log('[DEBUG] Prep token indices:', Array.from(prepTokenIndices));
console.log('[DEBUG] Final subject:', structure.subject);

        return structure;
    }

    function parseEnglishStructure(text) {
        const originalWords = text.match(/\b[\w']+\b/g) || [];
        const words = originalWords.map(w => w.toLowerCase());
        const structure = {
            subject: null,
            subjectModifiers: [],
            verb: null,
            object: null,
            objectModifiers: [],
            hasSubordinateClause: false,
            mainClauseSubject: null,
            mainClauseVerb: null,
            subordinateUsesInfinitive: false,
            prepositionalPhrases: [],
            allWords: words
        };
        const prepositionWords = ['for','in','on','at','by','with','from','into','onto','over','under','after','before','toward','towards'];
        const skipIndices = new Set();

        function isCandidateNoun(index) {
            const word = words[index];
            if (!word) return false;
            if (pronounWords.includes(word) || nounWords.includes(word)) return true;
            if (STOP_WORDS.has(word)) return false;
            if (verbPatterns.test(word)) return false;
            const original = originalWords[index] || word;
            if (/^[A-Z]/.test(original)) return true;
            return word.length > 3;
        }

        // Capture simple prepositional phrases such as "for accomplishing", "in the house"
        for (let i = 0; i < words.length - 1; i++) {
            const current = words[i];
            if (prepositionWords.includes(current)) {
                const phraseParts = [current];
                skipIndices.add(i);
                const nextWord = words[i + 1];
                if (nextWord) {
                    phraseParts.push(nextWord);
                    skipIndices.add(i + 1);
                    // include one more non-stop word if available
                    if (i + 2 < words.length) {
                        const third = words[i + 2];
                        if (!STOP_WORDS.has(third)) {
                            phraseParts.push(third);
                            skipIndices.add(i + 2);
                        }
                    }
                }
                structure.prepositionalPhrases.push(phraseParts.join(' '));
            }
        }


        // Noun and adjective word lists
        const nounWords = ['father', 'mother', 'son', 'daughter', 'man', 'woman', 'boy', 'girl',
            'king', 'queen', 'leader', 'soldier', 'god', 'goddess', 'friend', 'brother', 'sister',
            'master', 'slave', 'city', 'people', 'war', 'peace', 'teacher', 'student', 'child',
            'servant', 'lord', 'enemy', 'citizen', 'orator', 'speaker', 'senator', 'general',
            'commander', 'philosopher', 'poet', 'hero', 'warrior', 'slave', 'thing', 'things',
            'human', 'humans', 'men', 'women', 'person', 'persons'];
       
        const pronounWords = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
            'myself', 'yourself', 'himself', 'herself', 'itself', 'ourselves', 'themselves',
            'this', 'that', 'these', 'those'];
       
        const adjectiveWords = ['good', 'bad', 'great', 'small', 'beautiful', 'brave', 'wise',
            'happy', 'sad', 'old', 'new', 'young', 'strong', 'weak'];

        // Common verb forms
        const verbPatterns = /(be|am|is|are|was|were|been|being|love|loves|loved|loving|hate|hates|hated|see|sees|saw|seen|give|gives|gave|given|take|takes|took|taken|come|comes|came|go|goes|went|gone|lead|leads|led|send|sends|sent|call|calls|called|carry|carries|carried|teach|teaches|taught|fear|fears|feared|believe|believes|believed|say|says|said|think|thinks|thought|know|knows|knew|known|do|does|did|done|make|makes|made|have|has|had|order|orders|ordered|tell|tells|told|show|shows|showed|shown|hear|hears|heard|decide|decides|decided|establish|establishes|established|determine|determines|determined|resolve|resolves|resolved|choose|chooses|chose|chosen)/;

        // Reporting verbs that take indirect statements
        const reportingVerbsList = ['say', 'says', 'said', 'think', 'thinks', 'thought', 'believe', 'believes', 'believed',
            'know', 'knows', 'knew', 'see', 'sees', 'saw', 'hear', 'hears', 'heard', 'tell', 'tells', 'told',
            'show', 'shows', 'showed', 'report', 'reports', 'reported', 'claim', 'claims', 'claimed'];
       
        // Check for "that" clause (indirect statement)
        const thatIdx = words.indexOf('that');
       
        // Also check for accusative + infinitive pattern (e.g., "says himself to be")
        let hasAccInfinitive = false;
        let reportingVerbIdx = -1;
        let accInfinitiveSubject = null;
        let accInfinitiveVerb = null;
       
        // Look for reporting verb followed by pronoun/noun + "to" + verb
        for (let i = 0; i < words.length - 2; i++) {
            if (reportingVerbsList.includes(words[i])) {
                // Check if followed by pronoun/noun + "to" + verb
                const nextWord = words[i + 1];
                const toIdx = i + 2;
               
                if (words[toIdx] === 'to' && (pronounWords.includes(nextWord) || nounWords.includes(nextWord))) {
                    // Found accusative + infinitive pattern
                    hasAccInfinitive = true;
                    reportingVerbIdx = i;
                    accInfinitiveSubject = nextWord;
                   
                    // Find the infinitive verb after "to"
                    if (toIdx + 1 < words.length && verbPatterns.test(words[toIdx + 1])) {
                        // Store as full infinitive "to verb"
                        accInfinitiveVerb = 'to ' + words[toIdx + 1];
                    }
                    break;
                }
            }
        }
       
        if (thatIdx !== -1) {
            structure.hasSubordinateClause = true;
           
            // First, extract the MAIN CLAUSE (before "that")
            // Find main clause verb (before "that")
            for (let i = 0; i < thatIdx; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.mainClauseVerb = words[i];
                   
                    // Find main clause subject (before main verb or after, if it exists)
                    for (let j = 0; j < thatIdx; j++) {
                        if (skipIndices.has(j)) continue;
                        if (pronounWords.includes(words[j]) || nounWords.includes(words[j])) {
                            structure.mainClauseSubject = words[j];
                            break;
                        }
                    }
                    break;
                }
            }
           
            // Then extract the SUBORDINATE CLAUSE (after "that")
            // Find verb after "that"
            let subordinateVerbIdx = -1;
            for (let i = thatIdx + 1; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.verb = words[i];
                    subordinateVerbIdx = i;
                   
                    // Check if there's "to" immediately before the verb (infinitive construction)
                    if (i > 0 && words[i - 1] === 'to') {
                        structure.subordinateUsesInfinitive = true;
                    }
                    break;
                }
            }
           
            // Find subject between "that" and subordinate verb
            if (subordinateVerbIdx !== -1) {
                for (let i = thatIdx + 1; i < subordinateVerbIdx; i++) {
                    if (skipIndices.has(i)) continue;
                    if (isCandidateNoun(i)) {
                        structure.subject = words[i];
                       
                        // Look for modifiers before this noun (after "that")
                        for (let j = thatIdx + 1; j < i; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.subjectModifiers.push(words[j]);
                            }
                        }
                        break;
                    }
                }
               
                // Find object after subordinate verb
                for (let i = subordinateVerbIdx + 1; i < words.length; i++) {
                    if (skipIndices.has(i)) continue;
                    if (isCandidateNoun(i)) {
                        structure.object = words[i];
                       
                        // Look for modifiers
                        for (let j = subordinateVerbIdx + 1; j < i; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.objectModifiers.push(words[j]);
                            }
                        }
                        for (let j = i + 1; j < words.length && (j - i) <= 2; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.objectModifiers.push(words[j]);
                            }
                        }
                        break;
                    }
                }
            }
        } else if (hasAccInfinitive) {
            // Accusative + Infinitive construction (e.g., "He says himself to be an orator")
            structure.hasSubordinateClause = true;
           
            // Set main clause verb (the reporting verb)
            structure.mainClauseVerb = words[reportingVerbIdx];
           
            // Find main clause subject (before the reporting verb)
            for (let i = 0; i < reportingVerbIdx; i++) {
                if (pronounWords.includes(words[i]) || nounWords.includes(words[i])) {
                    structure.mainClauseSubject = words[i];
                    break;
                }
            }
           
            // Map reflexive pronouns to subject forms for comparison
            const reflexiveMap = {
                'myself': 'i',
                'yourself': 'you',
                'himself': 'he',
                'herself': 'she',
                'itself': 'it',
                'ourselves': 'we',
                'yourselves': 'you',
                'themselves': 'they'
            };
           
            // Set subordinate clause subject (the accusative subject of infinitive)
            // Keep the actual pronoun form (don't map reflexives to personal pronouns)
            structure.subject = accInfinitiveSubject;
           
            // Set subordinate clause verb (the infinitive)
            structure.verb = accInfinitiveVerb;
           
            // Look for object after the infinitive verb
            const toIdx = reportingVerbIdx + 2; // position of "to"
            const infVerbIdx = toIdx + 1; // position of infinitive verb
           
            // Skip articles when looking for object
            const articles = ['a', 'an', 'the'];
           
            for (let i = infVerbIdx + 1; i < words.length; i++) {
                // Skip articles
                if (articles.includes(words[i])) {
                    continue;
                }
               
                if (nounWords.includes(words[i]) || pronounWords.includes(words[i])) {
                    structure.object = words[i];
                   
                    // Look for modifiers (adjectives, but not articles)
                    for (let j = infVerbIdx + 1; j < i; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }
        } else {
            // Simple sentence without "that" or acc+inf - use original logic
            // Find verb position
            let verbIdx = -1;
            for (let i = 0; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.verb = words[i];
                    verbIdx = i;

                    // Check if there's "to" immediately before the verb (might be indirect statement without "that")
                    if (i > 0 && words[i - 1] === 'to') {
                        // Could be an infinitive in a sentence that should use "that"
                        structure.subordinateUsesInfinitive = true;
                    }
                    break;
                }
            }

            if (verbIdx === -1) {
                // No clear verb found
                return structure;
            }

            // Look for subject before verb
            for (let i = verbIdx - 1; i >= 0; i--) {
                if (skipIndices.has(i)) continue;
                if (isCandidateNoun(i)) {
                    structure.subject = words[i];

                    // Look for modifiers before this noun
                    for (let j = i - 1; j >= 0 && (i - j) <= 3; j--) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.subjectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }

            // Look for object after verb
            for (let i = verbIdx + 1; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (isCandidateNoun(i)) {
                    structure.object = words[i];
                   
                    // Look for modifiers
                    for (let j = verbIdx + 1; j < i; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    for (let j = i + 1; j < words.length && (j - i) <= 2; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }
        }

        return structure;
    }

    function validateStructuralMatch(latinStruct, englishStruct) {
        const errors = [];

        // 0a. For direct speech, only validate the reporting verb, not the quoted content
        // e.g., "inquit, 'orator sum'" = "He says, 'I am an orator'"
        if (latinStruct.isDirectSpeech) {
            // Check if there's a reporting verb in the English
            const englishWords = englishStruct.allWords || [];
            const hasReportingVerb = englishWords.some(w =>
                ['say', 'says', 'said', 'tell', 'tells', 'told', 'ask', 'asks', 'asked'].includes(w)
            );
           
            if (!hasReportingVerb) {
                return {
                    isCorrect: false,
                    reason: 'missing reporting verb (e.g., "says", "said")'
                };
            }
           
            // Validate person/number of the reporting verb
            if (latinStruct.verb) {
                const personInfo = getVerbPersonNumber(latinStruct.verb.token);
                const expectedSubject = personInfo.expectedSubject.toLowerCase();
               
                // Find English subject (word before reporting verb)
                let englishSubject = null;
                for (let i = 0; i < englishWords.length; i++) {
                    if (['say', 'says', 'said', 'tell', 'tells', 'told', 'ask', 'asks', 'asked'].includes(englishWords[i])) {
                        if (i > 0) {
                            englishSubject = englishWords[i - 1].toLowerCase();
                        }
                        break;
                    }
                }
               
                // Check person/number agreement
                if (englishSubject) {
                    // For 3rd person singular: expect "he", "she", "it" (reject "they", "I", "we")
                    if (personInfo.person === 3 && personInfo.number === 'singular') {
                        if (englishSubject === 'they') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject number (Latin verb is singular, expected "he/she/it" not "they")'
                            };
                        } else if (['i', 'we', 'you'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 3rd person, expected "he/she/it")'
                            };
                        }
                    }
                    // For 3rd person plural: expect "they"
                    else if (personInfo.person === 3 && personInfo.number === 'plural') {
                        if (['he', 'she', 'it'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject number (Latin verb is plural, expected "they" not singular)'
                            };
                        } else if (['i', 'we'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 3rd person plural, expected "they")'
                            };
                        }
                    }
                    // For 1st person singular: expect "I"
                    else if (personInfo.person === 1 && personInfo.number === 'singular') {
                        if (englishSubject !== 'i') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 1st person singular, expected "I")'
                            };
                        }
                    }
                    // For 1st person plural: expect "we"
                    else if (personInfo.person === 1 && personInfo.number === 'plural') {
                        if (englishSubject !== 'we') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 1st person plural, expected "we")'
                            };
                        }
                    }
                }
            }
           
            // Direct speech is correct if it has a reporting verb and correct person/number
            // Don't validate the internal structure of the quoted speech
            return { isCorrect: true };
        }

        // PRIORITY CHECK: If Latin has an explicit subject, validate it FIRST before checking verb agreement
        // This ensures subject errors are caught before verb number errors
        // 1. Check subject match (subordinate clause or simple sentence)
        if (latinStruct.subject) {
            const latinSubjectDef = normalizeWord(latinStruct.subject.definition || '');
            const englishSubject = normalizeWord(englishStruct.subject || '');
           
            if (!englishSubject) {
                errors.push('missing subject');
            } else {
                // Special handling for reflexive pronouns
                // Latin "se" (himself/herself/itself/themselves) must refer back to main clause subject
                const isReflexive = latinSubjectDef.includes('himself') || latinSubjectDef.includes('herself') ||
                                   latinSubjectDef.includes('itself') || latinSubjectDef.includes('themselves');
               
                if (isReflexive) {
                    // For reflexive pronouns, the subordinate subject MUST be in reflexive form
                    const mainSubject = normalizeWord(englishStruct.mainClauseSubject || '');
                   
                    // If we don't have a main clause subject, this might be a simple sentence with reflexive
                    // In that case, still require a reflexive form
                    if (!mainSubject) {
                        const isReflexiveForm = ['himself', 'herself', 'itself', 'themselves', 'myself', 'yourself', 'ourselves', 'yourselves'].includes(englishSubject);
                        if (!isReflexiveForm) {
                            return {
                                isCorrect: false,
                                reason: `reflexive pronoun required (Latin "se" must be translated as "himself/herself/itself/themselves", not "${englishStruct.subject}")`
                            };
                        }
                    } else {
                        // We have a main subject, so validate proper reflexive matching
                        // Mapping: main subject → ONLY reflexive forms allowed
                        const reflexiveExpected = {
                            'he': ['himself'],
                            'she': ['herself'],
                            'it': ['itself'],
                            'they': ['themselves'],
                            'i': ['myself'],
                            'you': ['yourself', 'yourselves'],
                            'we': ['ourselves']
                        };
                       
                        const allowedSubjects = reflexiveExpected[mainSubject] || [];
                       
                        if (!allowedSubjects.includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: `reflexive pronoun required (main subject is "${englishStruct.mainClauseSubject}", so reflexive subject must be "${allowedSubjects.join(' or ')}", not "${englishStruct.subject}")`
                            };
                        }
                    }
                } else if (!wordsMatch(latinSubjectDef, englishSubject)) {
                    return {
                        isCorrect: false,
                        reason: `wrong subject (expected "${latinStruct.subject.definition}" but found "${englishStruct.subject}")`
                    };
                }
            }
        }

        // 0b. For simple sentences with no explicit subject, validate the subject implied by verb ending
        // This handles cases like "constituo" → "I decide" (not "she decides")
        // NOTE: This now runs AFTER explicit subject checking
        if (!latinStruct.subject && latinStruct.verb && !latinStruct.isIndirectStatement && !latinStruct.isDirectSpeech) {
            // Get the person/number from the Latin verb
            const personInfo = getVerbPersonNumber(latinStruct.verb.token);
           
            // Get the English subject
            const englishSubject = (englishStruct.subject || englishStruct.mainClauseSubject || '').toLowerCase();
           
            if (englishSubject) {
                // Validate person/number agreement
                if (personInfo.person === 1 && personInfo.number === 'singular') {
                    if (englishSubject !== 'i') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 1st person singular, expected "I" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 2 && personInfo.number === 'singular') {
                    if (englishSubject !== 'you') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 2nd person singular, expected "you" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 3 && personInfo.number === 'singular') {
                    // For 3rd person, accept pronouns (he/she/it) OR any noun/name
                    // Don't reject if it's a proper noun like "Orgetorix" or common noun like "the man"
                    const is1stOr2ndPerson = ['i', 'we', 'you'].includes(englishSubject);
                    if (is1stOr2ndPerson) {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 3rd person singular, expected "he/she/it" or a noun, but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 1 && personInfo.number === 'plural') {
                    if (englishSubject !== 'we') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 1st person plural, expected "we" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 2 && personInfo.number === 'plural') {
                    if (englishSubject !== 'you') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 2nd person plural, expected "you" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 3 && personInfo.number === 'plural') {
                    // For 3rd person plural, accept "they" OR any plural noun phrase
                    // Don't reject if it's a noun like "the soldiers" or "Romans"
                    const is1stOr2ndPerson = ['i', 'we', 'you'].includes(englishSubject);
                    const is3rdSingular = ['he', 'she', 'it'].includes(englishSubject);
                    if (is1stOr2ndPerson || is3rdSingular) {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 3rd person plural, expected "they" or a plural noun, but found "${englishSubject}")`
                        };
                    }
                }
            }
        }

        // 0c. For indirect statements, first validate the MAIN CLAUSE
        if (latinStruct.isIndirectStatement && latinStruct.mainVerbExpectedSubject) {
            // Check if English incorrectly uses infinitive in subordinate clause
            // ONLY reject if using infinitive inside a "that" clause (should be finite verb)
            // ALLOW accusative + infinitive constructions without "that" (valid alternative)
            if (englishStruct.subordinateUsesInfinitive && englishStruct.hasSubordinateClause) {
                // Check if it has "that" - if so, shouldn't use infinitive after "that"
                const words = englishStruct.allWords || [];
                const hasThat = words.includes('that');
               
                if (hasThat) {
                    return {
                        isCorrect: false,
                        reason: 'incorrect infinitive form (use "he is" not "he to be" after "that")'
                    };
                }
                // If no "that", it's an acc+inf construction which is valid
            }
           
            if (!englishStruct.mainClauseSubject) {
                return {
                    isCorrect: false,
                    reason: 'missing main clause subject (e.g., "He says...")'
                };
            }
           
            const expectedSubject = latinStruct.mainVerbExpectedSubject.toLowerCase();
            const actualSubject = englishStruct.mainClauseSubject.toLowerCase();
           
            // Check if the subject matches based on person/number
            // For person 1 singular: expect "I"
            if (latinStruct.mainVerbPerson === 1 && latinStruct.mainVerbNumber === 'singular') {
                if (actualSubject !== 'i') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 1st person singular, expected "I" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 2 singular: expect "you"
            else if (latinStruct.mainVerbPerson === 2 && latinStruct.mainVerbNumber === 'singular') {
                if (actualSubject !== 'you') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 2nd person singular, expected "you" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 3 singular: expect "he", "she", "it", or a noun
            else if (latinStruct.mainVerbPerson === 3 && latinStruct.mainVerbNumber === 'singular') {
                if (!['he', 'she', 'it'].includes(actualSubject)) {
                    // If it's a noun, that's okay too - but should be singular
                    // For now, we'll be lenient and just reject first/second person pronouns
                    if (['i', 'we', 'you', 'they'].includes(actualSubject)) {
                        return {
                            isCorrect: false,
                            reason: `wrong main clause subject (Latin verb is 3rd person singular, expected "he/she/it" or a noun, but found "${englishStruct.mainClauseSubject}")`
                        };
                    }
                }
            }
            // For person 1 plural: expect "we"
            else if (latinStruct.mainVerbPerson === 1 && latinStruct.mainVerbNumber === 'plural') {
                if (actualSubject !== 'we') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 1st person plural, expected "we" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 3 plural: expect "they"
            else if (latinStruct.mainVerbPerson === 3 && latinStruct.mainVerbNumber === 'plural') {
                if (actualSubject !== 'they' && !['he', 'she', 'it'].includes(actualSubject)) {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 3rd person plural, expected "they" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
        }

        // 2. Check object match
      // 2. Check object match
console.log('[OBJECT CHECK] Latin object:', latinStruct.object);
console.log('[OBJECT CHECK] English object:', englishStruct.object);

if (latinStruct.object) {
    const latinObjectDef = normalizeWord(latinStruct.object.definition || '');
    const englishObject = normalizeWord(englishStruct.object || '');
    
    console.log('[OBJECT CHECK] Normalized - Latin:', latinObjectDef, 'English:', englishObject);
   
    if (!englishObject) {
        console.log('[OBJECT CHECK] ✗ Missing English object');
        errors.push('missing object');
    } else {
        const matches = wordsMatch(latinObjectDef, englishObject);
        console.log('[OBJECT CHECK] wordsMatch result:', matches);
        
        if (!matches) {
            console.log('[OBJECT CHECK] ✗ Object mismatch detected');
            return {
                isCorrect: false,
                reason: `wrong object (expected "${latinStruct.object.definition}" but found "${englishStruct.object}")`
            };
        } else {
            console.log('[OBJECT CHECK] ✓ Object matches');
        }
    }
} else {
    console.log('[OBJECT CHECK] No Latin object found in structure');
}

        // 3. Check verb match (use infinitive verb if it's an indirect statement)
        const latinVerbToCheck = latinStruct.infinitiveVerb || latinStruct.verb;
        if (latinVerbToCheck) {
            const latinVerbDef = normalizeWord(latinVerbToCheck.definition || '');
            let englishVerb = normalizeWord(englishStruct.verb || '');

            if (!englishVerb) {
                errors.push('missing verb');
            } else {
                // Strip "to " from English infinitives for comparison with Latin verb definitions
                // e.g., "to be" → "be" to match Latin "esse" → "be"
                const englishVerbBase = englishVerb.replace(/^to\s+/, '');

                if (!wordsMatch(latinVerbDef, englishVerbBase)) {
                    return {
                        isCorrect: false,
                        reason: `wrong verb (expected "${latinVerbToCheck.definition}" but found "${englishStruct.verb}")`
                    };
                }
            }
        }

        // 4. Check subject modifiers
        if (latinStruct.subjectModifiers.length > 0) {
            const latinMods = latinStruct.subjectModifiers.map(m => normalizeWord(m.definition || ''));
            const englishMods = englishStruct.subjectModifiers.map(m => normalizeWord(m));
           
            for (const latinMod of latinMods) {
                const matched = englishMods.some(eMod => wordsMatch(latinMod, eMod));
                if (!matched) {
                    // Check if there's a contradictory modifier
                    const contradiction = findContradictions([latinMod], englishMods.concat(englishStruct.objectModifiers));
                    if (contradiction.length > 0) {
                        return {
                            isCorrect: false,
                            reason: `wrong modifier (expected "${latinMod}" describing subject, but found "${contradiction[0].found}")`
                        };
                    }
                }
            }
        }

        // 5. Check object modifiers
        if (latinStruct.objectModifiers.length > 0) {
            const latinMods = latinStruct.objectModifiers.map(m => normalizeWord(m.definition || ''));
            const englishMods = englishStruct.objectModifiers.map(m => normalizeWord(m));
           
            for (const latinMod of latinMods) {
                const matched = englishMods.some(eMod => wordsMatch(latinMod, eMod));
                if (!matched) {
                    // Check if there's a contradictory modifier
                    const contradiction = findContradictions([latinMod], englishMods.concat(englishStruct.subjectModifiers));
                    if (contradiction.length > 0) {
                        return {
                            isCorrect: false,
                            reason: `wrong modifier (expected "${latinMod}" describing object, but found "${contradiction[0].found}")`
                        };
                    }
                }
            }
        }

        // 6. Final fallback: Check for semantic contradictions in all words
        if (STATE.baselineEnglish) {
            const userWords = (englishStruct.allWords || []).filter(w => !STOP_WORDS.has(w));
            const contradictions = findContradictions(STATE.baselineEnglish, userWords);
            if (contradictions.length > 0) {
                return {
                    isCorrect: false,
                    reason: `contradictory meaning (expected "${contradictions[0].expected}" but found "${contradictions[0].found}")`
                };
            }
        }

        // If we have errors, report them
        if (errors.length > 0) {
            return {
                isCorrect: false,
                reason: errors.join(', ')
            };
        }

        return { isCorrect: true, reason: '' };
    }
    function wordsMatch(word1, word2) {
    if (!word1 || !word2) return false;

    const w1 = normalizeWord(word1);
    const w2 = normalizeWord(word2);

    // If word1 contains multiple definitions (comma-separated), check if word2 matches ANY of them
    if (w1.includes(',')) {
        const definitions = w1.split(',').map(def => def.trim());
        for (const def of definitions) {
            // Direct match only for multiple definitions
            if (def === w2) return true;
        }
        return false;
    }

    // Single definition - standard matching
    // Direct match
    if (w1 === w2) return true;

    // STRICTER: Only allow 1 character difference (was 2)
    if (levenshteinDistance(w1, w2) <= 1) return true;

    // STRICTER: Only allow stem match if one word is a clear prefix (min 4 chars)
    if (w1.length >= 4 && w2.length >= 4) {
        if (w1.startsWith(w2) || w2.startsWith(w1)) return true;
    }

    return false;
}

    function sameCaseBucket(a, b) {
        const aCases = extractCaseTags(a);
        const bCases = extractCaseTags(b);
        if (!aCases.length || !bCases.length) return false;
        return aCases.some(c => bCases.includes(c));
    }

    function extractCaseTags(info) {
        if (!info) return [];
        const matches = info.toLowerCase().match(/nom|gen|dat|acc|abl|voc|loc/g);
        return matches ? Array.from(new Set(matches)) : [];
    }

    function extractNumberTags(token) {
        const tags = new Set();
        const caseInfo = (token.features.case || '').toLowerCase();
        if (caseInfo.includes('sg')) tags.add('singular');
        if (caseInfo.includes('pl')) tags.add('plural');

        const num = token.features.number;
        if (Array.isArray(num)) {
            num.forEach(n => {
                const lower = (n || '').toLowerCase();
                if (/singular|sg/.test(lower)) tags.add('singular');
                if (/plural|pl/.test(lower)) tags.add('plural');
            });
        } else if (typeof num === 'string') {
            const lower = num.toLowerCase();
            if (/singular|sg/.test(lower)) tags.add('singular');
            if (/plural|pl/.test(lower)) tags.add('plural');
        }
        return Array.from(tags);
    }

    function extractGenderTags(token) {
        const tags = new Set();
        const caseInfo = (token.features.case || '').toLowerCase();
        if (caseInfo.includes('fem')) tags.add('feminine');
        if (caseInfo.includes('masc')) tags.add('masculine');
        if (caseInfo.includes('neut')) tags.add('neuter');

        const gender = token.features.gender;
        if (Array.isArray(gender)) {
            gender.forEach(g => {
                if (g) tags.add(g.toLowerCase());
            });
        } else if (typeof gender === 'string' && gender) {
            tags.add(gender.toLowerCase());
        }

        if (!tags.size) {
            const w = token.normalized || '';
            if (/(ae|am|arum|a)$/.test(w)) tags.add('feminine');
            else if (/(us|i|os|orum)$/.test(w) && !/(ius|bus)$/.test(w)) tags.add('masculine');
            else if (/(um|on|ia|ium|ibus)$/.test(w)) tags.add('neuter');

            if (token.pos === 'participle' || token.pos === 'gerundive') {
                if (/a$/.test(w)) tags.add('feminine');
                if (/(us|tus|sus|ctus|ptus|rsus)$/.test(w)) tags.add('masculine');
                if (/(um|tum|sum|ctum|ptum|rsum)$/.test(w)) tags.add('neuter');
            }
        }

        return Array.from(tags);
    }

    function tokensMorphologicallyAgree(a, b) {
        const aCases = extractCaseTags(a.features.case);
        const bCases = extractCaseTags(b.features.case);
        if (!aCases.length || !bCases.length || !aCases.some(c => bCases.includes(c))) {
            return false;
        }

        const numsA = extractNumberTags(a);
        const numsB = extractNumberTags(b);
        if (numsA.length && numsB.length && !numsA.some(n => numsB.includes(n))) {
            return false;
        }

        const gensA = extractGenderTags(a);
        const gensB = extractGenderTags(b);
        if (gensA.length && gensB.length && !gensA.some(g => gensB.includes(g))) {
            return false;
        }

        return true;
    }

    function findContradictions(expectedWords, userWords) {
        const contradictions = [];
       
        for (const expected of expectedWords) {
            const opposites = SEMANTIC_OPPOSITES[expected] || [];
            for (const userWord of userWords) {
                if (opposites.includes(userWord)) {
                    contradictions.push({ expected, found: userWord });
                }
            }
        }
       
        return contradictions;
    }

    function normalizeWord(word) {
        // Normalize to base form for better matching
        word = word.toLowerCase();
       
        // Handle common verb forms
        if (word.endsWith('ing')) return word.slice(0, -3); // loving -> lov
        if (word.endsWith('ed')) return word.slice(0, -2); // loved -> lov
        if (word.endsWith('es')) return word.slice(0, -2); // loves -> lov
        if (word.endsWith('s') && word.length > 3) return word.slice(0, -1); // loves -> love
       
        // Handle common plural forms
        if (word.endsWith('ies')) return word.slice(0, -3) + 'y'; // cities -> city
       
        return word;
    }

    function hasRelatedForm(word, wordList) {
        // Check if any word in the list is a related form
        const baseWord = word.length > 3 ? word.slice(0, -1) : word;
        return wordList.some(w => {
            return w === word ||
                   w.startsWith(baseWord) ||
                   baseWord.startsWith(w) ||
                   levenshteinDistance(word, w) <= 2;
        });
    }

    function isRelatedToAny(word, wordList) {
        return wordList.some(expected => {
            const dist = levenshteinDistance(word, expected);
            return dist <= 2 || word.startsWith(expected) || expected.startsWith(word);
        });
    }

    function levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
       
        const matrix = [];
       
        for (let i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
       
        for (let j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
       
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
       
        return matrix[b.length][a.length];
    }

    // Analysis pipeline
    function analyze(rawText, opts) {
        const tokens = tokenize(rawText);
        const authorBias = inferAuthorBias(opts.author);
        tokens.forEach(t => annotateToken(t, authorBias));
        const groups = buildTranslationChunks(rawText, tokens, authorBias);
        const grammar = detectComplexGrammar(tokens, authorBias);
        const baselineEnglish = buildBaselineEnglish(tokens);
        return { tokens, groups, grammar, baselineEnglish };
    }

    function tokenize(text) {
        const regex = /\p{L}+[\p{L}\-]*/gu;
        const tokens = [];
        let m;
        while ((m = regex.exec(text)) !== null) {
            const word = m[0];
            const start = m.index;
            tokens.push({
                original: word,
                normalized: normalizeLatin(word),
                pos: 'unknown',
                features: {},
                definition: lookupDefinition(word),
                start,
                end: start + word.length
            });
        }
        return tokens;
    }

    function normalizeLatin(w) {
        return w
            .toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // strip diacritics
            .replace(/j/g, 'i')
            .replace(/v/g, 'u');
    }
    function getLemma(word, pos) {
    // Simple lemmatization rules to find base form
    const w = normalizeLatin(word);
    
    if (pos === 'adjective' || pos === 'noun') {
        // Try removing common endings to find base form
        const endings = [
            'as', 'os', 'es', 'is',           // accusative plurals
            'arum', 'orum', 'ium', 'erum',    // genitive plurals  
            'ibus', 'ebus',                   // dative/ablative plurals
            'am', 'um', 'em',                 // accusative singulars
            'ae', 'i', 'ei'                   // genitive/dative singulars
        ];
        
        for (const ending of endings) {
            if (w.endsWith(ending) && w.length > ending.length + 1) {
                const base = w.slice(0, -ending.length);
                
                // Try different base forms based on declension patterns
                const candidates = [
                    base + 'us',   // 2nd declension masculine (certus)
                    base + 'a',    // 1st declension feminine (sagitta)
                    base + 'um',   // 2nd declension neuter
                    base + 'is',   // 3rd declension
                    base + 'e',    // 3rd declension neuter
                    base + 'or',   // 3rd declension (amor)
                    base + 'o',    // 3rd declension (homo)
                    base + 'ex',   // 3rd declension (rex)
                    base + 'x'     // 3rd declension (dux, vox)
                ];
                
                for (const candidate of candidates) {
                    if (LEXICON[candidate]) {
                        return candidate;
                    }
                }
            }
        }
    }
    
    if (pos === 'verb') {
        // Try removing verb endings to find infinitive
        const verbEndings = [
            'nt', 't', 'mus', 'tis', 'ntur', 'tur',  // present
            'o', 'm', 'or',                           // 1st person
            'bat', 'bant', 'batur', 'bantur',        // imperfect
            'vi', 'vit', 'verunt', 'visti'           // perfect
        ];
        
        for (const ending of verbEndings) {
            if (w.endsWith(ending) && w.length > ending.length + 2) {
                const base = w.slice(0, -ending.length);
                
                // Try different infinitive forms
                const candidates = [
                    base + 'are',   // 1st conjugation
                    base + 'ere',   // 2nd conjugation
                    base + 'ere',   // 3rd conjugation
                    base + 'ire'    // 4th conjugation
                ];
                
                for (const candidate of candidates) {
                    if (LEXICON[candidate]) {
                        return candidate;
                    }
                }
            }
        }
    }
    
    return null;
}

    function annotateToken(t, bias) {
        const w = t.normalized;
       
        // FIRST: Check if word exists in LEXICON
        const lexEntry = LEXICON[w];
        if (lexEntry && lexEntry.pos) {
            t.pos = lexEntry.pos;
            t.definition = lexEntry.def; // Set definition from lexicon!
           
            // Set appropriate features based on part of speech
            if (lexEntry.pos === 'noun' || lexEntry.pos === 'proper-noun' || lexEntry.pos === 'adjective' || lexEntry.pos === 'participle' || lexEntry.pos === 'gerundive') {
                // If lexicon has case information, use it (for irregular forms like "omnis")
                if (lexEntry.case) {
                    t.features.case = lexEntry.case;
                } else {
                    // Try to determine case from word endings
                    if (/(ae|am|as|arum|a)$/.test(w)) {
                        t.features.case = caseFromEnding1st(w);
                    } else if (/(us|i|o|um|os|orum)$/.test(w)) {
                        t.features.case = caseFromEnding2nd(w);
                    } else if (/(em|es|is|e|ibus|um|ium)$/.test(w)) {
                        t.features.case = caseFromEnding3rd(w);
                    } else if (/er$/.test(w)) {
                        t.features.case = 'nom sg';
                    } else if (/(or|x)$/.test(w)) {
                        t.features.case = 'nom sg';
                    }
                }
            }
            if (lexEntry.pos === 'verb') {
                // Try to determine tense from word endings
                if (/re$|sse$/.test(w)) {
                    t.features.tense = 'infinitive';
                } else if (/(vi|vit|visti|xit|si|sit)$/.test(w)) {
                    t.features.tense = 'perfect';
                } else if (/nt$/.test(w)) {
                    t.features.tense = 'present';
                } else {
                    t.features.tense = 'present';
                }
            }
            if (lexEntry.pos === 'participle') {
                // Set tense for participles
                if (/(urus|ura|urum)$/.test(w)) {
                    t.features.tense = 'future';
                } else if (/n(s|t[ieao]|tis|tem|tes|tia|tium|tibus)$/.test(w)) {
                    t.features.tense = 'present';
                } else {
                    t.features.tense = 'perfect'; // Most common
                }
            }
            if (lexEntry.pos === 'gerundive') {
                t.features.voice = 'passive';
                if (!t.features.tense) {
                    t.features.tense = 'future';
                }
            }

            return;
        }
 // TRY LEMMATIZATION: If word not in lexicon, try to find its base form
 if (!lexEntry || !lexEntry.def) {
        // First do basic POS detection if we don't have it yet
        if (!t.pos || t.pos === 'unknown') {
            // Quick POS detection based on endings (simplified version)
            if (/(us|a|um|is|e|as|os|es|arum|orum)$/i.test(w)) {
                t.pos = 'adjective'; // Could be noun or adjective, try both
            } else if (/(o|or|m|t|nt|mus|tis|re)$/i.test(w)) {
                t.pos = 'verb';
            }
        }
        
        const lemma = getLemma(w, t.pos);
        if (lemma && LEXICON[lemma]) {
            console.log(`[LEMMA] Found lemma for "${w}": "${lemma}" → ${LEXICON[lemma].def}`);
            t.definition = LEXICON[lemma].def;
            t.pos = LEXICON[lemma].pos;
            return;
        }
        
        // If adjective didn't work, try as noun
        if (t.pos === 'adjective') {
            const nounLemma = getLemma(w, 'noun');
            if (nounLemma && LEXICON[nounLemma]) {
                console.log(`[LEMMA] Found noun lemma for "${w}": "${nounLemma}" → ${LEXICON[nounLemma].def}`);
                t.definition = LEXICON[nounLemma].def;
                t.pos = LEXICON[nounLemma].pos;
                return;
            }
        }
    }
        
        // SECOND: Fall back to morphology heuristics if not in LEXICON
        // Check for participles FIRST (before verbs) to avoid misclassification
       
        // Perfect participles: -tus, -ta, -tum, -sus, -sa, -sum, -ctus, -ptus, -rsus
        if (/(tus|ta|tum|sus|sa|sum|ctus|cta|ctum|ptus|pta|ptum|rsus|rsa|rsum)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'perfect';
            // Also assign case based on ending
            if (/a$/.test(w)) {
                t.features.case = 'nom/abl sg fem';
            } else if (/(us|tus|sus|ctus|ptus|rsus)$/.test(w)) {
                t.features.case = 'nom sg masc';
            } else if (/(um|tum|sum|ctum|ptum|rsum)$/.test(w)) {
                t.features.case = 'nom/acc sg neut';
            }
            return;
        }
       
        // Future active participles: -urus, -ura, -urum
        if (/(urus|ura|urum)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'future';
            return;
        }
       
        // Present active participles: -ns, -ntis, -ntem, -ntes (but not verb endings)
        // Check for -ns or -nt- followed by vowels (case endings)
        if (/n(s|t[ieao]|tis|tem|tes|tia|tium|tibus)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'present';
            return;
        }
       
        // NOW check verb patterns (after participles)
        // Irregular verb: sum, esse (to be)
        if (/\b(sum|es|est|sumus|estis|sunt|eram|eras|erat|eramus|eratis|erant|ero|eris|erit|erimus|eritis|erunt|fui|fuisti|fuit|fuimus|fuistis|fuerunt|fueram|fueras|fuerat|fueramus|fueratis|fuerant)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^fu/.test(w) ? 'perfect' : (/^era/.test(w) ? 'imperfect' : 'present');
            t.definition ||= 'be';
            return;
        }
        // Irregular verb: possum, posse (to be able)
        if (/\b(possum|potes|potest|possumus|potestis|possunt|poteram|poteras|poterat|poteramus|poteratis|poterant|potero|poteris|poterit|poterimus|poteritis|poterunt|potui|potuisti|potuit|potuimus|potuistis|potuerunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^potu/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'be able, can';
            return;
        }
        // Irregular verb: eo, ire (to go)
        if (/\b(eo|is|it|imus|itis|eunt|ibam|ibas|ibat|ibamus|ibatis|ibant|ibo|ibis|ibit|ibimus|ibitis|ibunt|ii|ivi|iisti|ivisti|iit|ivit|iimus|ivimus|iistis|ivistis|ierunt|iverunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^i[iv]/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'go';
            return;
        }
        // Irregular verb: fero, ferre (to carry, bear)
        if (/\b(fero|fers|fert|ferimus|fertis|ferunt|ferebam|ferebas|ferebat|ferebamus|ferebatis|ferebant|feram|feres|feret|feremus|feretis|ferent|tuli|tulisti|tulit|tulimus|tulistis|tulerunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^tul/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'carry, bear, bring';
            return;
        }
        // Irregular verb: volo, velle (to want, wish)
        if (/\b(volo|vis|vult|volumus|vultis|volunt|volebam|volebas|volebat|volebamus|volebatis|volebant|volam|voles|volet|volemus|voletis|volent|volui|voluisti|voluit|voluimus|voluistis|voluerunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^volu/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'want, wish';
            return;
        }
        // Irregular verb: nolo, nolle (to not want, be unwilling)
        if (/\b(nolo|non vis|non vult|nolumus|non vultis|nolunt|nolebam|nolebas|nolebat|nolebamus|nolebatis|nolebant|nolam|noles|nolet|nolemus|noletis|nolent|nolui|noluisti|noluit|noluimus|noluistis|noluerunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^nolu/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'not want, be unwilling';
            return;
        }
        // Irregular verb: malo, malle (to prefer)
        if (/\b(malo|mavis|mavult|malumus|mavultis|malunt|malebam|malebas|malebat|malebamus|malebatis|malebant|malam|males|malet|malemus|maletis|malent|malui|maluisti|maluit|maluimus|maluistis|maluerunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = /^malu/.test(w) ? 'perfect' : 'present';
            t.definition ||= 'prefer';
            return;
        }

        // Infinitives (before other verb endings)
        if (/re$/.test(w) && !/(urus|ura|urum)$/.test(w)) {
            t.pos = 'verb';
            t.features.tense = 'infinitive';
            // Check if it's a perfect infinitive (-isse)
            if (/isse$/.test(w)) {
                t.features.tense = 'perfect infinitive';
            }
            return;
        }

        // Passive voice endings (present/imperfect system)
        if (/(or|ris|tur|mur|mini|ntur)$/.test(w) && !/(urus|ura|urum|ior|ius)$/.test(w)) {
            t.pos = 'verb';
            t.features.voice = 'passive';
            t.features.tense = 'present';
            return;
        }
        // Imperfect passive: -bar, -baris, -batur, -bamur, -bamini, -bantur
        if (/(bar|baris|batur|bamur|bamini|bantur)$/.test(w)) {
            t.pos = 'verb';
            t.features.voice = 'passive';
            t.features.tense = 'imperfect';
            return;
        }

        // Perfect tense forms (active voice)
        // Common perfect endings: -i, -isti, -it, -imus, -istis, -erunt, -ere
        if (/(avi|evi|ivi|ui|xi|si)$/.test(w) || // 1st person sg perfect
            /(avisti|evisti|ivisti|uisti|xisti|sisti)$/.test(w) || // 2nd person sg perfect
            /(avit|evit|ivit|uit|xit|sit)$/.test(w) || // 3rd person sg perfect
            /(avimus|evimus|ivimus|uimus|ximus|simus)$/.test(w) || // 1st person pl perfect
            /(avistis|evistis|ivistis|uistis|xistis|sistis)$/.test(w) || // 2nd person pl perfect
            /(averunt|everunt|iverunt|uerunt|xerunt|serunt|avere|evere|ivere|uere|xere|sere)$/.test(w)) { // 3rd person pl perfect
            t.pos = 'verb';
            t.features.tense = 'perfect';
            t.features.voice = 'active';
            return;
        }

        // Pluperfect tense: -eram, -eras, -erat, -eramus, -eratis, -erant (but not "sum" forms, already handled)
        if (/(averam|averas|averat|averamus|averatis|averant|everam|everas|everat|everamus|everatis|everant|iveram|iveras|iverat|iveramus|iveratis|iverant|ueram|ueras|uerat|ueramus|ueratis|uerant)$/.test(w)) {
            t.pos = 'verb';
            t.features.tense = 'pluperfect';
            t.features.voice = 'active';
            return;
        }

        // Future perfect: -ero, -eris, -erit, -erimus, -eritis, -erint
        if (/(avero|averis|averit|averimus|averitis|averint|evero|everis|everit|everimus|everitis|everint|ivero|iveris|iverit|iverimus|iveritis|iverint|uero|ueris|uerit|uerimus|ueritis|uerint)$/.test(w)) {
            t.pos = 'verb';
            t.features.tense = 'future perfect';
            t.features.voice = 'active';
            return;
        }


     // Finite verb forms (present/future)
// Only match if it's a likely verb ending, not generic -um
if (/nt$/.test(w) || /t$/.test(w) || (/o$/.test(w) || (/m$/.test(w) && !/um$/.test(w)))) {
    if (!/(tus|sus|ctus|ptus|rsus)$/.test(w)) {
        t.pos = 'verb';
        // ...
        return;
    }
}
        // Comparative adjectives: -ior (masc/fem), -ius (neut)
        // Must check before regular adjective patterns to avoid misclassification
        if (/(ior|ius|iorem|iores|ioris|iori|ioribus|iorum)$/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'comparative';
            // Determine case based on ending
            if (/ior$/.test(w)) {
                t.features.case = 'nom sg masc/fem';
            } else if (/ius$/.test(w)) {
                t.features.case = 'nom/acc sg neut';
            } else if (/iorem$/.test(w)) {
                t.features.case = 'acc sg masc/fem';
            } else if (/iores$/.test(w)) {
                t.features.case = 'nom/acc pl masc/fem';
            } else if (/ioris$/.test(w)) {
                t.features.case = 'gen sg';
            } else if (/iori$/.test(w)) {
                t.features.case = 'dat sg or abl sg';
            } else if (/ioribus$/.test(w)) {
                t.features.case = 'dat/abl pl';
            } else if (/iorum$/.test(w)) {
                t.features.case = 'gen pl';
            }
            return;
        }

        // Superlative adjectives: -issimus, -issima, -issimum (and other declensions)
        if (/(issimus|issima|issimum|issimi|issimae|issimo|issimam|issimos|issimarum|issimorum|issimis)$/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            // Determine case based on ending (follows 1st/2nd declension)
            if (/issimus$/.test(w)) {
                t.features.case = 'nom sg masc';
            } else if (/issima$/.test(w)) {
                t.features.case = 'nom/abl sg fem';
            } else if (/issimum$/.test(w)) {
                t.features.case = 'nom/acc sg neut or acc sg masc';
            } else if (/issimi$/.test(w)) {
                t.features.case = 'gen sg masc/neut or nom pl masc';
            } else if (/issimae$/.test(w)) {
                t.features.case = 'gen/dat sg fem or nom pl fem';
            } else if (/issimo$/.test(w)) {
                t.features.case = 'dat/abl sg masc/neut';
            } else if (/issimam$/.test(w)) {
                t.features.case = 'acc sg fem';
            } else if (/issimos$/.test(w)) {
                t.features.case = 'acc pl masc';
            } else if (/(issimarum|issimorum)$/.test(w)) {
                t.features.case = 'gen pl';
            } else if (/issimis$/.test(w)) {
                t.features.case = 'dat/abl pl';
            }
            return;
        }

        // Irregular superlatives (common ones)
        if (/\b(optimus|optima|optimum|optimi|optimae|optimo|optimam|optimos|optimarum|optimorum|optimis)\b/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            t.definition ||= 'best';
            return;
        }
        if (/\b(pessimus|pessima|pessimum|pessimi|pessimae|pessimo|pessimam|pessimos|pessimarum|pessimorum|pessimis)\b/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            t.definition ||= 'worst';
            return;
        }
        if (/\b(maximus|maxima|maximum|maximi|maximae|maximo|maximam|maximos|maximarum|maximorum|maximis)\b/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            t.definition ||= 'greatest, largest';
            return;
        }
        if (/\b(minimus|minima|minimum|minimi|minimae|minimo|minimam|minimos|minimarum|minimorum|minimis)\b/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            t.definition ||= 'smallest, least';
            return;
        }
        if (/\b(plurimus|plurima|plurimum|plurimi|plurimae|plurimo|plurimam|plurimos|plurimarum|plurimorum|plurimis)\b/.test(w)) {
            t.pos = 'adjective';
            t.features.degree = 'superlative';
            t.definition ||= 'most, very many';
            return;
        }

        // Noun/adjective endings (very simplified)
        if (/(ae|am|as|arum)$/.test(w) || /(a)$/.test(w)) {
            t.pos = guessAdjOrNoun(w);
            t.features.case = caseFromEnding1st(w);
            return;
        }
        if (/(us|i|o|um|os|orum)$/.test(w)) {
            t.pos = guessAdjOrNoun(w);
            t.features.case = caseFromEnding2nd(w);
            return;
        }
        if (/(em|es|is|e|ibus|um|ium)$/.test(w)) {
            t.pos = 'noun';
            t.features.case = caseFromEnding3rd(w);
            return;
        }
        if (/que$|ve$|ne$/.test(w)) {
            t.pos = 'particle';
            return;
        }
        // fallback
        t.pos = t.pos || 'unknown';
    }

    function guessAdjOrNoun(w) {
        return LEXICON[w]?.pos || (/(us|a|um|i|ae)$/.test(w) ? 'adjective' : 'noun');
    }

    function caseFromEnding1st(w) {
        if (/ae$/.test(w)) return 'gen/dat sg or nom pl';
        if (/am$/.test(w)) return 'acc sg';
        if (/arum$/.test(w)) return 'gen pl';
        if (/a$/.test(w)) return 'nom/abl sg';
        return undefined;
    }

    function caseFromEnding2nd(w) {
        if (/i$/.test(w)) return 'gen sg or nom pl';
        if (/o$/.test(w)) return 'dat/abl sg';
        if (/um$/.test(w)) return 'acc sg (or nom/acc sg neuter)';
        if (/os$/.test(w)) return 'acc pl';
        if (/orum$/.test(w)) return 'gen pl';
        if (/us$/.test(w)) return 'nom sg';
        return undefined;
    }

    function caseFromEnding3rd(w) {
        if (/em$/.test(w)) return 'acc sg';
        if (/es$/.test(w)) return 'nom/acc pl';
        if (/is$/.test(w)) return 'gen sg or dat sg';
        if (/e$/.test(w)) return 'abl sg';
        if (/ibus$/.test(w)) return 'dat/abl pl';
        if (/um$/.test(w)) return 'gen pl';
        if (/ium$/.test(w)) return 'gen pl (i-stem)';
        return undefined;
    }

    // Helper: Detect if a verb is subjunctive based on endings
    function isSubjunctive(token) {
        if (token.pos !== 'verb') return false;
        const w = token.normalized;
        // Present subjunctive: -em, -am, -et, -at, -emus, -amus, -etis, -atis, -ent, -ant
        if (/(em|am|et|at|emus|amus|etis|atis|ent|ant)$/.test(w)) return true;
        // Imperfect subjunctive: -rem, -res, -ret, -remus, -retis, -rent
        if (/(rem|res|ret|remus|retis|rent)$/.test(w)) return true;
        // Perfect subjunctive: -erim, -eris, -erit, -erimus, -eritis, -erint
        if(/(erim|eris|erit|erimus|eritis|erint)$/.test(w)) return true;
        // Pluperfect subjunctive: -issem, -isses, -isset, -issemus, -issetis, -issent
        if(/(issem|isses|isset|issemus|issetis|issent)$/.test(w)) return true;
        return false;
    }

    // Helper: Check if "cum" is preposition (with abl) or conjunction (with verb)
    function isCumPreposition(tokens, cumIdx) {
        if (cumIdx + 1 >= tokens.length) return false;
        const nextToken = tokens[cumIdx + 1];
        // Check if next word is ablative
        const nextCase = nextToken.features.case || '';
        return /abl/.test(nextCase) || nextToken.normalized.endsWith('o');
    }

    // Helper: Check if "ut" introduces subjunctive clause
    function isUtClause(tokens, utIdx) {
        // Look ahead 1-3 words for a verb
        for (let i = utIdx + 1; i <= Math.min(utIdx + 3, tokens.length - 1); i++) {
            if (tokens[i].pos === 'verb') {
                return isSubjunctive(tokens[i]);
            }
        }
        return false; // Default to not a clause if no verb found
    }

    // Helper: Detect ablative absolute (abl noun + abl participle)
    function findAblativeAbsolutes(tokens) {
        const ablAbsolutes = [];
        for (let i = 0; i < tokens.length - 1; i++) {
            const t1 = tokens[i];
            const t2 = tokens[i + 1];
            if ((t1.pos === 'noun' || t1.pos === 'pronoun') && t2.pos === 'participle') {
                if (tokensMorphologicallyAgree(t1, t2)) {
                    const nounCases = extractCaseTags(t1.features.case);
                    const partCases = extractCaseTags(t2.features.case);
                    if (nounCases.includes('abl') && partCases.includes('abl')) {
                        ablAbsolutes.push([i, i + 1]);
                    }
                }
            }
        }
        return ablAbsolutes;
    }

    function buildTranslationChunks(rawText, tokens, bias) {
    if (!tokens || tokens.length === 0) return [];

    const chunks = [];

    // Helper: Check if segment has a finite verb
    function hasFiniteVerb(startIdx, endIdx) {
        for (let i = startIdx; i <= endIdx; i++) {
            const t = tokens[i];
            if (t && t.pos === 'verb' && t.features.tense !== 'infinitive') {
                return true;
            }
        }
        return false;
    }

    // Helper: Check if segment has an infinitive
    function hasInfinitive(startIdx, endIdx) {
        for (let i = startIdx; i <= endIdx; i++) {
            const t = tokens[i];
            if (t && t.pos === 'verb' && t.features.tense === 'infinitive') {
                return true;
            }
        }
        return false;
    }

    // Helper: Check if segment contains a purpose clause (ut/ne + verb)
    function hasPurposeClause(startIdx, endIdx) {
        for (let i = startIdx; i < endIdx; i++) {
            const t = tokens[i];
            if (t && (t.normalized === 'ut' || t.normalized === 'ne')) {
                // Look for verb within next 5 words
                for (let j = i + 1; j <= Math.min(endIdx, i + 5); j++) {
                    if (tokens[j] && tokens[j].pos === 'verb') {
                        return true;
                    }
                }
            }
        }
        return false;
    }

    // Helper: Check if segment starts with ablative absolute (abl noun + abl participle at start)
    function startsWithAblativeAbsolute(startIdx, endIdx) {
        if (endIdx - startIdx < 1) return false;
        
        for (let i = startIdx; i <= Math.min(startIdx + 3, endIdx - 1); i++) {
            const t1 = tokens[i];
            const t2 = tokens[i + 1];
            
            if ((t1.pos === 'noun' || t1.pos === 'pronoun') && t2.pos === 'participle') {
                const t1Case = t1.features.case || '';
                const t2Case = t2.features.case || '';
                if (/abl/.test(t1Case) && /abl/.test(t2Case)) {
                    return true;
                }
            }
        }
        return false;
    }

    // Step 1: Find all punctuation marks and their types
    const punctuationMarks = [];

    for (let i = 0; i < tokens.length - 1; i++) {
        const t = tokens[i];
        const next = tokens[i + 1];
        const between = rawText.slice(t.end, next.start);

        if (between.includes('.')) {
            punctuationMarks.push({ idx: i, type: 'period' });
        } else if (between.includes(';')) {
            punctuationMarks.push({ idx: i, type: 'semicolon' });
        } else if (between.includes(',')) {
            punctuationMarks.push({ idx: i, type: 'comma' });
        }
    }

    // Step 2: Split by periods and semicolons first (always boundaries)
    const majorBoundaries = punctuationMarks
        .filter(p => p.type === 'period' || p.type === 'semicolon')
        .map(p => p.idx);

    // Add end of tokens as final boundary
    majorBoundaries.push(tokens.length - 1);

    // Step 3: For each major segment, decide if commas create sub-chunks
    let segmentStart = 0;

    for (const majorBoundaryIdx of majorBoundaries) {
        // Get all commas within this segment
        const commasInSegment = punctuationMarks
            .filter(p => p.type === 'comma' && p.idx >= segmentStart && p.idx < majorBoundaryIdx)
            .map(p => p.idx);

        if (commasInSegment.length === 0) {
            // No commas - entire segment is one chunk
            const chunkTokens = [];
            for (let i = segmentStart; i <= majorBoundaryIdx; i++) {
                chunkTokens.push(i);
            }
            if (chunkTokens.length > 0) {
                chunks.push({ tokens: chunkTokens, type: 'main', name: 'Main Clause' });
            }
        } else {
            // Has commas - use improved splitting logic
            const potentialBoundaries = [segmentStart - 1, ...commasInSegment, majorBoundaryIdx];
            const validChunks = [];
            let currentChunkStart = segmentStart;

            for (let i = 1; i < potentialBoundaries.length; i++) {
                const boundaryIdx = potentialBoundaries[i];
                const segmentEnd = boundaryIdx;

                // Check various conditions for this segment
                const hasVerb = hasFiniteVerb(currentChunkStart, segmentEnd);
                const hasInf = hasInfinitive(currentChunkStart, segmentEnd);
                const hasPurpose = hasPurposeClause(currentChunkStart, segmentEnd);
                const hasAblAbs = startsWithAblativeAbsolute(currentChunkStart, segmentEnd);

                // Look ahead: does the NEXT segment also have content?
                let nextSegmentHasVerb = false;
                let nextSegmentHasInf = false;
                let nextSegmentHasPurpose = false;
                
                if (i < potentialBoundaries.length - 1) {
                    const nextStart = boundaryIdx + 1;
                    const nextEnd = potentialBoundaries[i + 1];
                    nextSegmentHasVerb = hasFiniteVerb(nextStart, nextEnd);
                    nextSegmentHasInf = hasInfinitive(nextStart, nextEnd);
                    nextSegmentHasPurpose = hasPurposeClause(nextStart, nextEnd);
                }

                // DECISION: Split at this comma if any of these conditions are met:
                const shouldSplit = 
                    // 1. Both sides have finite verbs (original rule)
                    (hasVerb && nextSegmentHasVerb) ||
                    
                    // 2. Current has infinitive AND next has infinitive (coordinated infinitives)
                    (hasInf && nextSegmentHasInf) ||
                    
                    // 3. Current has purpose clause (always split after purpose clauses)
                    hasPurpose ||
                    
                    // 4. This is the major boundary (end of sentence)
                    (boundaryIdx === majorBoundaryIdx) ||
                    
                    // 5. Current has ablative absolute at start AND has verb (keep abl abs with its clause)
                    (hasAblAbs && hasVerb && (nextSegmentHasVerb || nextSegmentHasInf));

                if (shouldSplit) {
                    const chunkTokens = [];
                    for (let j = currentChunkStart; j <= segmentEnd; j++) {
                        chunkTokens.push(j);
                    }
                    if (chunkTokens.length > 0) {
                        validChunks.push(chunkTokens);
                    }
                    currentChunkStart = segmentEnd + 1;
                }
                // Otherwise, don't split - continue accumulating tokens
            }

            // Add remaining tokens if any
            if (currentChunkStart <= majorBoundaryIdx) {
                const chunkTokens = [];
                for (let j = currentChunkStart; j <= majorBoundaryIdx; j++) {
                    chunkTokens.push(j);
                }
                if (chunkTokens.length > 0) {
                    validChunks.push(chunkTokens);
                }
            }

            // Add all valid chunks for this segment with appropriate labels
            validChunks.forEach(chunkTokens => {
                const chunkTokenObjs = chunkTokens.map(idx => tokens[idx]);
                
                // Determine chunk type based on content
                const hasRelativePronoun = chunkTokenObjs.some(t =>
                    ['qui', 'quae', 'quod', 'quem', 'quam', 'quos', 'quas', 'quo', 'qua', 'quibus', 'cui', 'cuius', 'quorum', 'quarum'].includes(t.normalized)
                );
                const hasCum = chunkTokenObjs.some(t => t.normalized === 'cum');
                const hasUt = chunkTokenObjs.some(t => t.normalized === 'ut' || t.normalized === 'ne');
                const hasInfVerb = chunkTokenObjs.some(t => t.pos === 'verb' && t.features.tense === 'infinitive');
                const hasParticiple = chunkTokenObjs.some(t => t.pos === 'participle');

                let chunkType = 'main';
                let chunkName = 'Main Clause';
                
                if (hasRelativePronoun) {
                    chunkType = 'relative';
                    chunkName = 'Relative Clause';
                } else if (hasUt) {
                    chunkType = 'purpose';
                    chunkName = 'Purpose Clause';
                } else if (hasCum) {
                    chunkType = 'cum-clause';
                    chunkName = 'Cum Clause';
                } else if (hasInfVerb && !hasFiniteVerb(chunkTokens[0], chunkTokens[chunkTokens.length - 1])) {
                    chunkType = 'infinitive';
                    chunkName = 'Infinitive Phrase';
                } else if (hasParticiple && chunkTokenObjs.length <= 4) {
                    chunkType = 'participial';
                    chunkName = 'Participial Phrase';
                }

                chunks.push({
                    tokens: chunkTokens,
                    type: chunkType,
                    name: chunkName
                });
            });
        }

        // Next segment starts after this major boundary
        segmentStart = majorBoundaryIdx + 1;
    }

    // If no chunks were created, make entire text one chunk
    if (chunks.length === 0) {
        const allTokens = [];
        for (let i = 0; i < tokens.length; i++) {
            allTokens.push(i);
        }
        chunks.push({ tokens: allTokens, type: 'main', name: 'Main Clause' });
    }

    return chunks;
}
    function sameCaseBucket(a, b) {
        const aCases = extractCaseTags(a);
        const bCases = extractCaseTags(b);
        if (!aCases.length || !bCases.length) return false;
        return aCases.some(c => bCases.includes(c));
    }

    function mergeSets(sets) {
        const result = [];
        sets.forEach(s => {
            let merged = false;
            for (const r of result) {
                if ([...s].some(x => r.has(x))) { [...s].forEach(x => r.add(x)); merged = true; break; }
            }
            if (!merged) result.push(new Set(s));
        });
        return result;
    }

    function detectComplexGrammar(tokens, bias) {
        const found = [];
    
    // === ABLATIVE ABSOLUTE (with detailed debugging) ===
    // === ABLATIVE ABSOLUTE (improved - allows intervening genitives) ===
console.log('[ABLATIVE ABS] Checking for ablative absolutes...');
for (let i = 0; i < tokens.length; i++) {
    const a = tokens[i];
    
    // Must start with ablative noun/pronoun
    if (!(a.pos === 'noun' || a.pos === 'pronoun')) continue;
    
    const nounCase = (a.features.case || '').toLowerCase();
    if (!nounCase.includes('abl')) continue;
    
    console.log(`[ABLATIVE ABS] Found ablative noun: "${a.original}" (case: ${nounCase})`);
    
    // Look ahead for participle (within 3 words, skipping genitives)
    for (let j = i + 1; j <= Math.min(i + 3, tokens.length - 1); j++) {
        const b = tokens[j];
        
        console.log(`[ABLATIVE ABS]   Checking potential participle: "${b.original}" (${b.pos})`);
        
        // Skip genitive nouns (they modify the ablative noun)
        if ((b.pos === 'noun' || b.pos === 'proper-noun' || b.pos === 'pronoun') && 
            (b.features.case || '').toLowerCase().includes('gen')) {
            console.log(`[ABLATIVE ABS]   Skipping genitive: "${b.original}"`);
            continue;
        }
        
        // Check if it's a participle
        if (b.pos === 'participle') {
            // Get participle case - check multiple sources
            let partCase = (b.features.case || '').toLowerCase();
            
            // If case is missing or wrong, infer from ending
            if (!partCase || (!partCase.includes('abl') && !partCase.includes('nom'))) {
                const word = b.normalized;
                // Perfect participles in -i ending are often nom/abl pl masc
                if (/i$/i.test(word)) {
                    partCase = 'nom/abl pl masc';
                    console.log(`[ABLATIVE ABS]   Inferred case from ending: ${partCase}`);
                }
                // -is ending could be abl/dat pl or gen sg
                else if (/is$/i.test(word)) {
                    partCase = 'abl pl';
                    console.log(`[ABLATIVE ABS]   Inferred case from ending: ${partCase}`);
                }
            }
            
            console.log(`[ABLATIVE ABS]   Participle case: "${partCase}"`);
            
            const partHasAbl = partCase.includes('abl') || partCase.includes('nom');
            
            if (partHasAbl) {
                // Collect all words in between for full phrase
                const phraseTokens = [];
                for (let k = i; k <= j; k++) {
                    phraseTokens.push(tokens[k].original);
                }
                
                console.log(`[ABLATIVE ABS] ✓ FOUND: ${phraseTokens.join(' ')}`);
                found.push({ name: 'Ablative Absolute', text: phraseTokens.join(' ') });
                break; // Found participle for this noun, move to next noun
            } else {
                console.log(`[ABLATIVE ABS] ✗ Participle case doesn't match`);
            }
        }
        
        // Stop if we hit a finite verb or conjunction
        if ((b.pos === 'verb' && b.features.tense !== 'infinitive') || b.pos === 'conjunction') {
            console.log(`[ABLATIVE ABS]   Hit ${b.pos}, stopping search`);
            break;
        }
    }
}
    
    // === REST OF THE FUNCTION (keep all the other sections) ===
    // Supine detection
    const motion = new Set(['venit','veniunt','venimus','venio','eo','iit','ierunt','ibat','ibant','ivimus','adeo','redeo']);
    for (let i = 0; i < tokens.length - 1; i++) {
        if (motion.has(tokens[i].normalized) && /um$/.test(tokens[i+1].normalized)) {
            found.push({ name: 'Accusative Supine', text: tokens[i+1].original });
        }
    }
    
    // Indirect statement
    const indirectStatementVerbs = new Set([
        'dico', 'dicis', 'dicit', 'dicimus', 'dicitis', 'dicunt', 'dixit', 'dixerunt',
        'puto', 'putas', 'putat', 'putamus', 'putatis', 'putant', 'putavi', 'putavit',
        'credo', 'credis', 'credit', 'credimus', 'creditis', 'credunt', 'credidi',
        'video', 'vides', 'videt', 'videmus', 'videtis', 'vident', 'vidi', 'viderunt',
        'audio', 'audis', 'audit', 'audimus', 'auditis', 'audiunt', 'audivi', 'audivit',
        'spero', 'speras', 'sperat', 'speramus', 'scio', 'scis', 'scit', 'scimus', 'scitis', 'sciunt',
        'narro', 'narras', 'narrat', 'narramus',
        'constituo', 'constituis', 'constituit', 'constituimus', 'constituitis', 'constituunt', 'constituerunt',
        'statuo', 'statuis', 'statuit', 'statuimus', 'statuitis', 'statuunt', 'statuerunt',
        'decerno', 'decernis', 'decernit', 'decernimus', 'decernitis', 'decernunt', 'decreverunt'
    ]);
    
    for (let i = 0; i < tokens.length; i++) {
        const t = tokens[i];
        
        if (t.pos === 'verb' && t.features.tense === 'infinitive') {
            let reportingVerbIdx = -1;
            
            for (let k = Math.max(0, i - 8); k < i; k++) {
                if (tokens[k].pos === 'verb' && indirectStatementVerbs.has(tokens[k].normalized)) {
                    reportingVerbIdx = k;
                    break;
                }
            }
            
            if (reportingVerbIdx >= 0) {
                const accSubjects = [];
                
                for (let j = reportingVerbIdx + 1; j < i; j++) {
                    const token = tokens[j];
                    if (token.pos === 'noun' || token.pos === 'pronoun') {
                        const tokenCase = token.features.case || '';
                        const isAccusative = /^acc/.test(tokenCase);
                        const accPronouns = ['me', 'te', 'se', 'nos', 'vos', 'eum', 'eam', 'eos', 'eas', 'id'];
                        const isAccPronoun = accPronouns.includes(token.normalized);
                        
                        if (isAccusative || isAccPronoun) {
                            accSubjects.push(token.original);
                        }
                    }
                }
                
                for (let j = i + 1; j <= Math.min(i + 3, tokens.length - 1); j++) {
                    const token = tokens[j];
                    if (token.pos === 'noun' || token.pos === 'pronoun') {
                        const tokenCase = token.features.case || '';
                        if (/^acc/.test(tokenCase)) {
                            accSubjects.push(token.original);
                        }
                    }
                }
                
                if (accSubjects.length > 0) {
                    const span = [tokens[reportingVerbIdx].original, ...accSubjects, t.original].join(' ');
                    found.push({ name: 'Indirect Statement', text: span });
                    break;
                }
            }
        }
    }
    
    // Relative Clauses (exclude "quam")
    const relSet = new Set(['qui','quae','quod','quem','quo','qua','quibus','cui','cuius','quorum','quarum']);
    
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].normalized === 'quam') continue;
        
        if (relSet.has(tokens[i].normalized)) {
            const span = [tokens[i].original];
            
            for (let j = i + 1; j < tokens.length && j <= i + 5; j++) {
                span.push(tokens[j].original);
                if (tokens[j].pos === 'verb' && tokens[j].features.tense !== 'infinitive') {
                    break;
                }
            }
            
            if (span.length > 1) {
                found.push({ name: 'Relative Clause', text: span.join(' ') });
            }
        }
    }
    
    // Purpose Clauses
    for (let i = 0; i < tokens.length - 1; i++) {
        const t = tokens[i];
        
        if (t.normalized === 'ut' || t.normalized === 'ne') {
            const span = [t.original];
            let foundVerb = false;
            
            for (let j = i + 1; j <= Math.min(i + 8, tokens.length - 1); j++) {
                span.push(tokens[j].original);
                
                if (tokens[j].pos === 'verb' && tokens[j].features.tense !== 'infinitive') {
                    foundVerb = true;
                    break;
                }
            }
            
            if (foundVerb) {
                found.push({ name: 'Purpose Clause', text: span.join(' ') });
            }
        }
    }
    
    // Gerundives
    const gerundiveSeen = new Set();
    
    for (let i = 0; i < tokens.length; i++) {
        const ger = tokens[i];
        
        const isGerundive = ger.pos === 'gerundive' || 
                           /nd(um|am|is|o|os|as|orum|arum|ibus)$/i.test(ger.normalized);
        
        if (!isGerundive) continue;
        
        let start = i;
        let hasAd = false;
        
        for (let j = i - 1; j >= Math.max(0, i - 4); j--) {
            const candidate = tokens[j];
            if (!candidate) break;
            
            if (candidate.normalized === 'ad') {
                start = j;
                hasAd = true;
                break;
            }
            
            if (candidate.pos === 'noun' || candidate.pos === 'pronoun' || candidate.pos === 'adjective') {
                start = j;
                continue;
            }
            
            if (candidate.pos === 'preposition') {
                break;
            }
        }
        
        const phraseTokens = tokens.slice(start, i + 1);
        const text = phraseTokens.map(t => t.original).join(' ');
        const key = `${hasAd ? 'purpose' : 'gerundive'}|${text}`;
        
        if (!gerundiveSeen.has(key)) {
            gerundiveSeen.add(key);
            const label = hasAd ? 'Gerundive of Purpose' : 'Gerundive';
            found.push({ name: label, text });
        }
    }
    
    // Participial Phrases
    const participlesInAdjGroups = new Set();
    
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].pos === 'participle') {
            for (let j = Math.max(0, i - 2); j <= Math.min(tokens.length - 1, i + 2); j++) {
                if (j !== i && (tokens[j].pos === 'noun' || tokens[j].pos === 'pronoun')) {
                    if (tokensMorphologicallyAgree(tokens[i], tokens[j])) {
                        participlesInAdjGroups.add(i);
                        break;
                    }
                }
            }
        }
    }
    
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].pos === 'participle' && !participlesInAdjGroups.has(i)) {
            const windowSize = 3;
            let nearestNoun = null;
            let bestDist = Infinity;
            
            for (let j = Math.max(0, i - windowSize); j <= Math.min(tokens.length - 1, i + windowSize); j++) {
                if (j !== i && (tokens[j].pos === 'noun' || tokens[j].pos === 'pronoun')) {
                    if (tokensMorphologicallyAgree(tokens[i], tokens[j])) {
                        const d = Math.abs(j - i);
                        if (d < bestDist) {
                            nearestNoun = tokens[j];
                            bestDist = d;
                        }
                    }
                }
            }
            
            if (nearestNoun) {
                found.push({ name: 'Participial Phrase', text: `${tokens[i].original} + ${nearestNoun.original}` });
            }
        }
    }
    
    return found;
    }

    function buildBaselineEnglish(tokens) {
        const english = [];
        tokens.forEach(t => {
            const gloss = (t.definition || '').toLowerCase();
            if (!gloss) return;
            const keep = gloss.split(/[^a-z]+/).filter(x => x && x.length > 1);
            keep.forEach(k => english.push(k));
        });
        return Array.from(new Set(english));
    }

    function inferAuthorBias(author) {
        const a = (author || '').toLowerCase();
        const poetryAuthors = ['vergil','virgil','ovid','horace','catullus','propertius','tibullus'];
        const proseAuthors = ['caesar','cicero','sallust','livy','pliny'];
        return {
            poetry: poetryAuthors.some(x => a.includes(x)),
            prose: proseAuthors.some(x => a.includes(x))
        };
    }

    function renderSafe(text) {
        return text.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
    }

    function escapeHtml(s) {
        return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
    }

    // Comprehensive Latin dictionary based on https://personal.math.ubc.ca/~cass/frivs/latin/latin-dict-full.html
    const LEXICON = {
        // Add these to your LEXICON object:
        // === MOST COMMON WORDS (Top 100) ===
// Conjunctions & Particles
'atque': { pos: 'conjunction', def: 'and, and also' },
'ac': { pos: 'conjunction', def: 'and' },
'-que': { pos: 'particle', def: 'and' },
'sed': { pos: 'conjunction', def: 'but' },
'autem': { pos: 'conjunction', def: 'but, however, moreover' },
'enim': { pos: 'particle', def: 'for, indeed' },
'nam': { pos: 'conjunction', def: 'for' },
'etiam': { pos: 'adverb', def: 'also, even' },
'quoque': { pos: 'adverb', def: 'also, too' },
'aut': { pos: 'conjunction', def: 'or' },
'vel': { pos: 'conjunction', def: 'or' },

// Prepositions (very common)
'ab': { pos: 'preposition', def: 'from, by' },
'abs': { pos: 'preposition', def: 'from, by' },
'apud': { pos: 'preposition', def: 'among, at the house of' },
'contra': { pos: 'preposition', def: 'against' },
'inter': { pos: 'preposition', def: 'between, among' },
'ob': { pos: 'preposition', def: 'on account of, because of' },
'propter': { pos: 'preposition', def: 'on account of, because of' },
'trans': { pos: 'preposition', def: 'across' },

// Pronouns (essential)
'ille': { pos: 'pronoun', def: 'that, he' },
'illa': { pos: 'pronoun', def: 'that, she' },
'illud': { pos: 'pronoun', def: 'that' },
'illum': { pos: 'pronoun', def: 'that, him' },
'illam': { pos: 'pronoun', def: 'that, her' },
'illi': { pos: 'pronoun', def: 'to that, those' },
'illius': { pos: 'pronoun', def: 'of that' },
'hic': { pos: 'pronoun', def: 'this, he' },
'haec': { pos: 'pronoun', def: 'this, she' },
'hoc': { pos: 'pronoun', def: 'this' },
'hunc': { pos: 'pronoun', def: 'this, him' },
'hanc': { pos: 'pronoun', def: 'this, her' },
'huius': { pos: 'pronoun', def: 'of this' },
'is': { pos: 'pronoun', def: 'this, that, he' },
'id': { pos: 'pronoun', def: 'this, that, it' },
'idem': { pos: 'pronoun', def: 'the same' },
'eadem': { pos: 'pronoun', def: 'the same' },

// Question words
'quis': { pos: 'pronoun', def: 'who?, what?' },
'quid': { pos: 'pronoun', def: 'what?' },
'cur': { pos: 'adverb', def: 'why?' },
'quando': { pos: 'adverb', def: 'when?' },
'quomodo': { pos: 'adverb', def: 'how?' },
'ubi': { pos: 'adverb', def: 'where?' },

// === SCHOOL & EDUCATION VOCABULARY ===
'schola': { pos: 'noun', def: 'school' },
'scholae': { pos: 'noun', def: 'school' },
'scholam': { pos: 'noun', def: 'school' },
'scholarum': { pos: 'noun', def: 'schools' },
'scholis': { pos: 'noun', def: 'schools' },

'discipulus': { pos: 'noun', def: 'student, pupil' },
'discipuli': { pos: 'noun', def: 'student' },
'discipulo': { pos: 'noun', def: 'student' },
'discipulum': { pos: 'noun', def: 'student' },
'discipulorum': { pos: 'noun', def: 'students' },

'discipula': { pos: 'noun', def: 'female student' },
'discipulae': { pos: 'noun', def: 'female student' },

'magister': { pos: 'noun', def: 'teacher, master' },
'magistri': { pos: 'noun', def: 'teacher' },
'magistro': { pos: 'noun', def: 'teacher' },
'magistrum': { pos: 'noun', def: 'teacher' },
'magistrorum': { pos: 'noun', def: 'teachers' },

'magistra': { pos: 'noun', def: 'female teacher' },
'magistrae': { pos: 'noun', def: 'female teacher' },

'liber': { pos: 'noun', def: 'book' },
'libri': { pos: 'noun', def: 'book' },
'libro': { pos: 'noun', def: 'book' },
'librum': { pos: 'noun', def: 'book' },
'librorum': { pos: 'noun', def: 'books' },
'libris': { pos: 'noun', def: 'books' },

'lectio': { pos: 'noun', def: 'lesson, reading' },
'lectionis': { pos: 'noun', def: 'lesson' },
'lectione': { pos: 'noun', def: 'lesson' },
'lectionem': { pos: 'noun', def: 'lesson' },

'studium': { pos: 'noun', def: 'study, eagerness' },
'studii': { pos: 'noun', def: 'study' },
'studio': { pos: 'noun', def: 'study' },
'studia': { pos: 'noun', def: 'studies' },

'studeo': { pos: 'verb', def: 'study, be eager for' },
'studet': { pos: 'verb', def: 'studies' },
'student': { pos: 'verb', def: 'study' },
'studere': { pos: 'verb', def: 'study' },

'tabula': { pos: 'noun', def: 'board, tablet' },
'tabulae': { pos: 'noun', def: 'board' },
'tabulam': { pos: 'noun', def: 'board' },

'stilus': { pos: 'noun', def: 'stylus, pen' },
'stili': { pos: 'noun', def: 'stylus' },
'stilo': { pos: 'noun', def: 'stylus' },

'litterae': { pos: 'noun', def: 'letters, literature' },
'litterarum': { pos: 'noun', def: 'letters' },

// === CAESAR'S GALLIC WARS (Latin 2-3) ===
'caesar': { pos: 'proper-noun', def: 'Caesar' },
'caesaris': { pos: 'proper-noun', def: 'Caesar' },
'caesarem': { pos: 'proper-noun', def: 'Caesar' },
'caesare': { pos: 'proper-noun', def: 'Caesar' },

'gallia': { pos: 'noun', def: 'Gaul' },
'galliae': { pos: 'noun', def: 'Gaul' },
'galliam': { pos: 'noun', def: 'Gaul' },

'gallus': { pos: 'noun', def: 'Gaul (person)' },
'galli': { pos: 'noun', def: 'Gauls' },
'gallos': { pos: 'noun', def: 'Gauls' },
'gallorum': { pos: 'noun', def: 'Gauls' },

'helvetius': { pos: 'adjective', def: 'Helvetian' },
'helvetii': { pos: 'noun', def: 'Helvetians' },
'helvetiorum': { pos: 'noun', def: 'Helvetians' },

'legio': { pos: 'noun', def: 'legion' },
'legionis': { pos: 'noun', def: 'legion' },
'legionem': { pos: 'noun', def: 'legion' },
'legiones': { pos: 'noun', def: 'legions' },

'castra': { pos: 'noun', def: 'camp' },
'castrorum': { pos: 'noun', def: 'camp' },
'castris': { pos: 'noun', def: 'camp' },

'exercitus': { pos: 'noun', def: 'army' },
'exercituum': { pos: 'noun', def: 'armies' },

'hostis': { pos: 'noun', def: 'enemy' },
'hostes': { pos: 'noun', def: 'enemies' },
'hostium': { pos: 'noun', def: 'enemies' },
'hostibus': { pos: 'noun', def: 'enemies' },

'proelium': { pos: 'noun', def: 'battle' },
'proelii': { pos: 'noun', def: 'battle' },
'proelio': { pos: 'noun', def: 'battle' },
'proelia': { pos: 'noun', def: 'battles' },

'victoria': { pos: 'noun', def: 'victory' },
'victoriae': { pos: 'noun', def: 'victory' },
'victoriam': { pos: 'noun', def: 'victory' },

'clades': { pos: 'noun', def: 'defeat, disaster' },
'cladis': { pos: 'noun', def: 'defeat' },
'cladem': { pos: 'noun', def: 'defeat' },

'imperium': { pos: 'noun', def: 'command, empire' },
'imperii': { pos: 'noun', def: 'command' },
'imperio': { pos: 'noun', def: 'command' },

// === CICERO (Latin 3-4) ===
'cicero': { pos: 'proper-noun', def: 'Cicero' },
'ciceronis': { pos: 'proper-noun', def: 'Cicero' },

'oratio': { pos: 'noun', def: 'speech' },
'orationis': { pos: 'noun', def: 'speech' },
'oratione': { pos: 'noun', def: 'speech' },
'orationem': { pos: 'noun', def: 'speech' },
'orationes': { pos: 'noun', def: 'speeches' },

'coniuratio': { pos: 'noun', def: 'conspiracy' },
'coniurationis': { pos: 'noun', def: 'conspiracy' },
'coniurationem': { pos: 'noun', def: 'conspiracy' },

'catilina': { pos: 'proper-noun', def: 'Catiline' },
'catilinae': { pos: 'proper-noun', def: 'Catiline' },

'senatus': { pos: 'noun', def: 'senate' },
'senatui': { pos: 'noun', def: 'senate' },

'consul': { pos: 'noun', def: 'consul' },
'consulis': { pos: 'noun', def: 'consul' },
'consule': { pos: 'noun', def: 'consul' },
'consulem': { pos: 'noun', def: 'consul' },
'consules': { pos: 'noun', def: 'consuls' },

'res publica': { pos: 'noun', def: 'republic, state' },
'rei publicae': { pos: 'noun', def: 'republic' },

'civis': { pos: 'noun', def: 'citizen' },
'cives': { pos: 'noun', def: 'citizens' },
'civium': { pos: 'noun', def: 'citizens' },

'libertas': { pos: 'noun', def: 'freedom, liberty' },
'libertatis': { pos: 'noun', def: 'freedom' },
'libertatem': { pos: 'noun', def: 'freedom' },
'libertate': { pos: 'noun', def: 'freedom' },

// === VERGIL'S AENEID (Latin 3-4) ===
'vergilius': { pos: 'proper-noun', def: 'Vergil' },
'aeneis': { pos: 'noun', def: 'Aeneid' },
'aeneidos': { pos: 'noun', def: 'Aeneid' },

'pius': { pos: 'adjective', def: 'dutiful, pious' },
'pia': { pos: 'adjective', def: 'dutiful, pious' },
'pium': { pos: 'adjective', def: 'dutiful, pious' },
'pio': { pos: 'adjective', def: 'dutiful, pious' },

'fatum': { pos: 'noun', def: 'fate, destiny' },
'fati': { pos: 'noun', def: 'fate' },
'fato': { pos: 'noun', def: 'fate' },
'fata': { pos: 'noun', def: 'fates' },
'fatis': { pos: 'noun', def: 'fates' },

'dido': { pos: 'proper-noun', def: 'Dido' },
'didonis': { pos: 'proper-noun', def: 'Dido' },

'turnus': { pos: 'proper-noun', def: 'Turnus' },
'turni': { pos: 'proper-noun', def: 'Turnus' },

'latinus': { pos: 'proper-noun', def: 'Latinus' },
'latini': { pos: 'proper-noun', def: 'Latinus' },

'troia': { pos: 'noun', def: 'Troy' },
'troiae': { pos: 'noun', def: 'Troy' },
'troiam': { pos: 'noun', def: 'Troy' },

'troianus': { pos: 'adjective', def: 'Trojan' },
'troiana': { pos: 'adjective', def: 'Trojan' },
'troianum': { pos: 'adjective', def: 'Trojan' },

'heros': { pos: 'noun', def: 'hero' },
'herois': { pos: 'noun', def: 'hero' },
'heroa': { pos: 'noun', def: 'hero' },

// === OVID'S METAMORPHOSES (Latin 4) ===
'ovidius': { pos: 'proper-noun', def: 'Ovid' },
'metamorphosis': { pos: 'noun', def: 'metamorphosis, transformation' },

'apollo': { pos: 'proper-noun', def: 'Apollo' },
'apollinis': { pos: 'proper-noun', def: 'Apollo' },

'daphne': { pos: 'proper-noun', def: 'Daphne' },
'daphnes': { pos: 'proper-noun', def: 'Daphne' },

'cupido': { pos: 'proper-noun', def: 'Cupid' },
'cupidinis': { pos: 'proper-noun', def: 'Cupid' },

'narcissus': { pos: 'proper-noun', def: 'Narcissus' },
'narcissi': { pos: 'proper-noun', def: 'Narcissus' },

'echo': { pos: 'proper-noun', def: 'Echo' },
'echos': { pos: 'proper-noun', def: 'Echo' },

// === COMMON VERBS (all forms) ===
'possum': { pos: 'verb', def: 'be able, can' },
'potes': { pos: 'verb', def: 'can' },
'potest': { pos: 'verb', def: 'can' },
'possumus': { pos: 'verb', def: 'can' },
'potestis': { pos: 'verb', def: 'can' },
'possunt': { pos: 'verb', def: 'can' },
'posse': { pos: 'verb', def: 'be able, can' },
'potui': { pos: 'verb', def: 'was able' },

'volo': { pos: 'verb', def: 'want, wish' },
'vis': { pos: 'verb', def: 'want' },
'vult': { pos: 'verb', def: 'wants' },
'volumus': { pos: 'verb', def: 'want' },
'vultis': { pos: 'verb', def: 'want' },
'volunt': { pos: 'verb', def: 'want' },
'velle': { pos: 'verb', def: 'want' },

'nolo': { pos: 'verb', def: 'not want, be unwilling' },
'non vis': { pos: 'verb', def: 'not want' },
'non vult': { pos: 'verb', def: 'not want' },
'nolumus': { pos: 'verb', def: 'not want' },
'nolunt': { pos: 'verb', def: 'not want' },
'nolle': { pos: 'verb', def: 'not want' },

'fero': { pos: 'verb', def: 'carry, bear, bring' },
'fers': { pos: 'verb', def: 'carry' },
'fert': { pos: 'verb', def: 'carries' },
'ferimus': { pos: 'verb', def: 'carry' },
'fertis': { pos: 'verb', def: 'carry' },
'ferunt': { pos: 'verb', def: 'carry' },
'ferre': { pos: 'verb', def: 'carry' },
'tuli': { pos: 'verb', def: 'carried' },
'latum': { pos: 'verb', def: 'carried' },

'eo': { pos: 'verb', def: 'go' },
'is': { pos: 'verb', def: 'go' },
'it': { pos: 'verb', def: 'goes' },
'imus': { pos: 'verb', def: 'go' },
'itis': { pos: 'verb', def: 'go' },
'eunt': { pos: 'verb', def: 'go' },
'ire': { pos: 'verb', def: 'go' },
'ii': { pos: 'verb', def: 'went' },
'ivi': { pos: 'verb', def: 'went' },
'itum': { pos: 'verb', def: 'gone' },

'inquam': { pos: 'verb', def: 'say, said' },
'inquis': { pos: 'verb', def: 'say' },
'inquit': { pos: 'verb', def: 'says, said' },
'inquiunt': { pos: 'verb', def: 'say' },

// === COMMON ADJECTIVES ===
'melior': { pos: 'adjective', def: 'better' },
'melius': { pos: 'adjective', def: 'better' },
'optimus': { pos: 'adjective', def: 'best' },
'optima': { pos: 'adjective', def: 'best' },
'optimum': { pos: 'adjective', def: 'best' },

'peior': { pos: 'adjective', def: 'worse' },
'peius': { pos: 'adjective', def: 'worse' },
'pessimus': { pos: 'adjective', def: 'worst' },
'pessima': { pos: 'adjective', def: 'worst' },
'pessimum': { pos: 'adjective', def: 'worst' },

'maior': { pos: 'adjective', def: 'greater, larger' },
'maius': { pos: 'adjective', def: 'greater' },
'maximus': { pos: 'adjective', def: 'greatest, largest' },
'maxima': { pos: 'adjective', def: 'greatest' },
'maximum': { pos: 'adjective', def: 'greatest' },

'minor': { pos: 'adjective', def: 'smaller, less' },
'minus': { pos: 'adjective', def: 'smaller, less' },
'minimus': { pos: 'adjective', def: 'smallest, least' },
'minima': { pos: 'adjective', def: 'smallest' },
'minimum': { pos: 'adjective', def: 'smallest' },

'plus': { pos: 'adjective', def: 'more' },
'pluris': { pos: 'adjective', def: 'more' },
'plurimus': { pos: 'adjective', def: 'most, very many' },
'plurima': { pos: 'adjective', def: 'most' },
'plurimum': { pos: 'adjective', def: 'most' },

// === NUMBERS ===
'quattuor': { pos: 'numeral', def: 'four' },
'quinque': { pos: 'numeral', def: 'five' },
'sex': { pos: 'numeral', def: 'six' },
'septem': { pos: 'numeral', def: 'seven' },
'octo': { pos: 'numeral', def: 'eight' },
'novem': { pos: 'numeral', def: 'nine' },
'decem': { pos: 'numeral', def: 'ten' },
'centum': { pos: 'numeral', def: 'hundred' },
'mille': { pos: 'numeral', def: 'thousand' },
'milia': { pos: 'numeral', def: 'thousands' },

// === TIME EXPRESSIONS ===
'dum': { pos: 'conjunction', def: 'while, as long as, until' },
'donec': { pos: 'conjunction', def: 'until, as long as' },
'postquam': { pos: 'conjunction', def: 'after' },
'priusquam': { pos: 'conjunction', def: 'before' },
'antequam': { pos: 'conjunction', def: 'before' },
'simul': { pos: 'adverb', def: 'at the same time, together' },
'simul atque': { pos: 'conjunction', def: 'as soon as' },
'interea': { pos: 'adverb', def: 'meanwhile' },
'subito': { pos: 'adverb', def: 'suddenly' },

// === LOCATION / DIRECTION ===
'huc': { pos: 'adverb', def: 'to here, hither' },
'illuc': { pos: 'adverb', def: 'to there, thither' },
'hinc': { pos: 'adverb', def: 'from here, hence' },
'inde': { pos: 'adverb', def: 'from there, thence' },
'unde': { pos: 'adverb', def: 'from where, whence' },
'quo': { pos: 'adverb', def: 'to where, whither' },
'qua': { pos: 'adverb', def: 'by which way, where' },

// COMMON WORDS THAT ARE ALSO PROPER NAMES
// agricola = farmer (NOT just Agricola the Roman general)
'agricola': { pos: 'noun', def: 'farmer, husbandman' },
'agricolae': { pos: 'noun', def: 'farmer, husbandman' },
'agricolam': { pos: 'noun', def: 'farmer, husbandman' },
'agricolarum': { pos: 'noun', def: 'farmers' },
'agricolis': { pos: 'noun', def: 'farmers' },

// aquila = eagle (NOT just the town or constellation)
'aquila': { pos: 'noun', def: 'eagle' },
'aquilae': { pos: 'noun', def: 'eagle' },
'aquilam': { pos: 'noun', def: 'eagle' },
'aquilarum': { pos: 'noun', def: 'eagles' },

// silva = forest (NOT just Silva as a name)
'silva': { pos: 'noun', def: 'forest, woods' },
'silvae': { pos: 'noun', def: 'forest' },
'silvam': { pos: 'noun', def: 'forest' },
'silvarum': { pos: 'noun', def: 'forests' },
'silvis': { pos: 'noun', def: 'forests' },

// cicero = chickpea (NOT just the orator)
'cicero': { pos: 'noun', def: 'chickpea' },
'ciceronis': { pos: 'noun', def: 'chickpea' },

// scipio = staff, walking stick (NOT just Scipio Africanus)
'scipio': { pos: 'noun', def: 'staff, walking stick' },
'scipionis': { pos: 'noun', def: 'staff' },

// brutus = heavy, dull, stupid (NOT just Marcus Brutus)
'brutus': { pos: 'adjective', def: 'heavy, dull, stupid' },
'bruta': { pos: 'adjective', def: 'heavy, dull' },
'brutum': { pos: 'adjective', def: 'heavy, dull' },

// cato = shrewd person, wise man (NOT just Cato the Elder/Younger)
'cato': { pos: 'noun', def: 'shrewd person, wise man' },
'catonis': { pos: 'noun', def: 'shrewd person' },

// rufus = red, red-haired (common as adjective before becoming a name)
'rufus': { pos: 'adjective', def: 'red, red-haired, ruddy' },
'rufa': { pos: 'adjective', def: 'red, red-haired' },
'rufum': { pos: 'adjective', def: 'red, red-haired' },

// niger = black, dark (common adjective/name)
'niger': { pos: 'adjective', def: 'black, dark' },
'nigra': { pos: 'adjective', def: 'black, dark' },
'nigrum': { pos: 'adjective', def: 'black, dark' },

// albus = white, bright (common adjective/name)
'albus': { pos: 'adjective', def: 'white, bright' },
'alba': { pos: 'adjective', def: 'white, bright' },
'album': { pos: 'adjective', def: 'white, bright' },

// corvus = crow, raven (NOT just the Roman cognomen)
'corvus': { pos: 'noun', def: 'crow, raven' },
'corvi': { pos: 'noun', def: 'crow' },
'corvum': { pos: 'noun', def: 'crow' },

// leo = lion (NOT just Pope Leo or constellation)
'leo': { pos: 'noun', def: 'lion' },
'leonis': { pos: 'noun', def: 'lion' },
'leonem': { pos: 'noun', def: 'lion' },
'leone': { pos: 'noun', def: 'lion' },

// pius = dutiful, pious (NOT just Antoninus Pius)
'pius': { pos: 'adjective', def: 'dutiful, pious, devoted' },
'pia': { pos: 'adjective', def: 'dutiful, pious' },
'pium': { pos: 'adjective', def: 'dutiful, pious' },

// felix = lucky, happy, fortunate (NOT just as a name)
'felix': { pos: 'adjective', def: 'lucky, happy, fortunate' },
'felicis': { pos: 'adjective', def: 'lucky, happy' },
'felicem': { pos: 'adjective', def: 'lucky, happy' },

// victor = conqueror, victor (NOT just as a name)
'victor': { pos: 'noun', def: 'conqueror, victor, winner' },
'victoris': { pos: 'noun', def: 'conqueror' },
'victorem': { pos: 'noun', def: 'conqueror' },

// augustus = majestic, venerable (before it became a title)
'augustus': { pos: 'adjective', def: 'majestic, venerable, august' },
'augusta': { pos: 'adjective', def: 'majestic, venerable' },
'augustum': { pos: 'adjective', def: 'majestic, venerable' },

// gracchus = jackdaw (bird) (NOT just the Gracchi brothers)
'gracchus': { pos: 'noun', def: 'jackdaw (a bird)' },
'gracchi': { pos: 'noun', def: 'jackdaw' },

// flaccus = flabby-eared (common cognomen from adjective)
'flaccus': { pos: 'adjective', def: 'flabby-eared, drooping' },
'flacca': { pos: 'adjective', def: 'flabby-eared' },
'flaccum': { pos: 'adjective', def: 'flabby-eared' },

// paulus = small, little (NOT just the apostle Paul/Paulus)
'paulus': { pos: 'adjective', def: 'small, little' },
'paula': { pos: 'adjective', def: 'small, little' },
'paulum': { pos: 'adjective', def: 'small, little' },

// PRAENOMINA THAT ARE ALSO ORDINAL NUMBERS
// quintus = fifth (both a name and a number)
'quintus': { pos: 'adjective', def: 'fifth' },
'quinta': { pos: 'adjective', def: 'fifth' },
'quintum': { pos: 'adjective', def: 'fifth' },

// sextus = sixth
'sextus': { pos: 'adjective', def: 'sixth' },
'sexta': { pos: 'adjective', def: 'sixth' },
'sextum': { pos: 'adjective', def: 'sixth' },

// septimus = seventh
'septimus': { pos: 'adjective', def: 'seventh' },
'septima': { pos: 'adjective', def: 'seventh' },
'septimum': { pos: 'adjective', def: 'seventh' },

// decimus = tenth
'decimus': { pos: 'adjective', def: 'tenth' },
'decima': { pos: 'adjective', def: 'tenth' },
'decimum': { pos: 'adjective', def: 'tenth' },
        // Common verbs (with infinitives)
        'amo': { pos: 'verb', def: 'love' }, 'amas': { pos: 'verb', def: 'love' }, 'amat': { pos: 'verb', def: 'love' }, 'amamus': { pos: 'verb', def: 'love' }, 'amant': { pos: 'verb', def: 'love' }, 'amare': { pos: 'verb', def: 'love' },
        'amor': { pos: 'verb', def: 'am loved' }, 'amaris': { pos: 'verb', def: 'are loved' }, 'amatur': { pos: 'verb', def: 'is loved' }, 'amamur': { pos: 'verb', def: 'are loved' }, 'amamini': { pos: 'verb', def: 'are loved' }, 'amantur': { pos: 'verb', def: 'are loved' },
        'spero': { pos: 'verb', def: 'hope' }, 'speras': { pos: 'verb', def: 'hope' }, 'sperat': { pos: 'verb', def: 'hope' }, 'speramus': { pos: 'verb', def: 'hope' }, 'sperant': { pos: 'verb', def: 'hope' }, 'sperare': { pos: 'verb', def: 'hope' },
        'laboro': { pos: 'verb', def: 'work' }, 'laboras': { pos: 'verb', def: 'work' }, 'laborat': { pos: 'verb', def: 'work' }, 'laboramus': { pos: 'verb', def: 'work' }, 'laborant': { pos: 'verb', def: 'work' }, 'laborare': { pos: 'verb', def: 'work' },
        'paro': { pos: 'verb', def: 'prepare' }, 'paras': { pos: 'verb', def: 'prepare' }, 'parat': { pos: 'verb', def: 'prepare' }, 'paramus': { pos: 'verb', def: 'prepare' }, 'parant': { pos: 'verb', def: 'prepare' }, 'parare': { pos: 'verb', def: 'prepare' },
        'voco': { pos: 'verb', def: 'call' }, 'vocas': { pos: 'verb', def: 'call' }, 'vocat': { pos: 'verb', def: 'call' }, 'vocamus': { pos: 'verb', def: 'call' }, 'vocant': { pos: 'verb', def: 'call' }, 'vocare': { pos: 'verb', def: 'call' },
        'uoco': { pos: 'verb', def: 'call' }, 'uocas': { pos: 'verb', def: 'call' }, 'uocat': { pos: 'verb', def: 'call' }, 'uocamus': { pos: 'verb', def: 'call' }, 'uocant': { pos: 'verb', def: 'call' }, 'uocare': { pos: 'verb', def: 'call' },
        'laudo': { pos: 'verb', def: 'praise' }, 'laudas': { pos: 'verb', def: 'praise' }, 'laudat': { pos: 'verb', def: 'praise' }, 'laudamus': { pos: 'verb', def: 'praise' }, 'laudant': { pos: 'verb', def: 'praise' }, 'laudare': { pos: 'verb', def: 'praise' },
        'puto': { pos: 'verb', def: 'think' }, 'putas': { pos: 'verb', def: 'think' }, 'putat': { pos: 'verb', def: 'think' }, 'putamus': { pos: 'verb', def: 'think' }, 'putant': { pos: 'verb', def: 'think' }, 'putare': { pos: 'verb', def: 'think' },
        'sum': { pos: 'verb', def: 'be' }, 'es': { pos: 'verb', def: 'be' }, 'est': { pos: 'verb', def: 'be' }, 'sumus': { pos: 'verb', def: 'be' }, 'estis': { pos: 'verb', def: 'be' }, 'sunt': { pos: 'verb', def: 'be' }, 'esse': { pos: 'verb', def: 'be' },
        'video': { pos: 'verb', def: 'see' }, 'vides': { pos: 'verb', def: 'see' }, 'videt': { pos: 'verb', def: 'see' }, 'videmus': { pos: 'verb', def: 'see' }, 'videtis': { pos: 'verb', def: 'see' }, 'vident': { pos: 'verb', def: 'see' }, 'vidi': { pos: 'verb', def: 'see' }, 'visum': { pos: 'verb', def: 'see' }, 'videre': { pos: 'verb', def: 'see' },
        'videor': { pos: 'verb', def: 'am seen, seem' }, 'videris': { pos: 'verb', def: 'are seen, seem' }, 'videtur': { pos: 'verb', def: 'is seen, seems' }, 'videmur': { pos: 'verb', def: 'are seen, seem' }, 'videmini': { pos: 'verb', def: 'are seen' }, 'videntur': { pos: 'verb', def: 'are seen, seem' },
        'uideo': { pos: 'verb', def: 'see' }, 'uides': { pos: 'verb', def: 'see' }, 'uidet': { pos: 'verb', def: 'see' }, 'uidemus': { pos: 'verb', def: 'see' }, 'uidetis': { pos: 'verb', def: 'see' }, 'uident': { pos: 'verb', def: 'see' }, 'uidi': { pos: 'verb', def: 'see' }, 'uisum': { pos: 'verb', def: 'see' }, 'uidere': { pos: 'verb', def: 'see' },
        'dico': { pos: 'verb', def: 'say' }, 'dicis': { pos: 'verb', def: 'say' }, 'dicit': { pos: 'verb', def: 'say' }, 'dicimus': { pos: 'verb', def: 'say' }, 'dicitis': { pos: 'verb', def: 'say' }, 'dicunt': { pos: 'verb', def: 'say' }, 'dixit': { pos: 'verb', def: 'say' }, 'dicere': { pos: 'verb', def: 'say' },
        'inquam': { pos: 'verb', def: 'say' }, 'inquis': { pos: 'verb', def: 'say' }, 'inquit': { pos: 'verb', def: 'says' }, 'inquiunt': { pos: 'verb', def: 'say' },
        'facio': { pos: 'verb', def: 'do, make' }, 'facit': { pos: 'verb', def: 'do, make' }, 'feci': { pos: 'verb', def: 'do, make' }, 'factum': { pos: 'verb', def: 'do, make' }, 'facere': { pos: 'verb', def: 'do, make' },
        'venio': { pos: 'verb', def: 'come' }, 'venit': { pos: 'verb', def: 'come' }, 'veni': { pos: 'verb', def: 'come' }, 'ventum': { pos: 'verb', def: 'come' }, 'venire': { pos: 'verb', def: 'come' },
        'uenio': { pos: 'verb', def: 'come' }, 'uenit': { pos: 'verb', def: 'come' }, 'ueni': { pos: 'verb', def: 'come' }, 'uentum': { pos: 'verb', def: 'come' }, 'uenire': { pos: 'verb', def: 'come' },
        'do': { pos: 'verb', def: 'give' }, 'dat': { pos: 'verb', def: 'give' }, 'dedi': { pos: 'verb', def: 'give' }, 'datum': { pos: 'verb', def: 'give' }, 'dare': { pos: 'verb', def: 'give' },
        'ago': { pos: 'verb', def: 'do, drive, act' }, 'agit': { pos: 'verb', def: 'do, drive' }, 'egi': { pos: 'verb', def: 'do, drive' }, 'actum': { pos: 'verb', def: 'do, drive' }, 'agere': { pos: 'verb', def: 'do, drive' },
        'pono': { pos: 'verb', def: 'put, place' }, 'ponit': { pos: 'verb', def: 'put, place' }, 'posui': { pos: 'verb', def: 'put, place' }, 'positum': { pos: 'verb', def: 'put, place' }, 'ponere': { pos: 'verb', def: 'put, place' },
        'capio': { pos: 'verb', def: 'take, capture' }, 'capis': { pos: 'verb', def: 'take' }, 'capit': { pos: 'verb', def: 'takes' }, 'capimus': { pos: 'verb', def: 'take' }, 'capiunt': { pos: 'verb', def: 'take' }, 'cepi': { pos: 'verb', def: 'took, captured' }, 'captum': { pos: 'verb', def: 'take, capture' }, 'capere': { pos: 'verb', def: 'take, capture' },
        'capior': { pos: 'verb', def: 'am taken, am captured' }, 'caperis': { pos: 'verb', def: 'are taken' }, 'capitur': { pos: 'verb', def: 'is taken, is captured' }, 'capimur': { pos: 'verb', def: 'are taken' }, 'capimini': { pos: 'verb', def: 'are taken' }, 'capiuntur': { pos: 'verb', def: 'are taken, are captured' },
        'habeo': { pos: 'verb', def: 'have, hold' }, 'habes': { pos: 'verb', def: 'have' }, 'habet': { pos: 'verb', def: 'has' }, 'habemus': { pos: 'verb', def: 'have' }, 'habetis': { pos: 'verb', def: 'have' }, 'habent': { pos: 'verb', def: 'have' },
        'habui': { pos: 'verb', def: 'had' }, 'habuisti': { pos: 'verb', def: 'had' }, 'habuit': { pos: 'verb', def: 'had' }, 'habuimus': { pos: 'verb', def: 'had' }, 'habuistis': { pos: 'verb', def: 'had' }, 'habuerunt': { pos: 'verb', def: 'had' },
        'habitum': { pos: 'verb', def: 'have, hold' }, 'habere': { pos: 'verb', def: 'have, hold' },
        'vivo': { pos: 'verb', def: 'live' }, 'vivit': { pos: 'verb', def: 'live' }, 'vixi': { pos: 'verb', def: 'live' }, 'victum': { pos: 'verb', def: 'live' }, 'vivere': { pos: 'verb', def: 'live' },
        'uiuo': { pos: 'verb', def: 'live' }, 'uiuit': { pos: 'verb', def: 'live' }, 'uixi': { pos: 'verb', def: 'live' }, 'uictum': { pos: 'verb', def: 'live' }, 'uiuere': { pos: 'verb', def: 'live' },
        'eo': { pos: 'verb', def: 'go' }, 'it': { pos: 'verb', def: 'go' }, 'ire': { pos: 'verb', def: 'go' }, 'iit': { pos: 'verb', def: 'go' }, 'ierunt': { pos: 'verb', def: 'go' },
        'duco': { pos: 'verb', def: 'lead' }, 'ducis': { pos: 'verb', def: 'lead' }, 'ducit': { pos: 'verb', def: 'leads' }, 'ducimus': { pos: 'verb', def: 'lead' }, 'ducunt': { pos: 'verb', def: 'lead' }, 'duxi': { pos: 'verb', def: 'led' }, 'ductum': { pos: 'verb', def: 'lead' }, 'ducere': { pos: 'verb', def: 'lead' },
        'ducor': { pos: 'verb', def: 'am led' }, 'duceris': { pos: 'verb', def: 'are led' }, 'ducitur': { pos: 'verb', def: 'is led' }, 'ducimur': { pos: 'verb', def: 'are led' }, 'ducimini': { pos: 'verb', def: 'are led' }, 'ducuntur': { pos: 'verb', def: 'are led' },
        'audio': { pos: 'verb', def: 'hear' }, 'audis': { pos: 'verb', def: 'hear' }, 'audit': { pos: 'verb', def: 'hear' }, 'audimus': { pos: 'verb', def: 'hear' }, 'auditis': { pos: 'verb', def: 'hear' }, 'audiunt': { pos: 'verb', def: 'hear' }, 'audivi': { pos: 'verb', def: 'hear' }, 'auditum': { pos: 'verb', def: 'hear' }, 'audire': { pos: 'verb', def: 'hear' },
        'scribo': { pos: 'verb', def: 'write' }, 'scribit': { pos: 'verb', def: 'write' }, 'scripsi': { pos: 'verb', def: 'write' }, 'scriptum': { pos: 'verb', def: 'write' }, 'scribere': { pos: 'verb', def: 'write' },
        'lego': { pos: 'verb', def: 'read, choose' }, 'legit': { pos: 'verb', def: 'read, choose' }, 'legi': { pos: 'verb', def: 'read, choose' }, 'lectum': { pos: 'verb', def: 'read, choose' }, 'legere': { pos: 'verb', def: 'read, choose' },
        'mitto': { pos: 'verb', def: 'send' }, 'mittis': { pos: 'verb', def: 'send' }, 'mittit': { pos: 'verb', def: 'sends' }, 'mittimus': { pos: 'verb', def: 'send' }, 'mittunt': { pos: 'verb', def: 'send' }, 'misi': { pos: 'verb', def: 'sent' }, 'missum': { pos: 'verb', def: 'send' }, 'mittere': { pos: 'verb', def: 'send' },
        'mittor': { pos: 'verb', def: 'am sent' }, 'mitteris': { pos: 'verb', def: 'are sent' }, 'mittitur': { pos: 'verb', def: 'is sent' }, 'mittimur': { pos: 'verb', def: 'are sent' }, 'mittimini': { pos: 'verb', def: 'are sent' }, 'mittuntur': { pos: 'verb', def: 'are sent' },
        'porto': { pos: 'verb', def: 'carry' }, 'portat': { pos: 'verb', def: 'carry' }, 'portavi': { pos: 'verb', def: 'carry' }, 'portatum': { pos: 'verb', def: 'carry' }, 'portare': { pos: 'verb', def: 'carry' },
        'puto': { pos: 'verb', def: 'think, suppose' }, 'putas': { pos: 'verb', def: 'think' }, 'putat': { pos: 'verb', def: 'think' }, 'putamus': { pos: 'verb', def: 'think' }, 'putatis': { pos: 'verb', def: 'think' }, 'putant': { pos: 'verb', def: 'think' }, 'putavi': { pos: 'verb', def: 'think' }, 'putatum': { pos: 'verb', def: 'think' }, 'putare': { pos: 'verb', def: 'think' },
        'vinco': { pos: 'verb', def: 'conquer, win' }, 'vincit': { pos: 'verb', def: 'conquer' }, 'vici': { pos: 'verb', def: 'conquer' }, 'victum': { pos: 'verb', def: 'conquer' }, 'vincere': { pos: 'verb', def: 'conquer' },
        'uinco': { pos: 'verb', def: 'conquer, win' }, 'uincit': { pos: 'verb', def: 'conquer' }, 'uici': { pos: 'verb', def: 'conquer' }, 'uictum': { pos: 'verb', def: 'conquer' }, 'uincere': { pos: 'verb', def: 'conquer' },
        'moveo': { pos: 'verb', def: 'move' }, 'movet': { pos: 'verb', def: 'move' }, 'movi': { pos: 'verb', def: 'move' }, 'motum': { pos: 'verb', def: 'move' }, 'movere': { pos: 'verb', def: 'move' },
        'teneo': { pos: 'verb', def: 'hold' }, 'tenet': { pos: 'verb', def: 'hold' }, 'tenui': { pos: 'verb', def: 'hold' }, 'tentum': { pos: 'verb', def: 'hold' }, 'tenere': { pos: 'verb', def: 'hold' },
        'moneo': { pos: 'verb', def: 'warn, advise' }, 'monet': { pos: 'verb', def: 'warn' }, 'monui': { pos: 'verb', def: 'warn' }, 'monitum': { pos: 'verb', def: 'warn' }, 'monere': { pos: 'verb', def: 'warn' },
        'timeo': { pos: 'verb', def: 'fear' }, 'timet': { pos: 'verb', def: 'fear' }, 'timui': { pos: 'verb', def: 'fear' }, 'timere': { pos: 'verb', def: 'fear' },
        'credo': { pos: 'verb', def: 'believe, trust' }, 'credis': { pos: 'verb', def: 'believe' }, 'credit': { pos: 'verb', def: 'believe' }, 'credimus': { pos: 'verb', def: 'believe' }, 'creditis': { pos: 'verb', def: 'believe' }, 'credunt': { pos: 'verb', def: 'believe' }, 'credidi': { pos: 'verb', def: 'believe' }, 'creditum': { pos: 'verb', def: 'believe' }, 'credere': { pos: 'verb', def: 'believe' },
        'laudo': { pos: 'verb', def: 'praise' }, 'laudat': { pos: 'verb', def: 'praise' }, 'laudavi': { pos: 'verb', def: 'praise' }, 'laudatum': { pos: 'verb', def: 'praise' },
        'specto': { pos: 'verb', def: 'watch, look at' }, 'spectat': { pos: 'verb', def: 'watch' }, 'spectavi': { pos: 'verb', def: 'watch' }, 'spectatum': { pos: 'verb', def: 'watch' },
        'paro': { pos: 'verb', def: 'prepare' }, 'parat': { pos: 'verb', def: 'prepare' }, 'paravi': { pos: 'verb', def: 'prepare' }, 'paratum': { pos: 'verb', def: 'prepare' },
        'narro': { pos: 'verb', def: 'tell, narrate' }, 'narrat': { pos: 'verb', def: 'tell' }, 'narravi': { pos: 'verb', def: 'tell' }, 'narratum': { pos: 'verb', def: 'tell' },
        'voco': { pos: 'verb', def: 'call' }, 'vocat': { pos: 'verb', def: 'call' }, 'vocavi': { pos: 'verb', def: 'call' }, 'vocatum': { pos: 'verb', def: 'call' },
        'iuvo': { pos: 'verb', def: 'help' }, 'iuvat': { pos: 'verb', def: 'help' }, 'iuvi': { pos: 'verb', def: 'help' }, 'iutum': { pos: 'verb', def: 'help' },
        'relinquo': { pos: 'verb', def: 'leave behind' }, 'relinquit': { pos: 'verb', def: 'leave behind' }, 'reliqui': { pos: 'verb', def: 'leave behind' }, 'relictum': { pos: 'verb', def: 'leave behind' },
        'disco': { pos: 'verb', def: 'learn' }, 'discit': { pos: 'verb', def: 'learn' }, 'didici': { pos: 'verb', def: 'learn' },
        'doceo': { pos: 'verb', def: 'teach' }, 'docet': { pos: 'verb', def: 'teach' }, 'docui': { pos: 'verb', def: 'teach' }, 'doctum': { pos: 'verb', def: 'teach' },
        'possum': { pos: 'verb', def: 'be able' }, 'potest': { pos: 'verb', def: 'be able' }, 'potui': { pos: 'verb', def: 'be able' }, 'posse': { pos: 'verb', def: 'be able' },
        'debeo': { pos: 'verb', def: 'ought, owe' }, 'debet': { pos: 'verb', def: 'ought' }, 'debui': { pos: 'verb', def: 'ought' }, 'debitum': { pos: 'verb', def: 'ought' },
        'iubeo': { pos: 'verb', def: 'order' }, 'iubet': { pos: 'verb', def: 'order' }, 'iussi': { pos: 'verb', def: 'order' }, 'iussum': { pos: 'verb', def: 'order' },
        'nolo': { pos: 'verb', def: 'not want' }, 'non': { pos: 'adverb', def: 'not' }, 'volo': { pos: 'verb', def: 'want, wish' }, 'vult': { pos: 'verb', def: 'want' }, 'volui': { pos: 'verb', def: 'want' }, 'velle': { pos: 'verb', def: 'want' },
        'peto': { pos: 'verb', def: 'seek, attack' }, 'petit': { pos: 'verb', def: 'seek' }, 'petivi': { pos: 'verb', def: 'seek' }, 'petitum': { pos: 'verb', def: 'seek' },
        'quaero': { pos: 'verb', def: 'seek, ask' }, 'quaerit': { pos: 'verb', def: 'seek' }, 'quaesivi': { pos: 'verb', def: 'seek' }, 'quaesitum': { pos: 'verb', def: 'seek' },
        'respondeo': { pos: 'verb', def: 'answer' }, 'respondet': { pos: 'verb', def: 'answer' }, 'respondi': { pos: 'verb', def: 'answer' }, 'responsum': { pos: 'verb', def: 'answer' },
        'rogo': { pos: 'verb', def: 'ask' }, 'rogat': { pos: 'verb', def: 'ask' }, 'rogavi': { pos: 'verb', def: 'ask' }, 'rogatum': { pos: 'verb', def: 'ask' },
        'cupio': { pos: 'verb', def: 'desire' }, 'cupit': { pos: 'verb', def: 'desire' }, 'cupivi': { pos: 'verb', def: 'desire' }, 'cupitum': { pos: 'verb', def: 'desire' },
        'curo': { pos: 'verb', def: 'care for' }, 'curat': { pos: 'verb', def: 'care for' }, 'curavi': { pos: 'verb', def: 'care for' }, 'curatum': { pos: 'verb', def: 'care for' },
        'pugno': { pos: 'verb', def: 'fight' }, 'pugnat': { pos: 'verb', def: 'fight' }, 'pugnavi': { pos: 'verb', def: 'fight' }, 'pugnatum': { pos: 'verb', def: 'fight' },
        'sto': { pos: 'verb', def: 'stand' }, 'stat': { pos: 'verb', def: 'stand' }, 'steti': { pos: 'verb', def: 'stand' }, 'statum': { pos: 'verb', def: 'stand' },
        'sedeo': { pos: 'verb', def: 'sit' }, 'sedet': { pos: 'verb', def: 'sit' }, 'sedi': { pos: 'verb', def: 'sit' }, 'sessum': { pos: 'verb', def: 'sit' },
        'curro': { pos: 'verb', def: 'run' }, 'currit': { pos: 'verb', def: 'run' }, 'cucurri': { pos: 'verb', def: 'run' }, 'cursum': { pos: 'verb', def: 'run' },
        'ambulo': { pos: 'verb', def: 'walk' }, 'ambulat': { pos: 'verb', def: 'walk' }, 'ambulavi': { pos: 'verb', def: 'walk' }, 'ambulatum': { pos: 'verb', def: 'walk' },
        'sto': { pos: 'verb', def: 'stand' }, 'supero': { pos: 'verb', def: 'overcome' }, 'impero': { pos: 'verb', def: 'command' }, 'iudico': { pos: 'verb', def: 'judge' },
        'accedo': { pos: 'verb', def: 'approach' }, 'accipio': { pos: 'verb', def: 'receive' }, 'adsum': { pos: 'verb', def: 'be present' }, 'aperio': { pos: 'verb', def: 'open' },
        'cedo': { pos: 'verb', def: 'yield' }, 'cogito': { pos: 'verb', def: 'think' }, 'cognosco': { pos: 'verb', def: 'learn, know' },
        'adduco': { pos: 'verb', def: 'lead, draw, induce' }, 'adducti': { pos: 'participle', def: 'led, induced' },
        'permoveo': { pos: 'verb', def: 'move deeply, influence' }, 'permoti': { pos: 'participle', def: 'moved, influenced' },
        'constituo': { pos: 'verb', def: 'establish, decide, determine, resolve' }, 'constituerunt': { pos: 'verb', def: 'decided, established' },
        'proficiscor': { pos: 'verb', def: 'set out, depart' }, 'proficiscendum': { pos: 'noun', case: 'acc sg', def: 'setting out, departure' },
        'pertineo': { pos: 'verb', def: 'extend, pertain' }, 'pertinerent': { pos: 'verb', def: 'might pertain' },
        'comparo': { pos: 'verb', def: 'prepare, acquire' }, 'comparare': { pos: 'verb', def: 'to prepare, acquire' },
        'coemo': { pos: 'verb', def: 'buy up' }, 'coemere': { pos: 'verb', def: 'to buy up' },
        'conficio': { pos: 'verb', def: 'make, accomplish, complete' }, 'conficiendum': { pos: 'noun', case: 'acc sg', def: 'the finishing, completing' },
        'conficiendas': { pos: 'gerundive', def: 'to be completed, for completing', case: 'acc pl fem' }, 'conficere': { pos: 'verb', def: 'to make, to accomplish' },
        'deligo': { pos: 'verb', def: 'choose, select' }, 'deligis': { pos: 'verb', def: 'choose' }, 'deligit': { pos: 'verb', def: 'chooses' }, 'deligimus': { pos: 'verb', def: 'choose' }, 'deligunt': { pos: 'verb', def: 'choose' },
        'deligi': { pos: 'verb', def: 'to be chosen' }, 'deligor': { pos: 'verb', def: 'am chosen' }, 'deligeris': { pos: 'verb', def: 'are chosen' }, 'deligitur': { pos: 'verb', def: 'is chosen' }, 'deligimur': { pos: 'verb', def: 'are chosen' }, 'deligimini': { pos: 'verb', def: 'are chosen' }, 'deliguntur': { pos: 'verb', def: 'are chosen' },
        'suppeto': { pos: 'verb', def: 'be available, suffice' }, 'suppeteret': { pos: 'verb', def: 'might be available, might suffice' },
        'confirmo': { pos: 'verb', def: 'strengthen, assure, establish' }, 'confirmare': { pos: 'verb', def: 'to strengthen, assure, establish' },
        'defendo': { pos: 'verb', def: 'defend' }, 'deleo': { pos: 'verb', def: 'destroy' }, 'discedo': { pos: 'verb', def: 'depart' }, 'fero': { pos: 'verb', def: 'bear, carry' },
        'fugio': { pos: 'verb', def: 'flee' }, 'gero': { pos: 'verb', def: 'carry on, wage' }, 'intro': { pos: 'verb', def: 'enter' }, 'iacio': { pos: 'verb', def: 'throw' },
        'invenio': { pos: 'verb', def: 'find' }, 'maneo': { pos: 'verb', def: 'remain' }, 'ostendo': { pos: 'verb', def: 'show' }, 'pervenio': { pos: 'verb', def: 'arrive' },
        'prohibeo': { pos: 'verb', def: 'prevent' }, 'promitto': { pos: 'verb', def: 'promise' }, 'redeo': { pos: 'verb', def: 'return' }, 'regno': { pos: 'verb', def: 'rule' },
        'servo': { pos: 'verb', def: 'save, protect' }, 'supero': { pos: 'verb', def: 'overcome' }, 'trado': { pos: 'verb', def: 'hand over' }, 'traho': { pos: 'verb', def: 'drag' },
        'verto': { pos: 'verb', def: 'turn' }, 'vigilo': { pos: 'verb', def: 'watch' }, 'vulnero': { pos: 'verb', def: 'wound' },
       
        // Common nouns
        'homo': { pos: 'noun', def: 'man, human' }, 'hominis': { pos: 'noun', def: 'man, human' }, 'hominem': { pos: 'noun', def: 'man, human' }, 'homines': { pos: 'noun', def: 'men, humans' },
        'vir': { pos: 'noun', def: 'man, hero' }, 'viri': { pos: 'noun', def: 'man, hero' }, 'virum': { pos: 'noun', def: 'man, hero' },
        'uir': { pos: 'noun', def: 'man, hero' }, 'uiri': { pos: 'noun', def: 'man, hero' }, 'uirum': { pos: 'noun', def: 'man, hero' },
        'femina': { pos: 'noun', def: 'woman' }, 'feminae': { pos: 'noun', def: 'woman' }, 'feminam': { pos: 'noun', def: 'woman' },
        'puella': { pos: 'noun', def: 'girl' }, 'puellae': { pos: 'noun', def: 'girl' }, 'puellam': { pos: 'noun', def: 'girl' },
        'puer': { pos: 'noun', def: 'boy' }, 'pueri': { pos: 'noun', def: 'boy' }, 'puerum': { pos: 'noun', def: 'boy' },
        'rex': { pos: 'noun', def: 'king' }, 'regis': { pos: 'noun', def: 'king' }, 'regem': { pos: 'noun', def: 'king' }, 'reges': { pos: 'noun', def: 'kings' },
        'dux': { pos: 'noun', def: 'leader' }, 'ducis': { pos: 'noun', def: 'leader' }, 'ducem': { pos: 'noun', def: 'leader' },
        'miles': { pos: 'noun', def: 'soldier' }, 'militis': { pos: 'noun', def: 'soldier' }, 'militem': { pos: 'noun', def: 'soldier' },
        'deus': { pos: 'noun', def: 'god' }, 'dei': { pos: 'noun', def: 'god' }, 'deum': { pos: 'noun', def: 'god' }, 'di': { pos: 'noun', def: 'gods' }, 'dii': { pos: 'noun', def: 'gods' },
        'dea': { pos: 'noun', def: 'goddess' }, 'deae': { pos: 'noun', def: 'goddess' }, 'deam': { pos: 'noun', def: 'goddess' },
        'amicus': { pos: 'noun', def: 'friend' }, 'amici': { pos: 'noun', def: 'friend' }, 'amicum': { pos: 'noun', def: 'friend' },
        'pater': { pos: 'noun', def: 'father' }, 'patris': { pos: 'noun', def: 'father' }, 'patrem': { pos: 'noun', def: 'father' }, 'patres': { pos: 'noun', def: 'fathers' },
        'mater': { pos: 'noun', def: 'mother' }, 'matris': { pos: 'noun', def: 'mother' }, 'matrem': { pos: 'noun', def: 'mother' }, 'matres': { pos: 'noun', def: 'mothers' },
        'filius': { pos: 'noun', def: 'son' }, 'filii': { pos: 'noun', def: 'son' }, 'filium': { pos: 'noun', def: 'son' },
        'filia': { pos: 'noun', def: 'daughter' }, 'filiae': { pos: 'noun', def: 'daughter' }, 'filiam': { pos: 'noun', def: 'daughter' },
        'frater': { pos: 'noun', def: 'brother' }, 'fratris': { pos: 'noun', def: 'brother' }, 'fratrem': { pos: 'noun', def: 'brother' },
        'soror': { pos: 'noun', def: 'sister' }, 'sororis': { pos: 'noun', def: 'sister' }, 'sororem': { pos: 'noun', def: 'sister' },
        'uxor': { pos: 'noun', def: 'wife' }, 'uxoris': { pos: 'noun', def: 'wife' }, 'uxorem': { pos: 'noun', def: 'wife' },
        'dominus': { pos: 'noun', def: 'master, lord' }, 'domini': { pos: 'noun', def: 'master' }, 'dominum': { pos: 'noun', def: 'master' },
        'domina': { pos: 'noun', def: 'mistress, lady' }, 'dominae': { pos: 'noun', def: 'mistress' }, 'dominam': { pos: 'noun', def: 'mistress' },
        'servus': { pos: 'noun', def: 'slave, servant' }, 'servi': { pos: 'noun', def: 'slave' }, 'servum': { pos: 'noun', def: 'slave' },
        'urbs': { pos: 'noun', def: 'city' }, 'urbis': { pos: 'noun', def: 'city' }, 'urbem': { pos: 'noun', def: 'city' },
        'civitas': { pos: 'noun', def: 'state, citizenship' }, 'civitatis': { pos: 'noun', def: 'state' }, 'civitatem': { pos: 'noun', def: 'state' },
        'domus': { pos: 'noun', def: 'house, home' }, 'domi': { pos: 'noun', def: 'at home' }, 'domum': { pos: 'noun', def: 'house' },
        'villa': { pos: 'noun', def: 'country house, villa' }, 'villae': { pos: 'noun', def: 'villa' }, 'villam': { pos: 'noun', def: 'villa' },
        'templum': { pos: 'noun', def: 'temple' }, 'templi': { pos: 'noun', def: 'temple' },
        'bellum': { pos: 'noun', def: 'war' }, 'belli': { pos: 'noun', def: 'war' },
        'pax': { pos: 'noun', def: 'peace' }, 'pacis': { pos: 'noun', def: 'peace' }, 'pacem': { pos: 'noun', def: 'peace' },
        'terra': { pos: 'noun', def: 'earth, land' }, 'terrae': { pos: 'noun', def: 'earth' }, 'terram': { pos: 'noun', def: 'earth' },
        'aqua': { pos: 'noun', def: 'water' }, 'aquae': { pos: 'noun', def: 'water' }, 'aquam': { pos: 'noun', def: 'water' },
        'mare': { pos: 'noun', def: 'sea' }, 'maris': { pos: 'noun', def: 'sea' },
        'navis': { pos: 'noun', def: 'ship' }, 'navis': { pos: 'noun', def: 'ship' }, 'navem': { pos: 'noun', def: 'ship' },
        'porta': { pos: 'noun', def: 'gate' }, 'portae': { pos: 'noun', def: 'gate' }, 'portam': { pos: 'noun', def: 'gate' },
        'via': { pos: 'noun', def: 'road, way' }, 'viae': { pos: 'noun', def: 'road' }, 'viam': { pos: 'noun', def: 'road' },
        'corpus': { pos: 'noun', def: 'body' }, 'corporis': { pos: 'noun', def: 'body' },
        'caput': { pos: 'noun', def: 'head' }, 'capitis': { pos: 'noun', def: 'head' },
        'manus': { pos: 'noun', def: 'hand' }, 'manum': { pos: 'noun', def: 'hand' },
        'pes': { pos: 'noun', def: 'foot' }, 'pedis': { pos: 'noun', def: 'foot' }, 'pedem': { pos: 'noun', def: 'foot' },
        'oculus': { pos: 'noun', def: 'eye' }, 'oculi': { pos: 'noun', def: 'eye' }, 'oculum': { pos: 'noun', def: 'eye' },
        'cor': { pos: 'noun', def: 'heart' }, 'cordis': { pos: 'noun', def: 'heart' },
        'animus': { pos: 'noun', def: 'mind, soul' }, 'animi': { pos: 'noun', def: 'mind' }, 'animum': { pos: 'noun', def: 'mind' },
        'anima': { pos: 'noun', def: 'soul, life' }, 'animae': { pos: 'noun', def: 'soul' }, 'animam': { pos: 'noun', def: 'soul' },
        'vita': { pos: 'noun', def: 'life' }, 'vitae': { pos: 'noun', def: 'life' }, 'vitam': { pos: 'noun', def: 'life' },
        'mors': { pos: 'noun', def: 'death' }, 'mortis': { pos: 'noun', def: 'death' }, 'mortem': { pos: 'noun', def: 'death' },
        'tempus': { pos: 'noun', def: 'time' }, 'temporis': { pos: 'noun', def: 'time' },
        'dies': { pos: 'noun', def: 'day' }, 'diei': { pos: 'noun', def: 'day' }, 'diem': { pos: 'noun', def: 'day' },
        'nox': { pos: 'noun', def: 'night' }, 'noctis': { pos: 'noun', def: 'night' }, 'noctem': { pos: 'noun', def: 'night' },
        'annus': { pos: 'noun', def: 'year' }, 'anni': { pos: 'noun', def: 'year' }, 'annum': { pos: 'noun', def: 'year' },
        'hora': { pos: 'noun', def: 'hour' }, 'horae': { pos: 'noun', def: 'hour' }, 'horam': { pos: 'noun', def: 'hour' },
        'lux': { pos: 'noun', def: 'light' }, 'lucis': { pos: 'noun', def: 'light' }, 'lucem': { pos: 'noun', def: 'light' },
        'sol': { pos: 'noun', def: 'sun' }, 'solis': { pos: 'noun', def: 'sun' }, 'solem': { pos: 'noun', def: 'sun' },
        'luna': { pos: 'noun', def: 'moon' }, 'lunae': { pos: 'noun', def: 'moon' }, 'lunam': { pos: 'noun', def: 'moon' },
        'stella': { pos: 'noun', def: 'star' }, 'stellae': { pos: 'noun', def: 'star' }, 'stellam': { pos: 'noun', def: 'star' },
        'caelum': { pos: 'noun', def: 'sky, heaven' }, 'caeli': { pos: 'noun', def: 'sky' },
        'ignis': { pos: 'noun', def: 'fire' }, 'ignem': { pos: 'noun', def: 'fire' },
        'ventus': { pos: 'noun', def: 'wind' }, 'venti': { pos: 'noun', def: 'wind' }, 'ventum': { pos: 'noun', def: 'wind' },
        'mons': { pos: 'noun', def: 'mountain' }, 'montis': { pos: 'noun', def: 'mountain' }, 'montem': { pos: 'noun', def: 'mountain' },
        'silva': { pos: 'noun', def: 'forest' }, 'silvae': { pos: 'noun', def: 'forest' }, 'silvam': { pos: 'noun', def: 'forest' },
        'flumen': { pos: 'noun', def: 'river' }, 'fluminis': { pos: 'noun', def: 'river' },
        'campus': { pos: 'noun', def: 'field, plain' }, 'campi': { pos: 'noun', def: 'field' }, 'campum': { pos: 'noun', def: 'field' },
        'arbor': { pos: 'noun', def: 'tree' }, 'arboris': { pos: 'noun', def: 'tree' }, 'arborem': { pos: 'noun', def: 'tree' },
        'flos': { pos: 'noun', def: 'flower' }, 'floris': { pos: 'noun', def: 'flower' }, 'florem': { pos: 'noun', def: 'flower' },
        'equus': { pos: 'noun', def: 'horse' }, 'equi': { pos: 'noun', def: 'horse' }, 'equum': { pos: 'noun', def: 'horse' },
        'canis': { pos: 'noun', def: 'dog' }, 'canem': { pos: 'noun', def: 'dog' },
        'animal': { pos: 'noun', def: 'animal' }, 'animalis': { pos: 'noun', def: 'animal' },
        'liber': { pos: 'noun', def: 'book' }, 'libri': { pos: 'noun', def: 'book' }, 'librum': { pos: 'noun', def: 'book' },
        'verbum': { pos: 'noun', def: 'word' }, 'verbi': { pos: 'noun', def: 'word' },
        'nomen': { pos: 'noun', def: 'name' }, 'nominis': { pos: 'noun', def: 'name' },
        'vox': { pos: 'noun', def: 'voice, word' }, 'vocis': { pos: 'noun', def: 'voice' }, 'vocem': { pos: 'noun', def: 'voice' },
        'res': { pos: 'noun', def: 'thing, matter' }, 'rei': { pos: 'noun', case: 'gen/dat sg', def: 'thing' }, 'rem': { pos: 'noun', case: 'acc sg', def: 'thing' }, 'rebus': { pos: 'noun', case: 'dat/abl pl', def: 'things' },
        'auctoritas': { pos: 'noun', def: 'authority, influence' }, 'auctoritatem': { pos: 'noun', case: 'acc sg', def: 'authority' }, 'auctoritate': { pos: 'noun', case: 'abl sg', def: 'authority' },
        'orgetorix': { pos: 'proper-noun', def: 'Orgetorix' }, 'orgetorigis': { pos: 'proper-noun', case: 'gen sg', def: 'of Orgetorix' },
        'iumentum': { pos: 'noun', def: 'pack animal, beast of burden' }, 'iumenta': { pos: 'noun', def: 'pack animals' }, 'iumentorum': { pos: 'noun', case: 'gen pl', def: 'of pack animals' },
        'carrus': { pos: 'noun', def: 'cart, wagon' }, 'carri': { pos: 'noun', def: 'cart' }, 'carrorum': { pos: 'noun', case: 'gen pl', def: 'of carts' },
        'numerus': { pos: 'noun', def: 'number' }, 'numeri': { pos: 'noun', def: 'number' }, 'numerum': { pos: 'noun', case: 'acc sg', def: 'number' },
        'semen': { pos: 'noun', def: 'seed' }, 'sementes': { pos: 'noun', case: 'acc pl', def: 'seeds' },
        'iter': { pos: 'noun', def: 'journey, route' }, 'itinere': { pos: 'noun', case: 'abl sg', def: 'on the journey' },
        'frumentum': { pos: 'noun', def: 'grain, corn' }, 'frumenti': { pos: 'noun', case: 'gen sg', def: 'of grain' },
        'civitas': { pos: 'noun', def: 'state, tribe, citizenship' }, 'civitati': { pos: 'noun', def: 'to the state' }, 'civitatibus': { pos: 'noun', case: 'dat/abl pl', def: 'to/with the states' },
        'amicitia': { pos: 'noun', def: 'friendship' }, 'amicitiam': { pos: 'noun', case: 'acc sg', def: 'friendship' },
        'causa': { pos: 'noun', def: 'cause, reason, case' }, 'causae': { pos: 'noun', def: 'cause' }, 'causam': { pos: 'noun', def: 'cause' },
        'lex': { pos: 'noun', def: 'law' }, 'legis': { pos: 'noun', def: 'law' }, 'legem': { pos: 'noun', def: 'law' },
        'ius': { pos: 'noun', def: 'right, law' }, 'iuris': { pos: 'noun', def: 'right' },
        'virtus': { pos: 'noun', def: 'courage, virtue' }, 'virtutis': { pos: 'noun', def: 'virtue' }, 'virtutem': { pos: 'noun', def: 'virtue' },
        'gloria': { pos: 'noun', def: 'glory' }, 'gloriae': { pos: 'noun', def: 'glory' }, 'gloriam': { pos: 'noun', def: 'glory' },
        'amor': { pos: 'noun', def: 'love' }, 'amoris': { pos: 'noun', def: 'love' }, 'amorem': { pos: 'noun', def: 'love' },
        'odium': { pos: 'noun', def: 'hatred' }, 'odii': { pos: 'noun', def: 'hatred' },
        'gaudium': { pos: 'noun', def: 'joy' }, 'gaudii': { pos: 'noun', def: 'joy' },
        'dolor': { pos: 'noun', def: 'pain, grief' }, 'doloris': { pos: 'noun', def: 'pain' }, 'dolorem': { pos: 'noun', def: 'pain' },
        'spes': { pos: 'noun', def: 'hope' }, 'spei': { pos: 'noun', def: 'hope' }, 'spem': { pos: 'noun', def: 'hope' },
        'timor': { pos: 'noun', def: 'fear' }, 'timoris': { pos: 'noun', def: 'fear' }, 'timorem': { pos: 'noun', def: 'fear' },
        'consul': { pos: 'noun', def: 'consul' }, 'consulis': { pos: 'noun', def: 'consul' }, 'consulem': { pos: 'noun', def: 'consul' },
        'senatus': { pos: 'noun', def: 'senate' }, 'senatus': { pos: 'noun', def: 'senate' },
        'populus': { pos: 'noun', def: 'people' }, 'populi': { pos: 'noun', def: 'people' }, 'populum': { pos: 'noun', def: 'people' },
        'plebs': { pos: 'noun', def: 'common people' }, 'plebis': { pos: 'noun', def: 'common people' }, 'plebem': { pos: 'noun', def: 'common people' },
        'gens': { pos: 'noun', def: 'nation, clan' }, 'gentis': { pos: 'noun', def: 'nation' }, 'gentem': { pos: 'noun', def: 'nation' },
        'locus': { pos: 'noun', def: 'place' }, 'loci': { pos: 'noun', def: 'place' }, 'locum': { pos: 'noun', def: 'place' },
        'numerus': { pos: 'noun', def: 'number' }, 'numeri': { pos: 'noun', def: 'number' }, 'numerum': { pos: 'noun', def: 'number' },
        'pars': { pos: 'noun', def: 'part' }, 'partis': { pos: 'noun', def: 'part' }, 'partem': { pos: 'noun', def: 'part' }, 'partes': { pos: 'noun', def: 'parts' }, 'partium': { pos: 'noun', def: 'parts' },
        'lingua': { pos: 'noun', def: 'tongue, language' }, 'linguae': { pos: 'noun', def: 'language' }, 'linguam': { pos: 'noun', def: 'language' },
        'gallia': { pos: 'noun', def: 'Gaul' }, 'galliae': { pos: 'noun', def: 'Gaul' }, 'galliam': { pos: 'noun', def: 'Gaul' },
        'belgae': { pos: 'noun', def: 'Belgians' }, 'belgarum': { pos: 'noun', def: 'Belgians' },
        'aquitani': { pos: 'noun', def: 'Aquitanians' }, 'aquitanorum': { pos: 'noun', def: 'Aquitanians' },
        'celtae': { pos: 'noun', def: 'Celts' }, 'celtarum': { pos: 'noun', def: 'Celts' },
        'galli': { pos: 'noun', def: 'Gauls' }, 'gallorum': { pos: 'noun', def: 'Gauls' }, 'gallos': { pos: 'noun', def: 'Gauls' },
        'modus': { pos: 'noun', def: 'manner, way' }, 'modi': { pos: 'noun', def: 'manner' }, 'modum': { pos: 'noun', def: 'manner' },
        'consilium': { pos: 'noun', def: 'plan, advice' }, 'consilii': { pos: 'noun', def: 'plan' },
        'imperium': { pos: 'noun', def: 'command, empire' }, 'imperii': { pos: 'noun', def: 'command' },
        'regnum': { pos: 'noun', def: 'kingdom' }, 'regni': { pos: 'noun', def: 'kingdom' },
        'arma': { pos: 'noun', def: 'arms, weapons' }, 'armorum': { pos: 'noun', def: 'arms' },
        'telum': { pos: 'noun', def: 'weapon, javelin' }, 'teli': { pos: 'noun', def: 'weapon' },
        'gladius': { pos: 'noun', def: 'sword' }, 'gladii': { pos: 'noun', def: 'sword' }, 'gladium': { pos: 'noun', def: 'sword' },
        'copia': { pos: 'noun', def: 'abundance, forces' }, 'copiae': { pos: 'noun', def: 'forces' }, 'copiam': { pos: 'noun', def: 'abundance' },
        'fortuna': { pos: 'noun', def: 'fortune, luck' }, 'fortunae': { pos: 'noun', def: 'fortune' }, 'fortunam': { pos: 'noun', def: 'fortune' },
        'fatum': { pos: 'noun', def: 'fate' }, 'fati': { pos: 'noun', def: 'fate' },
        'natura': { pos: 'noun', def: 'nature' }, 'naturae': { pos: 'noun', def: 'nature' }, 'naturam': { pos: 'noun', def: 'nature' },
        'fides': { pos: 'noun', def: 'faith, trust' }, 'fidei': { pos: 'noun', def: 'faith' }, 'fidem': { pos: 'noun', def: 'faith' },
        'veritas': { pos: 'noun', def: 'truth' }, 'veritatis': { pos: 'noun', def: 'truth' }, 'veritatem': { pos: 'noun', def: 'truth' },
       
        // Adjectives
        'bonus': { pos: 'adjective', def: 'good' }, 'bona': { pos: 'adjective', def: 'good' }, 'bonum': { pos: 'adjective', def: 'good' },
        'malus': { pos: 'adjective', def: 'bad, evil' }, 'mala': { pos: 'adjective', def: 'bad' }, 'malum': { pos: 'adjective', def: 'bad' },
        'magnus': { pos: 'adjective', def: 'great, large' }, 'magna': { pos: 'adjective', def: 'great' }, 'magnum': { pos: 'adjective', def: 'great' },
        'parvus': { pos: 'adjective', def: 'small' }, 'parva': { pos: 'adjective', def: 'small' }, 'parvum': { pos: 'adjective', def: 'small' },
        'longus': { pos: 'adjective', def: 'long' }, 'longa': { pos: 'adjective', def: 'long' }, 'longum': { pos: 'adjective', def: 'long' },
        'brevis': { pos: 'adjective', def: 'short, brief' }, 'breve': { pos: 'adjective', def: 'short' },
        'altus': { pos: 'adjective', def: 'high, deep' }, 'alta': { pos: 'adjective', def: 'high' }, 'altum': { pos: 'adjective', def: 'high' },
        'novus': { pos: 'adjective', def: 'new' }, 'nova': { pos: 'adjective', def: 'new' }, 'novum': { pos: 'adjective', def: 'new' },
        'vetus': { pos: 'adjective', def: 'old' }, 'veteris': { pos: 'adjective', def: 'old' },
        'multus': { pos: 'adjective', def: 'much, many' }, 'multa': { pos: 'adjective', def: 'much' }, 'multum': { pos: 'adjective', def: 'much' }, 'multi': { pos: 'adjective', def: 'many' },
        'paucus': { pos: 'adjective', def: 'few' }, 'pauca': { pos: 'adjective', def: 'few' }, 'paucum': { pos: 'adjective', def: 'few' }, 'pauci': { pos: 'adjective', def: 'few' },
        'totus': { pos: 'adjective', def: 'whole, all' }, 'tota': { pos: 'adjective', def: 'whole' }, 'totum': { pos: 'adjective', def: 'whole' },
        'omnis': { pos: 'adjective', def: 'all, every', case: 'nom/gen sg' }, 'omne': { pos: 'adjective', def: 'all', case: 'nom/acc sg neut' }, 'omnes': { pos: 'adjective', def: 'all', case: 'nom/acc pl' },
        'nullus': { pos: 'adjective', def: 'no, none' }, 'nulla': { pos: 'adjective', def: 'no' }, 'nullum': { pos: 'adjective', def: 'no' },
        'primus': { pos: 'adjective', def: 'first' }, 'prima': { pos: 'adjective', def: 'first' }, 'primum': { pos: 'adjective', def: 'first' },
        'ultimus': { pos: 'adjective', def: 'last, farthest' }, 'ultima': { pos: 'adjective', def: 'last' }, 'ultimum': { pos: 'adjective', def: 'last' },
        'summus': { pos: 'adjective', def: 'highest, greatest' }, 'summa': { pos: 'adjective', def: 'highest' }, 'summum': { pos: 'adjective', def: 'highest' },
        'medius': { pos: 'adjective', def: 'middle' }, 'media': { pos: 'adjective', def: 'middle' }, 'medium': { pos: 'adjective', def: 'middle' },
        'alius': { pos: 'adjective', def: 'other, another' }, 'alia': { pos: 'adjective', def: 'other' }, 'aliud': { pos: 'adjective', def: 'other' },
        'alter': { pos: 'adjective', def: 'other (of two)' }, 'altera': { pos: 'adjective', def: 'other' }, 'alterum': { pos: 'adjective', def: 'other' },
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' },
        'duo': { pos: 'adjective', def: 'two' }, 'duae': { pos: 'adjective', def: 'two' },
        'tres': { pos: 'adjective', def: 'three' }, 'tria': { pos: 'adjective', def: 'three' },
        'pulcher': { pos: 'adjective', def: 'beautiful' }, 'pulchra': { pos: 'adjective', def: 'beautiful' }, 'pulchrum': { pos: 'adjective', def: 'beautiful' },
        'fortis': { pos: 'adjective', def: 'brave, strong' }, 'forte': { pos: 'adjective', def: 'brave' },
        'felix': { pos: 'adjective', def: 'happy, fortunate' }, 'felicis': { pos: 'adjective', def: 'happy' }, 'felicem': { pos: 'adjective', def: 'happy' },
        'miser': { pos: 'adjective', def: 'wretched, unhappy' }, 'misera': { pos: 'adjective', def: 'wretched' }, 'miserum': { pos: 'adjective', def: 'wretched' },
        'laetus': { pos: 'adjective', def: 'happy, joyful' }, 'laeta': { pos: 'adjective', def: 'happy' }, 'laetum': { pos: 'adjective', def: 'happy' },
        'tristis': { pos: 'adjective', def: 'sad' }, 'triste': { pos: 'adjective', def: 'sad' },
        'clarus': { pos: 'adjective', def: 'clear, famous' }, 'clara': { pos: 'adjective', def: 'clear' }, 'clarum': { pos: 'adjective', def: 'clear' },
        'notus': { pos: 'adjective', def: 'known, famous' }, 'nota': { pos: 'adjective', def: 'known' }, 'notum': { pos: 'adjective', def: 'known' },
        'ignotus': { pos: 'adjective', def: 'unknown' }, 'ignota': { pos: 'adjective', def: 'unknown' }, 'ignotum': { pos: 'adjective', def: 'unknown' },
        'certus': { pos: 'adjective', def: 'certain, sure' }, 'certa': { pos: 'adjective', def: 'certain' }, 'certum': { pos: 'adjective', def: 'certain' },
        'verus': { pos: 'adjective', def: 'true, real' }, 'vera': { pos: 'adjective', def: 'true' }, 'verum': { pos: 'adjective', def: 'true' },
        'falsus': { pos: 'adjective', def: 'false' }, 'falsa': { pos: 'adjective', def: 'false' }, 'falsum': { pos: 'adjective', def: 'false' },
        'iustus': { pos: 'adjective', def: 'just, fair' }, 'iusta': { pos: 'adjective', def: 'just' }, 'iustum': { pos: 'adjective', def: 'just' },
        'sanctus': { pos: 'adjective', def: 'holy, sacred' }, 'sancta': { pos: 'adjective', def: 'holy' }, 'sanctum': { pos: 'adjective', def: 'holy' },
        'sacer': { pos: 'adjective', def: 'sacred' }, 'sacra': { pos: 'adjective', def: 'sacred' }, 'sacrum': { pos: 'adjective', def: 'sacred' },
        'liber': { pos: 'adjective', def: 'free' }, 'libera': { pos: 'adjective', def: 'free' }, 'liberum': { pos: 'adjective', def: 'free' },
        'gravis': { pos: 'adjective', def: 'heavy, serious' }, 'grave': { pos: 'adjective', def: 'heavy' },
        'levis': { pos: 'adjective', def: 'light, slight' }, 'leve': { pos: 'adjective', def: 'light' },
        'durus': { pos: 'adjective', def: 'hard' }, 'dura': { pos: 'adjective', def: 'hard' }, 'durum': { pos: 'adjective', def: 'hard' },
        'mollis': { pos: 'adjective', def: 'soft' }, 'molle': { pos: 'adjective', def: 'soft' },
        'celer': { pos: 'adjective', def: 'swift, quick' }, 'celeris': { pos: 'adjective', def: 'swift' }, 'celere': { pos: 'adjective', def: 'swift' },
        'tardus': { pos: 'adjective', def: 'slow' }, 'tarda': { pos: 'adjective', def: 'slow' }, 'tardum': { pos: 'adjective', def: 'slow' },
        'sapiens': { pos: 'adjective', def: 'wise' }, 'sapientis': { pos: 'adjective', def: 'wise' },
        'stultus': { pos: 'adjective', def: 'foolish' }, 'stulta': { pos: 'adjective', def: 'foolish' }, 'stultum': { pos: 'adjective', def: 'foolish' },
        'divinus': { pos: 'adjective', def: 'divine' }, 'divina': { pos: 'adjective', def: 'divine' }, 'divinum': { pos: 'adjective', def: 'divine' },
        'humanus': { pos: 'adjective', def: 'human' }, 'humana': { pos: 'adjective', def: 'human' }, 'humanum': { pos: 'adjective', def: 'human' },
        'publicus': { pos: 'adjective', def: 'public' }, 'publica': { pos: 'adjective', def: 'public' }, 'publicum': { pos: 'adjective', def: 'public' },
        'privatus': { pos: 'adjective', def: 'private' }, 'privata': { pos: 'adjective', def: 'private' }, 'privatum': { pos: 'adjective', def: 'private' },
        'proprius': { pos: 'adjective', def: 'one\'s own' }, 'propria': { pos: 'adjective', def: 'one\'s own' }, 'proprium': { pos: 'adjective', def: 'one\'s own' },
        'communis': { pos: 'adjective', def: 'common, shared' }, 'commune': { pos: 'adjective', def: 'common' },
        'perpetuus': { pos: 'adjective', def: 'continuous, perpetual' }, 'perpetua': { pos: 'adjective', def: 'continuous' }, 'perpetuum': { pos: 'adjective', def: 'continuous' },
        'aeternus': { pos: 'adjective', def: 'eternal' }, 'aeterna': { pos: 'adjective', def: 'eternal' }, 'aeternum': { pos: 'adjective', def: 'eternal' },
        'suus': { pos: 'adjective', def: 'his/her/its own' }, 'sua': { pos: 'adjective', def: 'his/her/its own' }, 'suum': { pos: 'adjective', def: 'his/her/its own' },
       
        // Pronouns and adjectives for pronouns
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' }, 'unam': { pos: 'adjective', def: 'one' }, 'unius': { pos: 'adjective', def: 'one' },
        'alius': { pos: 'adjective', def: 'another, other' }, 'alia': { pos: 'adjective', def: 'another' }, 'aliud': { pos: 'adjective', def: 'another' }, 'aliam': { pos: 'adjective', def: 'another' },
        'tertius': { pos: 'adjective', def: 'third' }, 'tertia': { pos: 'adjective', def: 'third' }, 'tertium': { pos: 'adjective', def: 'third' }, 'tertiam': { pos: 'adjective', def: 'third' },
        'noster': { pos: 'adjective', def: 'our' }, 'nostra': { pos: 'adjective', def: 'our' }, 'nostrum': { pos: 'adjective', def: 'our' }, 'nostri': { pos: 'adjective', def: 'our' },
        'vester': { pos: 'adjective', def: 'your' }, 'vestra': { pos: 'adjective', def: 'your' }, 'vestrum': { pos: 'adjective', def: 'your' },
        'ipse': { pos: 'pronoun', def: 'himself, herself, itself' }, 'ipsa': { pos: 'pronoun', def: 'herself' }, 'ipsum': { pos: 'pronoun', def: 'itself' }, 'ipsorum': { pos: 'pronoun', def: 'of themselves' }, 'ipsius': { pos: 'pronoun', def: 'of himself/herself' },
        'ego': { pos: 'pronoun', def: 'I' }, 'mei': { pos: 'pronoun', def: 'me' }, 'mihi': { pos: 'pronoun', def: 'to me' }, 'me': { pos: 'pronoun', def: 'me' },
        'tu': { pos: 'pronoun', def: 'you (sg.)' }, 'tui': { pos: 'pronoun', def: 'you' }, 'tibi': { pos: 'pronoun', def: 'to you' }, 'te': { pos: 'pronoun', def: 'you' },
        'nos': { pos: 'pronoun', def: 'we' }, 'nostri': { pos: 'pronoun', def: 'us' }, 'nobis': { pos: 'pronoun', def: 'to us, us' },
        'vos': { pos: 'pronoun', def: 'you (pl.)' }, 'vestri': { pos: 'pronoun', def: 'you' }, 'vobis': { pos: 'pronoun', def: 'to you, you' },
        'se': { pos: 'pronoun', case: 'acc/abl', def: 'himself, herself, itself, themselves' }, 'sui': { pos: 'pronoun', case: 'gen', def: 'of himself/herself' }, 'sibi': { pos: 'pronoun', case: 'dat', def: 'to himself/herself' },
        'is': { pos: 'pronoun', def: 'he, this' }, 'ea': { pos: 'pronoun', def: 'she, this' }, 'id': { pos: 'pronoun', def: 'it, this' },
        'eum': { pos: 'pronoun', def: 'him' }, 'eam': { pos: 'pronoun', def: 'her' }, 'eos': { pos: 'pronoun', def: 'them (m.)' }, 'eas': { pos: 'pronoun', def: 'them (f.)' },
        'hic': { pos: 'pronoun', def: 'this' }, 'haec': { pos: 'pronoun', def: 'this' }, 'hoc': { pos: 'pronoun', def: 'this' }, 'his': { pos: 'pronoun', case: 'dat/abl pl', number: 'plural', def: 'these' },
        'ille': { pos: 'pronoun', def: 'that' }, 'illa': { pos: 'pronoun', def: 'that' }, 'illud': { pos: 'pronoun', def: 'that' },
        'iste': { pos: 'pronoun', def: 'that (of yours)' }, 'ista': { pos: 'pronoun', def: 'that' }, 'istud': { pos: 'pronoun', def: 'that' },
        'ipse': { pos: 'pronoun', def: 'himself, herself, itself' }, 'ipsa': { pos: 'pronoun', def: 'herself' }, 'ipsum': { pos: 'pronoun', def: 'itself' },
        'qui': { pos: 'pronoun', def: 'who, which' }, 'quae': { pos: 'pronoun', def: 'who, which' }, 'quod': { pos: 'pronoun', def: 'which, that' }, 'quarum': { pos: 'pronoun', def: 'of whom/which' }, 'quorum': { pos: 'pronoun', def: 'of whom/which' }, 'quos': { pos: 'pronoun', def: 'whom/which' }, 'quas': { pos: 'pronoun', def: 'whom/which' },
        'quem': { pos: 'pronoun', def: 'whom' }, 'quam': { pos: 'pronoun', def: 'whom, which' }, 'quo': { pos: 'pronoun', def: 'by whom/which' },
        'quos': { pos: 'pronoun', def: 'whom (pl.)' }, 'quas': { pos: 'pronoun', def: 'whom (pl.)' },
        'cui': { pos: 'pronoun', def: 'to whom' }, 'cuius': { pos: 'pronoun', def: 'whose' }, 'quorum': { pos: 'pronoun', def: 'whose (pl.)' }, 'quarum': { pos: 'pronoun', def: 'whose (pl.)' },
        'quibus': { pos: 'pronoun', def: 'to/by whom (pl.)' },
        'quis': { pos: 'pronoun', def: 'who?, what?' }, 'quid': { pos: 'pronoun', def: 'what?' },
        'aliquis': { pos: 'pronoun', def: 'someone, something' }, 'aliquid': { pos: 'pronoun', def: 'something' },
        'nemo': { pos: 'pronoun', def: 'no one' }, 'nihil': { pos: 'pronoun', def: 'nothing' },
       
        // Prepositions & Conjunctions
        'in': { pos: 'preposition', def: 'in, into, on' },
        'ad': { pos: 'preposition', def: 'to, toward, at' },
        'ex': { pos: 'preposition', def: 'out of, from' }, 'e': { pos: 'preposition', def: 'out of, from' },
        'de': { pos: 'preposition', def: 'from, down from, about, concerning' },
        'cum': { pos: 'preposition', def: 'with' },
        'sine': { pos: 'preposition', def: 'without' },
        'pro': { pos: 'preposition', def: 'for, on behalf of, in front of' },
        'per': { pos: 'preposition', def: 'through, by means of' },
        'inter': { pos: 'preposition', def: 'between, among' },
        'propter': { pos: 'preposition', def: 'on account of, because of' },
        'post': { pos: 'preposition', def: 'after, behind' },
        'ante': { pos: 'preposition', def: 'before, in front of' },
        'sub': { pos: 'preposition', def: 'under, beneath' },
        'super': { pos: 'preposition', def: 'over, above' },
        'trans': { pos: 'preposition', def: 'across' },
        'circum': { pos: 'preposition', def: 'around' },
        'contra': { pos: 'preposition', def: 'against' },
        'apud': { pos: 'preposition', def: 'at, near, among' },
        'ab': { pos: 'preposition', def: 'from, by' }, 'a': { pos: 'preposition', def: 'from, by' },
        'et': { pos: 'conjunction', def: 'and' },
        'sed': { pos: 'conjunction', def: 'but' },
        'aut': { pos: 'conjunction', def: 'or' },
        'vel': { pos: 'conjunction', def: 'or' },
        'ac': { pos: 'conjunction', def: 'and' },
        'atque': { pos: 'conjunction', def: 'and' },
        'neque': { pos: 'conjunction', def: 'and not, nor' }, 'nec': { pos: 'conjunction', def: 'and not, nor' },
        'enim': { pos: 'conjunction', def: 'for' },
        'autem': { pos: 'conjunction', def: 'but, however' },
        'igitur': { pos: 'conjunction', def: 'therefore' },
        'ergo': { pos: 'conjunction', def: 'therefore' },
        'itaque': { pos: 'conjunction', def: 'and so, therefore' },
        'quoque': { pos: 'adverb', def: 'also, too' },
        'nam': { pos: 'conjunction', def: 'for' },
        'tamen': { pos: 'conjunction', def: 'however, nevertheless' },
        'si': { pos: 'conjunction', def: 'if' },
        'nisi': { pos: 'conjunction', def: 'if not, unless' },
        'ut': { pos: 'conjunction', def: 'as, when, that, so that' },
        'ne': { pos: 'conjunction', def: 'that not, lest' },
        'cum': { pos: 'conjunction', def: 'when, since, although' },
        'dum': { pos: 'conjunction', def: 'while, until' },
        'quod': { pos: 'conjunction', def: 'because, that' },
        'quia': { pos: 'conjunction', def: 'because' },
        'quoniam': { pos: 'conjunction', def: 'since, because' },
        'quando': { pos: 'conjunction', def: 'when' },
        'ubi': { pos: 'adverb', def: 'where, when' },
       
        // Adverbs
        'semper': { pos: 'adverb', def: 'always' },
        'numquam': { pos: 'adverb', def: 'never' },
        'saepe': { pos: 'adverb', def: 'often' },
        'iam': { pos: 'adverb', def: 'now, already' },
        'nunc': { pos: 'adverb', def: 'now' },
        'tunc': { pos: 'adverb', def: 'then' },
        'tum': { pos: 'adverb', def: 'then' },
        'hodie': { pos: 'adverb', def: 'today' },
        'heri': { pos: 'adverb', def: 'yesterday' },
        'cras': { pos: 'adverb', def: 'tomorrow' },
        'mox': { pos: 'adverb', def: 'soon' },
        'statim': { pos: 'adverb', def: 'immediately' },
        'diu': { pos: 'adverb', def: 'for a long time' },
        'bene': { pos: 'adverb', def: 'well' },
        'male': { pos: 'adverb', def: 'badly' },
        'valde': { pos: 'adverb', def: 'very, greatly' },
        'nimis': { pos: 'adverb', def: 'too much' },
        'satis': { pos: 'adverb', def: 'enough' },
        'parum': { pos: 'adverb', def: 'too little' },
        'ita': { pos: 'adverb', def: 'thus, so' },
        'sic': { pos: 'adverb', def: 'thus, so' },
        'tam': { pos: 'adverb', def: 'so' },
        'quam': { pos: 'adverb', def: 'than, as' },
        'magis': { pos: 'adverb', def: 'more' },
        'maxime': { pos: 'adverb', def: 'most, especially' },
        'minus': { pos: 'adverb', def: 'less' },
        'minime': { pos: 'adverb', def: 'least, not at all' },
        'etiam': { pos: 'adverb', def: 'also, even' },
        'quoque': { pos: 'adverb', def: 'also' },
        'tantum': { pos: 'adverb', def: 'only' },
        'solum': { pos: 'adverb', def: 'only' },
        'modo': { pos: 'adverb', def: 'only, just' },
        'quidem': { pos: 'adverb', def: 'indeed' },
        'certe': { pos: 'adverb', def: 'certainly' },
        'vero': { pos: 'adverb', def: 'truly, indeed' },
        'forte': { pos: 'adverb', def: 'by chance' },
        'forsitan': { pos: 'adverb', def: 'perhaps' },
        'fortasse': { pos: 'adverb', def: 'perhaps' },
        'hic': { pos: 'adverb', def: 'here' },
        'ibi': { pos: 'adverb', def: 'there' },
        'illic': { pos: 'adverb', def: 'there' },
        'hinc': { pos: 'adverb', def: 'from here' },
        'inde': { pos: 'adverb', def: 'from there' },
        'unde': { pos: 'adverb', def: 'from where' },
        'quo': { pos: 'adverb', def: 'to where' },
        'cur': { pos: 'adverb', def: 'why' },
        'quare': { pos: 'adverb', def: 'why, wherefore' },
        'quomodo': { pos: 'adverb', def: 'how' },
       
        // === AENEID-SPECIFIC VOCABULARY ===
        // Epic nouns - arma/bellum/war vocabulary
        'arma': { pos: 'noun', def: 'arms, weapons' }, 'armis': { pos: 'noun', def: 'arms, weapons' }, 'armorum': { pos: 'noun', def: 'arms, weapons' },
        'bellum': { pos: 'noun', def: 'war' }, 'belli': { pos: 'noun', def: 'war' }, 'bello': { pos: 'noun', def: 'war' }, 'bella': { pos: 'noun', def: 'wars' }, 'bellis': { pos: 'noun', def: 'wars' },
        'proelium': { pos: 'noun', def: 'battle' }, 'proelia': { pos: 'noun', def: 'battles' }, 'proelio': { pos: 'noun', def: 'battle' },
        'pugna': { pos: 'noun', def: 'fight, battle' }, 'pugnae': { pos: 'noun', def: 'fight, battle' }, 'pugnam': { pos: 'noun', def: 'fight, battle' },
        'gladius': { pos: 'noun', def: 'sword' }, 'gladii': { pos: 'noun', def: 'sword' }, 'gladio': { pos: 'noun', def: 'sword' }, 'gladium': { pos: 'noun', def: 'sword' },
        'telum': { pos: 'noun', def: 'weapon, missile' }, 'tela': { pos: 'noun', def: 'weapons' }, 'telis': { pos: 'noun', def: 'weapons' },
        'hasta': { pos: 'noun', def: 'spear' }, 'hastae': { pos: 'noun', def: 'spear' }, 'hastam': { pos: 'noun', def: 'spear' },
        'sagitta': { pos: 'noun', def: 'arrow' }, 'sagittae': { pos: 'noun', def: 'arrow' }, 'sagittam': { pos: 'noun', def: 'arrow' },
       
        // Important Aeneid characters and places
        'troianus': { pos: 'adjective', def: 'Trojan' }, 'troiana': { pos: 'adjective', def: 'Trojan' }, 'troianum': { pos: 'adjective', def: 'Trojan' },
        'troia': { pos: 'noun', def: 'Troy' }, 'troiae': { pos: 'noun', def: 'Troy' }, 'troiam': { pos: 'noun', def: 'Troy' },
        'ilium': { pos: 'noun', def: 'Ilium, Troy' }, 'ilii': { pos: 'noun', def: 'Ilium, Troy' }, 'ilio': { pos: 'noun', def: 'Ilium, Troy' },
        'aeneas': { pos: 'noun', def: 'Aeneas' }, 'aeneae': { pos: 'noun', def: 'Aeneas' }, 'aenean': { pos: 'noun', def: 'Aeneas' },
        'italia': { pos: 'noun', def: 'Italy' }, 'italiae': { pos: 'noun', def: 'Italy' }, 'italiam': { pos: 'noun', def: 'Italy' },
        'latium': { pos: 'noun', def: 'Latium' }, 'latii': { pos: 'noun', def: 'Latium' }, 'latio': { pos: 'noun', def: 'Latium' },
        'roma': { pos: 'noun', def: 'Rome' }, 'romae': { pos: 'noun', def: 'Rome' }, 'romam': { pos: 'noun', def: 'Rome' },
        'carthago': { pos: 'noun', def: 'Carthage' }, 'carthaginis': { pos: 'noun', def: 'Carthage' }, 'carthagine': { pos: 'noun', def: 'Carthage' },
       
        // Epic verbs - commonly used in Aeneid
        'cano': { pos: 'verb', def: 'sing' }, 'canis': { pos: 'verb', def: 'sing' }, 'canit': { pos: 'verb', def: 'sing' }, 'canimus': { pos: 'verb', def: 'sing' }, 'canunt': { pos: 'verb', def: 'sing' }, 'cecini': { pos: 'verb', def: 'sang' }, 'canere': { pos: 'verb', def: 'sing' },
        'fero': { pos: 'verb', def: 'carry, bear' }, 'fers': { pos: 'verb', def: 'carry' }, 'fert': { pos: 'verb', def: 'carry' }, 'ferimus': { pos: 'verb', def: 'carry' }, 'ferunt': { pos: 'verb', def: 'carry' }, 'tuli': { pos: 'verb', def: 'carried' }, 'latum': { pos: 'verb', def: 'carried' }, 'ferre': { pos: 'verb', def: 'carry' },
        'fugio': { pos: 'verb', def: 'flee' }, 'fugis': { pos: 'verb', def: 'flee' }, 'fugit': { pos: 'verb', def: 'flee' }, 'fugimus': { pos: 'verb', def: 'flee' }, 'fugiunt': { pos: 'verb', def: 'flee' }, 'fugi': { pos: 'verb', def: 'fled' }, 'fugere': { pos: 'verb', def: 'flee' },
        'cado': { pos: 'verb', def: 'fall' }, 'cadis': { pos: 'verb', def: 'fall' }, 'cadit': { pos: 'verb', def: 'fall' }, 'cadunt': { pos: 'verb', def: 'fall' }, 'cecidi': { pos: 'verb', def: 'fell' }, 'casum': { pos: 'verb', def: 'fallen' }, 'cadere': { pos: 'verb', def: 'fall' },
        'peto': { pos: 'verb', def: 'seek, attack' }, 'petis': { pos: 'verb', def: 'seek' }, 'petunt': { pos: 'verb', def: 'seek' }, 'petere': { pos: 'verb', def: 'seek' },
        'vinco': { pos: 'verb', def: 'conquer' }, 'vincis': { pos: 'verb', def: 'conquer' }, 'vincere': { pos: 'verb', def: 'conquer' },
        'appello': { pos: 'verb', def: 'call, name' }, 'appellat': { pos: 'verb', def: 'call' }, 'appellantur': { pos: 'verb', def: 'are called' }, 'appellare': { pos: 'verb', def: 'call' },
        'incolo': { pos: 'verb', def: 'inhabit, dwell' }, 'incolunt': { pos: 'verb', def: 'inhabit' }, 'incolere': { pos: 'verb', def: 'inhabit' },
        'divido': { pos: 'verb', def: 'divide' }, 'diuido': { pos: 'verb', def: 'divide' }, 'dividit': { pos: 'verb', def: 'divide' }, 'diuidit': { pos: 'verb', def: 'divide' },
        'divisa': { pos: 'participle', def: 'divided, having been divided' }, 'diuisa': { pos: 'participle', def: 'divided, having been divided' },
        'divisus': { pos: 'participle', def: 'divided, having been divided' }, 'diuisus': { pos: 'participle', def: 'divided, having been divided' },
        'divisum': { pos: 'participle', def: 'divided' }, 'diuisum': { pos: 'participle', def: 'divided' },
        'divisi': { pos: 'participle', def: 'divided' }, 'diuisi': { pos: 'participle', def: 'divided' },
        'dividere': { pos: 'verb', def: 'divide' }, 'diuidere': { pos: 'verb', def: 'divide' },
        'occido': { pos: 'verb', def: 'kill' }, 'occidis': { pos: 'verb', def: 'kill' }, 'occidit': { pos: 'verb', def: 'kill' }, 'occidunt': { pos: 'verb', def: 'kill' }, 'occidere': { pos: 'verb', def: 'kill' },
        'condo': { pos: 'verb', def: 'found, establish' }, 'condis': { pos: 'verb', def: 'found' }, 'condit': { pos: 'verb', def: 'found' }, 'condunt': { pos: 'verb', def: 'found' }, 'condidi': { pos: 'verb', def: 'founded' }, 'conditum': { pos: 'verb', def: 'founded' }, 'condere': { pos: 'verb', def: 'found' },
        'pello': { pos: 'verb', def: 'drive, push' }, 'pellis': { pos: 'verb', def: 'drive' }, 'pellit': { pos: 'verb', def: 'drive' }, 'pellere': { pos: 'verb', def: 'drive' },
        'sequor': { pos: 'verb', def: 'follow' }, 'sequitur': { pos: 'verb', def: 'follow' }, 'sequuntur': { pos: 'verb', def: 'follow' }, 'secutus': { pos: 'verb', def: 'followed' }, 'sequi': { pos: 'verb', def: 'follow' },
        'patior': { pos: 'verb', def: 'suffer, endure' }, 'patitur': { pos: 'verb', def: 'suffer' }, 'patiuntur': { pos: 'verb', def: 'suffer' }, 'passus': { pos: 'verb', def: 'suffered' }, 'pati': { pos: 'verb', def: 'suffer' },
        'relinquo': { pos: 'verb', def: 'leave behind' }, 'relinquis': { pos: 'verb', def: 'leave' }, 'relinquere': { pos: 'verb', def: 'leave' },
        'iacio': { pos: 'verb', def: 'throw' }, 'iacis': { pos: 'verb', def: 'throw' }, 'iacit': { pos: 'verb', def: 'throw' }, 'iaciunt': { pos: 'verb', def: 'throw' }, 'ieci': { pos: 'verb', def: 'threw' }, 'iactum': { pos: 'verb', def: 'thrown' }, 'iacere': { pos: 'verb', def: 'throw' },
        'tango': { pos: 'verb', def: 'touch' }, 'tangis': { pos: 'verb', def: 'touch' }, 'tangit': { pos: 'verb', def: 'touch' }, 'tangere': { pos: 'verb', def: 'touch' },
        'tendo': { pos: 'verb', def: 'stretch, strive' }, 'tendis': { pos: 'verb', def: 'stretch' }, 'tendit': { pos: 'verb', def: 'stretch' }, 'tendunt': { pos: 'verb', def: 'stretch' }, 'tendere': { pos: 'verb', def: 'stretch' },
        'claudo': { pos: 'verb', def: 'close, shut' }, 'claudis': { pos: 'verb', def: 'close' }, 'claudit': { pos: 'verb', def: 'close' }, 'clausit': { pos: 'verb', def: 'closed' }, 'claudere': { pos: 'verb', def: 'close' },
        'iuvo': { pos: 'verb', def: 'help' }, 'iuvas': { pos: 'verb', def: 'help' }, 'iuvare': { pos: 'verb', def: 'help' },
        'rego': { pos: 'verb', def: 'rule, guide' }, 'regis': { pos: 'verb', def: 'rule' }, 'regit': { pos: 'verb', def: 'rule' }, 'regunt': { pos: 'verb', def: 'rule' }, 'rexi': { pos: 'verb', def: 'ruled' }, 'rectum': { pos: 'verb', def: 'ruled' }, 'regere': { pos: 'verb', def: 'rule' },
        'paro': { pos: 'verb', def: 'prepare' }, 'paras': { pos: 'verb', def: 'prepare' }, 'parare': { pos: 'verb', def: 'prepare' },
       
        // Epic nouns - people, gods, fate
        'fatum': { pos: 'noun', def: 'fate' }, 'fati': { pos: 'noun', def: 'fate' }, 'fato': { pos: 'noun', def: 'fate' }, 'fata': { pos: 'noun', def: 'fates' }, 'fatis': { pos: 'noun', def: 'fates' },
        'fortuna': { pos: 'noun', def: 'fortune, luck' }, 'fortunae': { pos: 'noun', def: 'fortune' }, 'fortunam': { pos: 'noun', def: 'fortune' },
        'deus': { pos: 'noun', def: 'god' }, 'dei': { pos: 'noun', def: 'god' }, 'deo': { pos: 'noun', def: 'god' }, 'deum': { pos: 'noun', def: 'god' }, 'di': { pos: 'noun', def: 'gods' }, 'dis': { pos: 'noun', def: 'gods' }, 'deos': { pos: 'noun', def: 'gods' }, 'deorum': { pos: 'noun', def: 'gods' },
        'dea': { pos: 'noun', def: 'goddess' }, 'deae': { pos: 'noun', def: 'goddess' }, 'deam': { pos: 'noun', def: 'goddess' },
        'divus': { pos: 'adjective', def: 'divine' }, 'diva': { pos: 'adjective', def: 'divine' }, 'divum': { pos: 'adjective', def: 'divine' },
        'numen': { pos: 'noun', def: 'divine will, deity' }, 'numinis': { pos: 'noun', def: 'divine will' }, 'numine': { pos: 'noun', def: 'divine will' }, 'numina': { pos: 'noun', def: 'divine wills' },
        'rex': { pos: 'noun', def: 'king' }, 'regis': { pos: 'noun', def: 'king' }, 'regi': { pos: 'noun', def: 'king' }, 'regem': { pos: 'noun', def: 'king' }, 'rege': { pos: 'noun', def: 'king' }, 'reges': { pos: 'noun', def: 'kings' }, 'regum': { pos: 'noun', def: 'kings' },
        'regina': { pos: 'noun', def: 'queen' }, 'reginae': { pos: 'noun', def: 'queen' }, 'reginam': { pos: 'noun', def: 'queen' },
        'dux': { pos: 'noun', def: 'leader' }, 'ducis': { pos: 'noun', def: 'leader' }, 'duci': { pos: 'noun', def: 'leader' }, 'ducem': { pos: 'noun', def: 'leader' }, 'duce': { pos: 'noun', def: 'leader' }, 'duces': { pos: 'noun', def: 'leaders' },
        'heros': { pos: 'noun', def: 'hero' }, 'herois': { pos: 'noun', def: 'hero' }, 'heroa': { pos: 'noun', def: 'hero' }, 'heroas': { pos: 'noun', def: 'heroes' },
        'orator': { pos: 'noun', def: 'orator, speaker' }, 'oratoris': { pos: 'noun', def: 'orator' }, 'oratori': { pos: 'noun', def: 'orator' }, 'oratorem': { pos: 'noun', def: 'orator' }, 'oratore': { pos: 'noun', def: 'orator' }, 'oratores': { pos: 'noun', def: 'orators' },
        'senator': { pos: 'noun', def: 'senator' }, 'senatoris': { pos: 'noun', def: 'senator' }, 'senatori': { pos: 'noun', def: 'senator' }, 'senatorem': { pos: 'noun', def: 'senator' }, 'senatore': { pos: 'noun', def: 'senator' },
        'imperator': { pos: 'noun', def: 'general, commander' }, 'imperatoris': { pos: 'noun', def: 'general' }, 'imperatori': { pos: 'noun', def: 'general' }, 'imperatorem': { pos: 'noun', def: 'general' }, 'imperatore': { pos: 'noun', def: 'general' },
        'consul': { pos: 'noun', def: 'consul' }, 'consulis': { pos: 'noun', def: 'consul' }, 'consuli': { pos: 'noun', def: 'consul' }, 'consulem': { pos: 'noun', def: 'consul' }, 'consule': { pos: 'noun', def: 'consul' },
        'civis': { pos: 'noun', def: 'citizen' }, 'civis': { pos: 'noun', def: 'citizen' }, 'civi': { pos: 'noun', def: 'citizen' }, 'civem': { pos: 'noun', def: 'citizen' }, 'cive': { pos: 'noun', def: 'citizen' }, 'cives': { pos: 'noun', def: 'citizens' },
        'miles': { pos: 'noun', def: 'soldier' }, 'militis': { pos: 'noun', def: 'soldier' }, 'militi': { pos: 'noun', def: 'soldier' }, 'militem': { pos: 'noun', def: 'soldier' }, 'milite': { pos: 'noun', def: 'soldier' }, 'milites': { pos: 'noun', def: 'soldiers' },
        'poeta': { pos: 'noun', def: 'poet' }, 'poetae': { pos: 'noun', def: 'poet' }, 'poetam': { pos: 'noun', def: 'poet' }, 'poetis': { pos: 'noun', def: 'poets' },
        'philosophus': { pos: 'noun', def: 'philosopher' }, 'philosophi': { pos: 'noun', def: 'philosopher' }, 'philosopho': { pos: 'noun', def: 'philosopher' }, 'philosophum': { pos: 'noun', def: 'philosopher' },
        'vir': { pos: 'noun', def: 'man' }, 'viri': { pos: 'noun', def: 'man' }, 'viro': { pos: 'noun', def: 'man' }, 'virum': { pos: 'noun', def: 'man' }, 'virorum': { pos: 'noun', def: 'men' }, 'viros': { pos: 'noun', def: 'men' }, 'viris': { pos: 'noun', def: 'men' },
        'femina': { pos: 'noun', def: 'woman' }, 'feminae': { pos: 'noun', def: 'woman' }, 'feminam': { pos: 'noun', def: 'woman' },
        'gens': { pos: 'noun', def: 'race, nation' }, 'gentis': { pos: 'noun', def: 'race' }, 'genti': { pos: 'noun', def: 'race' }, 'gentem': { pos: 'noun', def: 'race' }, 'gente': { pos: 'noun', def: 'race' }, 'gentes': { pos: 'noun', def: 'races' }, 'gentium': { pos: 'noun', def: 'races' },
        'populus': { pos: 'noun', def: 'people' }, 'populi': { pos: 'noun', def: 'people' }, 'populo': { pos: 'noun', def: 'people' }, 'populum': { pos: 'noun', def: 'people' },
       
        // Epic nouns - places, nature
        'caelum': { pos: 'noun', def: 'sky, heaven' }, 'caeli': { pos: 'noun', def: 'sky' }, 'caelo': { pos: 'noun', def: 'sky' }, 'caelorum': { pos: 'noun', def: 'skies' },
        'terra': { pos: 'noun', def: 'earth, land' }, 'terrae': { pos: 'noun', def: 'earth' }, 'terram': { pos: 'noun', def: 'earth' }, 'terris': { pos: 'noun', def: 'lands' },
        'mare': { pos: 'noun', def: 'sea' }, 'maris': { pos: 'noun', def: 'sea' }, 'mari': { pos: 'noun', def: 'sea' }, 'maria': { pos: 'noun', def: 'seas' },
        'pontus': { pos: 'noun', def: 'sea' }, 'ponti': { pos: 'noun', def: 'sea' }, 'ponto': { pos: 'noun', def: 'sea' },
        'fluctus': { pos: 'noun', def: 'wave' }, 'fluctuum': { pos: 'noun', def: 'waves' }, 'fluctibus': { pos: 'noun', def: 'waves' },
        'unda': { pos: 'noun', def: 'wave, water' }, 'undae': { pos: 'noun', def: 'wave' }, 'undam': { pos: 'noun', def: 'wave' }, 'undis': { pos: 'noun', def: 'waves' },
        'litus': { pos: 'noun', def: 'shore' }, 'litoris': { pos: 'noun', def: 'shore' }, 'litore': { pos: 'noun', def: 'shore' }, 'litora': { pos: 'noun', def: 'shores' },
        'navis': { pos: 'noun', def: 'ship' }, 'navis': { pos: 'noun', def: 'ship' }, 'navi': { pos: 'noun', def: 'ship' }, 'navem': { pos: 'noun', def: 'ship' }, 'nave': { pos: 'noun', def: 'ship' }, 'naves': { pos: 'noun', def: 'ships' }, 'navium': { pos: 'noun', def: 'ships' }, 'navibus': { pos: 'noun', def: 'ships' },
        'classis': { pos: 'noun', def: 'fleet' }, 'classis': { pos: 'noun', def: 'fleet' }, 'classi': { pos: 'noun', def: 'fleet' }, 'classem': { pos: 'noun', def: 'fleet' }, 'classe': { pos: 'noun', def: 'fleet' },
        'urbs': { pos: 'noun', def: 'city' }, 'urbis': { pos: 'noun', def: 'city' }, 'urbi': { pos: 'noun', def: 'city' }, 'urbem': { pos: 'noun', def: 'city' }, 'urbe': { pos: 'noun', def: 'city' }, 'urbes': { pos: 'noun', def: 'cities' }, 'urbium': { pos: 'noun', def: 'cities' },
        'moenia': { pos: 'noun', def: 'walls, fortifications' }, 'moenibus': { pos: 'noun', def: 'walls' },
        'porta': { pos: 'noun', def: 'gate' }, 'portae': { pos: 'noun', def: 'gate' }, 'portam': { pos: 'noun', def: 'gate' }, 'portis': { pos: 'noun', def: 'gates' },
        'domus': { pos: 'noun', def: 'house, home' }, 'domui': { pos: 'noun', def: 'house' }, 'domum': { pos: 'noun', def: 'house' }, 'domo': { pos: 'noun', def: 'house' }, 'domibus': { pos: 'noun', def: 'houses' },
        'regia': { pos: 'noun', def: 'palace' }, 'regiae': { pos: 'noun', def: 'palace' }, 'regiam': { pos: 'noun', def: 'palace' },
        'templum': { pos: 'noun', def: 'temple' }, 'templi': { pos: 'noun', def: 'temple' }, 'templo': { pos: 'noun', def: 'temple' }, 'templa': { pos: 'noun', def: 'temples' },
        'ara': { pos: 'noun', def: 'altar' }, 'arae': { pos: 'noun', def: 'altar' }, 'aram': { pos: 'noun', def: 'altar' }, 'aris': { pos: 'noun', def: 'altars' },
        'silva': { pos: 'noun', def: 'forest' }, 'silvae': { pos: 'noun', def: 'forest' }, 'silvam': { pos: 'noun', def: 'forest' }, 'silvis': { pos: 'noun', def: 'forests' },
        'mons': { pos: 'noun', def: 'mountain' }, 'montis': { pos: 'noun', def: 'mountain' }, 'monti': { pos: 'noun', def: 'mountain' }, 'montem': { pos: 'noun', def: 'mountain' }, 'monte': { pos: 'noun', def: 'mountain' }, 'montes': { pos: 'noun', def: 'mountains' }, 'montium': { pos: 'noun', def: 'mountains' },
        'campus': { pos: 'noun', def: 'plain, field' }, 'campi': { pos: 'noun', def: 'field' }, 'campo': { pos: 'noun', def: 'field' }, 'campos': { pos: 'noun', def: 'fields' },
       
        // Epic adjectives
        'magnus': { pos: 'adjective', def: 'great, large' }, 'magna': { pos: 'adjective', def: 'great' }, 'magnum': { pos: 'adjective', def: 'great' }, 'magni': { pos: 'adjective', def: 'great' }, 'magno': { pos: 'adjective', def: 'great' },
        'parvus': { pos: 'adjective', def: 'small' }, 'parva': { pos: 'adjective', def: 'small' }, 'parvum': { pos: 'adjective', def: 'small' },
        'longus': { pos: 'adjective', def: 'long' }, 'longa': { pos: 'adjective', def: 'long' }, 'longum': { pos: 'adjective', def: 'long' },
        'altus': { pos: 'adjective', def: 'high, deep' }, 'alta': { pos: 'adjective', def: 'high, deep' }, 'altum': { pos: 'adjective', def: 'high, deep' }, 'altis': { pos: 'adjective', def: 'high, deep' },
        'clarus': { pos: 'adjective', def: 'clear, famous' }, 'clara': { pos: 'adjective', def: 'clear, famous' }, 'clarum': { pos: 'adjective', def: 'clear, famous' },
        'fortis': { pos: 'adjective', def: 'brave, strong' }, 'forte': { pos: 'adjective', def: 'brave, strong' }, 'fortes': { pos: 'adjective', def: 'brave, strong' }, 'fortium': { pos: 'adjective', def: 'brave, strong' },
        'felix': { pos: 'adjective', def: 'happy, fortunate' }, 'felicis': { pos: 'adjective', def: 'happy' }, 'felicem': { pos: 'adjective', def: 'happy' },
        'infelix': { pos: 'adjective', def: 'unhappy, unfortunate' }, 'infelicis': { pos: 'adjective', def: 'unhappy' }, 'infelicem': { pos: 'adjective', def: 'unhappy' },
        'sacer': { pos: 'adjective', def: 'sacred' }, 'sacra': { pos: 'adjective', def: 'sacred' }, 'sacrum': { pos: 'adjective', def: 'sacred' }, 'sacri': { pos: 'adjective', def: 'sacred' },
        'sanctus': { pos: 'adjective', def: 'holy, sacred' }, 'sancta': { pos: 'adjective', def: 'holy' }, 'sanctum': { pos: 'adjective', def: 'holy' },
        'pius': { pos: 'adjective', def: 'pious, dutiful' }, 'pia': { pos: 'adjective', def: 'pious' }, 'pium': { pos: 'adjective', def: 'pious' },
        'impius': { pos: 'adjective', def: 'impious' }, 'impia': { pos: 'adjective', def: 'impious' }, 'impium': { pos: 'adjective', def: 'impious' },
        'acer': { pos: 'adjective', def: 'sharp, fierce' }, 'acris': { pos: 'adjective', def: 'sharp, fierce' }, 'acre': { pos: 'adjective', def: 'sharp, fierce' },
        'saevus': { pos: 'adjective', def: 'savage, cruel' }, 'saeva': { pos: 'adjective', def: 'savage' }, 'saevum': { pos: 'adjective', def: 'savage' },
        'dirus': { pos: 'adjective', def: 'dreadful, ominous' }, 'dira': { pos: 'adjective', def: 'dreadful' }, 'dirum': { pos: 'adjective', def: 'dreadful' },
        'aeternus': { pos: 'adjective', def: 'eternal' }, 'aeterna': { pos: 'adjective', def: 'eternal' }, 'aeternum': { pos: 'adjective', def: 'eternal' },
        'immensus': { pos: 'adjective', def: 'immense, boundless' }, 'immensa': { pos: 'adjective', def: 'immense' }, 'immensum': { pos: 'adjective', def: 'immense' },
        'vastus': { pos: 'adjective', def: 'vast, huge' }, 'vasta': { pos: 'adjective', def: 'vast' }, 'vastum': { pos: 'adjective', def: 'vast' },
        'celsus': { pos: 'adjective', def: 'high, lofty' }, 'celsa': { pos: 'adjective', def: 'high' }, 'celsum': { pos: 'adjective', def: 'high' },
        'arduus': { pos: 'adjective', def: 'steep, difficult' }, 'ardua': { pos: 'adjective', def: 'steep' }, 'arduum': { pos: 'adjective', def: 'steep' },
       
        // Abstract nouns
        'animus': { pos: 'noun', def: 'mind, spirit' }, 'animi': { pos: 'noun', def: 'mind' }, 'animo': { pos: 'noun', def: 'mind' }, 'animum': { pos: 'noun', def: 'mind' }, 'animis': { pos: 'noun', def: 'minds' },
        'anima': { pos: 'noun', def: 'soul, life' }, 'animae': { pos: 'noun', def: 'soul' }, 'animam': { pos: 'noun', def: 'soul' },
        'pectus': { pos: 'noun', def: 'breast, heart' }, 'pectoris': { pos: 'noun', def: 'breast' }, 'pectore': { pos: 'noun', def: 'breast' }, 'pectora': { pos: 'noun', def: 'breasts' },
        'cor': { pos: 'noun', def: 'heart' }, 'cordis': { pos: 'noun', def: 'heart' }, 'cordi': { pos: 'noun', def: 'heart' }, 'corde': { pos: 'noun', def: 'heart' },
        'virtus': { pos: 'noun', def: 'virtue, courage' }, 'virtutis': { pos: 'noun', def: 'virtue' }, 'virtute': { pos: 'noun', def: 'virtue' }, 'virtutes': { pos: 'noun', def: 'virtues' },
        'gloria': { pos: 'noun', def: 'glory' }, 'gloriae': { pos: 'noun', def: 'glory' }, 'gloriam': { pos: 'noun', def: 'glory' },
        'fama': { pos: 'noun', def: 'fame, rumor' }, 'famae': { pos: 'noun', def: 'fame' }, 'famam': { pos: 'noun', def: 'fame' },
        'laus': { pos: 'noun', def: 'praise' }, 'laudis': { pos: 'noun', def: 'praise' }, 'laude': { pos: 'noun', def: 'praise' }, 'laudes': { pos: 'noun', def: 'praises' },
        'dolor': { pos: 'noun', def: 'pain, grief' }, 'doloris': { pos: 'noun', def: 'pain' }, 'dolore': { pos: 'noun', def: 'pain' },
        'furor': { pos: 'noun', def: 'rage, madness' }, 'furoris': { pos: 'noun', def: 'rage' }, 'furore': { pos: 'noun', def: 'rage' },
        'ira': { pos: 'noun', def: 'anger' }, 'irae': { pos: 'noun', def: 'anger' }, 'iram': { pos: 'noun', def: 'anger' }, 'iris': { pos: 'noun', def: 'angers' },
        'amor': { pos: 'noun', def: 'love' }, 'amoris': { pos: 'noun', def: 'love' }, 'amore': { pos: 'noun', def: 'love' },
        'metus': { pos: 'noun', def: 'fear' }, 'metus': { pos: 'noun', def: 'fear' }, 'metu': { pos: 'noun', def: 'fear' },
        'spes': { pos: 'noun', def: 'hope' }, 'spei': { pos: 'noun', def: 'hope' }, 'spem': { pos: 'noun', def: 'hope' }, 'spe': { pos: 'noun', def: 'hope' },
        'labor': { pos: 'noun', def: 'labor, toil' }, 'laboris': { pos: 'noun', def: 'labor' }, 'labore': { pos: 'noun', def: 'labor' }, 'labores': { pos: 'noun', def: 'labors' },
        'opus': { pos: 'noun', def: 'work, deed' }, 'operis': { pos: 'noun', def: 'work' }, 'opere': { pos: 'noun', def: 'work' }, 'opera': { pos: 'noun', def: 'works' },
       
        // Body parts and physical
        'corpus': { pos: 'noun', def: 'body' }, 'corporis': { pos: 'noun', def: 'body' }, 'corpore': { pos: 'noun', def: 'body' }, 'corpora': { pos: 'noun', def: 'bodies' },
        'caput': { pos: 'noun', def: 'head' }, 'capitis': { pos: 'noun', def: 'head' }, 'capite': { pos: 'noun', def: 'head' }, 'capita': { pos: 'noun', def: 'heads' },
        'oculus': { pos: 'noun', def: 'eye' }, 'oculi': { pos: 'noun', def: 'eye' }, 'oculo': { pos: 'noun', def: 'eye' }, 'oculum': { pos: 'noun', def: 'eye' }, 'oculos': { pos: 'noun', def: 'eyes' }, 'oculis': { pos: 'noun', def: 'eyes' },
        'manus': { pos: 'noun', def: 'hand' }, 'manus': { pos: 'noun', def: 'hand' }, 'manui': { pos: 'noun', def: 'hand' }, 'manum': { pos: 'noun', def: 'hand' }, 'manu': { pos: 'noun', def: 'hand' }, 'manibus': { pos: 'noun', def: 'hands' },
        'pes': { pos: 'noun', def: 'foot' }, 'pedis': { pos: 'noun', def: 'foot' }, 'pedi': { pos: 'noun', def: 'foot' }, 'pedem': { pos: 'noun', def: 'foot' }, 'pede': { pos: 'noun', def: 'foot' }, 'pedes': { pos: 'noun', def: 'feet' },
        'vox': { pos: 'noun', def: 'voice' }, 'vocis': { pos: 'noun', def: 'voice' }, 'vocem': { pos: 'noun', def: 'voice' }, 'voce': { pos: 'noun', def: 'voice' },
        'sanguis': { pos: 'noun', def: 'blood' }, 'sanguinis': { pos: 'noun', def: 'blood' }, 'sanguine': { pos: 'noun', def: 'blood' },
        'vulnus': { pos: 'noun', def: 'wound' }, 'vulneris': { pos: 'noun', def: 'wound' }, 'vulnere': { pos: 'noun', def: 'wound' }, 'vulnera': { pos: 'noun', def: 'wounds' },
       
        // Time and numbers
        'tempus': { pos: 'noun', def: 'time' }, 'temporis': { pos: 'noun', def: 'time' }, 'tempore': { pos: 'noun', def: 'time' }, 'tempora': { pos: 'noun', def: 'times' },
        'hora': { pos: 'noun', def: 'hour' }, 'horae': { pos: 'noun', def: 'hour' }, 'horam': { pos: 'noun', def: 'hour' }, 'horis': { pos: 'noun', def: 'hours' },
        'dies': { pos: 'noun', def: 'day' }, 'diei': { pos: 'noun', def: 'day' }, 'diem': { pos: 'noun', def: 'day' }, 'die': { pos: 'noun', def: 'day' }, 'dierum': { pos: 'noun', def: 'days' },
        'nox': { pos: 'noun', def: 'night' }, 'noctis': { pos: 'noun', def: 'night' }, 'noctem': { pos: 'noun', def: 'night' }, 'nocte': { pos: 'noun', def: 'night' }, 'noctes': { pos: 'noun', def: 'nights' },
        'lux': { pos: 'noun', def: 'light' }, 'lucis': { pos: 'noun', def: 'light' }, 'lucem': { pos: 'noun', def: 'light' }, 'luce': { pos: 'noun', def: 'light' },
        'annus': { pos: 'noun', def: 'year' }, 'anni': { pos: 'noun', def: 'year' }, 'anno': { pos: 'noun', def: 'year' }, 'annum': { pos: 'noun', def: 'year' }, 'annos': { pos: 'noun', def: 'years' },
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' },
        'duo': { pos: 'adjective', def: 'two' }, 'duae': { pos: 'adjective', def: 'two' }, 'duos': { pos: 'adjective', def: 'two' },
        'tres': { pos: 'adjective', def: 'three' }, 'tria': { pos: 'adjective', def: 'three' },
        'multus': { pos: 'adjective', def: 'much, many' }, 'multa': { pos: 'adjective', def: 'much, many' }, 'multum': { pos: 'adjective', def: 'much, many' }, 'multi': { pos: 'adjective', def: 'many' }, 'multos': { pos: 'adjective', def: 'many' }, 'multis': { pos: 'adjective', def: 'many' },
        'maximus': { pos: 'adjective', def: 'greatest, very great' }, 'maxima': { pos: 'adjective', def: 'greatest, very great' }, 'maximum': { pos: 'adjective', def: 'greatest, very great', case: 'acc sg (or nom/acc sg neuter)' },
        'maximas': { pos: 'adjective', def: 'very great, greatest', case: 'acc pl' }, 'maximo': { pos: 'adjective', def: 'very great', case: 'dat/abl sg' }, 'maximis': { pos: 'adjective', def: 'very great', case: 'dat/abl pl' },
        'proximus': { pos: 'adjective', def: 'nearest, next' }, 'proxima': { pos: 'adjective', def: 'nearest' }, 'proximorum': { pos: 'adjective', def: 'of the nearest' }, 'proximis': { pos: 'adjective', def: 'nearest, next', case: 'dat/abl pl' },
        'omnis': { pos: 'adjective', def: 'all, every', case: 'nom/gen sg' }, 'omne': { pos: 'adjective', def: 'all', case: 'nom/acc sg neut' }, 'omnes': { pos: 'adjective', def: 'all', case: 'nom/acc pl' }, 'omnia': { pos: 'adjective', def: 'all', case: 'nom/acc pl neut' }, 'omnium': { pos: 'adjective', def: 'all', case: 'gen pl' },
        'totus': { pos: 'adjective', def: 'whole, entire' }, 'tota': { pos: 'adjective', def: 'whole' }, 'totum': { pos: 'adjective', def: 'whole' },
        'nullus': { pos: 'adjective', def: 'no, none' }, 'nulla': { pos: 'adjective', def: 'no' }, 'nullum': { pos: 'adjective', def: 'no' },
       
        // Common connecting words and particles
        'atque': { pos: 'conjunction', def: 'and' }, 'ac': { pos: 'conjunction', def: 'and' },
        'que': { pos: 'particle', def: 'and' },
        'vel': { pos: 'conjunction', def: 'or' },
        'aut': { pos: 'conjunction', def: 'or' },
        'nam': { pos: 'conjunction', def: 'for' },
        'enim': { pos: 'particle', def: 'for, indeed' },
        'autem': { pos: 'conjunction', def: 'but, however' },
        'tamen': { pos: 'adverb', def: 'nevertheless, however' },
        'ergo': { pos: 'adverb', def: 'therefore' },
        'igitur': { pos: 'adverb', def: 'therefore' },
        'itaque': { pos: 'adverb', def: 'and so, therefore' }
    };

    function lookupDefinition(word) {
        const n = normalizeLatin(word);
        return LEXICON[n]?.def;
    }

    // === API FALLBACK SYSTEM FOR UNKNOWN WORDS ===
   
    // Local cache for API lookups
    const WORD_CACHE_KEY = 'latinWordCache';
    const CACHE_EXPIRY_DAYS = 30;
   
    function getWordCache() {
        try {
            const cache = localStorage.getItem(WORD_CACHE_KEY);
            if (!cache) return {};
            const parsed = JSON.parse(cache);
            // Check if cache is expired
            if (parsed.timestamp && (Date.now() - parsed.timestamp > CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                localStorage.removeItem(WORD_CACHE_KEY);
                return {};
            }
            return parsed.words || {};
        } catch (e) {
            return {};
        }
    }
   
    function setWordCache(cache) {
        try {
            localStorage.setItem(WORD_CACHE_KEY, JSON.stringify({
                timestamp: Date.now(),
                words: cache
            }));
        } catch (e) {
            console.warn('Could not save word cache to localStorage');
        }
    }
   
    function cacheWord(word, data) {
        const cache = getWordCache();
        cache[word] = data;
        setWordCache(cache);
    }
   
    // Fallback API lookup using Whitaker's Words approach
    async function lookupWordAPI(word) {
        const normalized = normalizeLatin(word);
        console.log('[API LOOKUP] Starting lookup for:', word, '→', normalized);
       
        // // Check cache first
        // const cache = getWordCache();
        // if (cache[normalized]) {
        //     console.log('[API LOOKUP] Found in cache:', normalized, '→', cache[normalized]);
        //     return cache[normalized];
        // }
       
        console.log('[API LOOKUP] Not in cache, trying APIs...');
       
        // CORS proxy to enable browser-based API calls
        const CORS_PROXY = 'https://corsproxy.io/?';
       
        try {
       // Option 1: Try Perseus Dictionary (NOT just morphology!)
       try {
            // STEP 1: Get the lemma (base form) from morphology
            const morphURL = `http://www.perseus.tufts.edu/hopper/xmlmorph?lang=lat&lookup=${encodeURIComponent(normalized)}`;
            const morphProxied = CORS_PROXY + encodeURIComponent(morphURL);
            console.log('[API LOOKUP] Step 1: Getting lemma from morphology...');
            
            const morphResponse = await fetch(morphProxied, {
                method: 'GET',
                signal: AbortSignal.timeout(10000)
            });
            
            if (!morphResponse.ok) {
                throw new Error('Morphology lookup failed');
            }
            
            const morphXML = await morphResponse.text();
            const parser = new DOMParser();
            const morphDoc = parser.parseFromString(morphXML, 'text/xml');
            
            // Extract lemma and POS
            const analyses = morphDoc.getElementsByTagName('analysis');
            if (analyses.length === 0) {
                throw new Error('No morphological analysis found');
            }
            
            const firstAnalysis = analyses[0];
            const lemmaEl = firstAnalysis.getElementsByTagName('lemma')[0];
            const lemma = lemmaEl ? lemmaEl.textContent.trim() : normalized;
            
            const posEl = firstAnalysis.getElementsByTagName('pos')[0];
            let pos = posEl ? posEl.textContent.toLowerCase() : 'unknown';
            
            // Normalize POS
            const posMap = {
                'noun': 'noun',
                'verb': 'verb',
                'adjective': 'adjective',
                'adverb': 'adverb',
                'pronoun': 'pronoun',
                'preposition': 'preposition',
                'conjunction': 'conjunction',
                'particle': 'particle',
                'numeral': 'numeral',
                'participle': 'participle'
            };
            pos = posMap[pos] || 'unknown';
            
            console.log('[API LOOKUP] Found lemma:', lemma, 'POS:', pos);
            
            // STEP 2: Look up the DICTIONARY entry for the lemma
            const dictURL = `http://www.perseus.tufts.edu/hopper/text?doc=Perseus:text:1999.04.0059:entry=${encodeURIComponent(lemma)}`;
            const dictProxied = CORS_PROXY + encodeURIComponent(dictURL);
            console.log('[API LOOKUP] Step 2: Getting definition from dictionary...');
            
            const dictResponse = await fetch(dictProxied, {
                method: 'GET',
                signal: AbortSignal.timeout(10000)
            });
            
            if (!dictResponse.ok) {
                throw new Error('Dictionary lookup failed');
            }
            
            const dictHTML = await dictResponse.text();
const dictDoc = parser.parseFromString(dictHTML, 'text/html');

console.log('[API LOOKUP] Dictionary HTML received, parsing...');

// === DEBUG LOGGING - START ===
console.log('[DEBUG] Perseus Response Length:', dictHTML.length, 'characters');
console.log('[DEBUG] First 1000 characters:', dictHTML.substring(0, 1000));

// Check what elements Perseus is returning
const allText = dictDoc.body ? dictDoc.body.innerText : '';
console.log('[DEBUG] Body text (first 500 chars):', allText.substring(0, 500));

// Test our selectors
const testSelectors = [
    '.lex_sense',
    '.lex_sense1',
    'span[lang="en"]',
    '.foreign',
    'div.text_container',
    'div#text_content',
    'div.entry',
    'div.lex_entry'
];

testSelectors.forEach(selector => {
    const elements = dictDoc.querySelectorAll(selector);
    console.log(`[DEBUG] Selector "${selector}": found ${elements.length} elements`);
    if (elements.length > 0) {
        console.log(`[DEBUG] First match text:`, elements[0].textContent.substring(0, 100));
    }
});
// === DEBUG LOGGING - END ===
            
// Extract definition from HTML
let definition = null;

// Look for .lex_sense elements (these contain the definitions)
const lexSenseElements = dictDoc.querySelectorAll('.lex_sense, .lex_sense1');

console.log('[API LOOKUP] Found', lexSenseElements.length, 'definition elements');

if (lexSenseElements.length > 0) {
    // Get the first definition
    const firstDef = lexSenseElements[0].textContent.trim();
    console.log('[API LOOKUP] Raw first definition:', firstDef.substring(0, 200));
    
    let cleaned = firstDef;

// STEP 1: Extract everything AFTER the etymology bracket (if present)
// Perseus format: [etymology stuff], actual definition
if (cleaned.includes(']')) {
    // Take everything after the last closing bracket
    cleaned = cleaned.split(']').pop();
}

// STEP 2: Remove Roman numerals at start (I., II., etc)
cleaned = cleaned.replace(/^[IVX]+\.\s*/, '');

// STEP 3: Remove gender markers at start (f., m., n.)
cleaned = cleaned.replace(/^[fmn]\.\s*/i, '');

// STEP 4: Remove leading punctuation/whitespace
cleaned = cleaned.replace(/^[,;\s]+/, '');

// STEP 5: Remove quoted Latin phrases (like "ovis mas")
cleaned = cleaned.replace(/^"[^"]*",?\s*/g, '');

// STEP 6: Take first sentence/clause (before period or semicolon)
cleaned = cleaned.split(/[.;]/)[0].trim();

// STEP 7: Remove any remaining citations
cleaned = cleaned.replace(/\b[A-Z][a-z]{2,}\.\s*[A-Z].*$/g, '').trim();

// STEP 8: Take first meaningful part (before comma, but keep "a sheep" not just "a")
const parts = cleaned.split(',');
cleaned = parts[0].trim();

console.log('[API LOOKUP] Cleaned definition:', cleaned);
    
    if (withoutParens.length > 2 && withoutParens.length < 150) {
        definition = withoutParens;
        console.log('[API LOOKUP] ✓ Extracted definition:', definition);
    } else if (firstClause.length > 2 && firstClause.length < 150) {
        definition = firstClause;
        console.log('[API LOOKUP] ✓ Extracted definition:', definition);
    }
}
            
            const result = {
                pos: pos,
                def: definition,
                found: definition !== 'unknown',
                lemma: lemma
            };
            
            cacheWord(normalized, result);
            console.log('[API LOOKUP] Final result:', result);
            return result;
            
        } catch (e) {
            console.log('[API LOOKUP] Perseus error:', e.message);
        }
           
            // Option 2: Try Latinitium API (fallback)
            try {
                const latinitiumURL = `https://api.latinitium.com/api/v1/words/${encodeURIComponent(normalized)}`;
                const proxiedURL = CORS_PROXY + encodeURIComponent(latinitiumURL);
                console.log('[API LOOKUP] Trying Latinitium (fallback):', proxiedURL);
                const latinitiumResponse = await fetch(proxiedURL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    signal: AbortSignal.timeout(8000)
                });
               
                if (latinitiumResponse.ok) {
                    const data = await latinitiumResponse.json();
                    if (data && data.definitions && data.definitions.length > 0) {
                        const result = {
                            pos: data.pos || determinePosMorphologically(normalized),
                            def: data.definitions[0].meaning || data.definitions[0],
                            found: true
                        };
                        cacheWord(normalized, result);
                        console.log('✓ Found via Latinitium:', normalized, '→', result.def);
                        return result;
                    }
                }
            } catch (e) {
                console.log('Latinitium API unavailable:', e.message);
            }
           
        } catch (error) {
            console.log('All API lookups failed for:', word, error);
        }

        // Option 3: Try Whitaker's Words (fallback #2)
try {
    // Whitaker's Words endpoint (via online service)
    const whitakerURL = `http://www.archives.nd.edu/cgi-bin/wordz.pl?keyword=${encodeURIComponent(normalized)}`;
    const proxiedURL = CORS_PROXY + encodeURIComponent(whitakerURL);
    console.log('[API LOOKUP] Trying Whitaker\'s Words (fallback #2):', proxiedURL);
    
    const whitakerResponse = await fetch(proxiedURL, {
        method: 'GET',
        signal: AbortSignal.timeout(8000)
    });
    
    if (whitakerResponse.ok) {
        const htmlText = await whitakerResponse.text();
        console.log('[API LOOKUP] Whitaker response received, parsing HTML...');
        
        // Parse HTML to extract definition
        // Whitaker returns HTML with definitions in specific format
        const parser = new DOMParser();
        const doc = parser.parseFromString(htmlText, 'text/html');
        
        // Look for definition text (Whitaker uses <pre> tags)
        const preElements = doc.getElementsByTagName('pre');
        
        if (preElements.length > 0) {
            const text = preElements[0].textContent;
            
            // Extract the English definition (usually after "=>")
            const lines = text.split('\n');
            let definition = '';
            let pos = 'unknown';
            
            for (const line of lines) {
                // Look for part of speech indicators
                if (line.includes('N ') || line.includes('noun')) pos = 'noun';
                else if (line.includes('V ') || line.includes('verb')) pos = 'verb';
                else if (line.includes('ADJ') || line.includes('adjective')) pos = 'adjective';
                else if (line.includes('ADV') || line.includes('adverb')) pos = 'adverb';
                else if (line.includes('PREP') || line.includes('preposition')) pos = 'preposition';
                else if (line.includes('PRON') || line.includes('pronoun')) pos = 'pronoun';
                else if (line.includes('CONJ') || line.includes('conjunction')) pos = 'conjunction';
                else if (line.includes('VPAR') || line.includes('participle')) pos = 'participle';
                
                // Extract definition (text after semicolons or in certain patterns)
                if (line.includes(';')) {
                    const parts = line.split(';');
                    // Take the part with actual English words
                    for (const part of parts) {
                        const cleaned = part.trim();
                        if (cleaned.length > 0 && 
                            cleaned.length < 100 && 
                            !cleaned.match(/^[A-Z\s,\-]+$/) && // Skip all-caps lines
                            cleaned.match(/[a-z]/)) { // Must have lowercase (English)
                            definition = cleaned;
                            break;
                        }
                    }
                    if (definition) break;
                }
            }
            
            // If we found a definition, use it
            if (definition && definition.length > 0) {
                // Clean up definition
                definition = definition.replace(/^\s*[-;,]\s*/, ''); // Remove leading punctuation
                definition = definition.split(',')[0]; // Take first meaning
                definition = definition.trim();
                
                if (pos === 'unknown') {
                    pos = determinePosMorphologically(normalized);
                }
                
                const result = {
                    pos: pos,
                    def: definition,
                    found: true
                };
                
                cacheWord(normalized, result);
                console.log('✓ Found via Whitaker\'s Words:', normalized, '→', result.def, `(${pos})`);
                return result;
            }
        }
    }
} catch (e) {
    console.log('Whitaker\'s Words API error:', e.message);
}
       
        // If all APIs fail, use morphological analysis as last resort
        const morphResult = analyzeMorphologically(normalized);
        if (morphResult.pos !== 'unknown') {
            // DON'T cache morphological results - they're not reliable definitions
            // This allows the system to retry with APIs later
            console.log('[API LOOKUP] Using morphological fallback (not cached):', morphResult);
            return morphResult;
        }
       
        // If everything fails, DON'T cache it - allow retries in future sessions
        const unknownResult = { pos: 'unknown', def: 'unknown', found: false };
        console.log('[API LOOKUP] All methods failed, returning unknown (not cached)');
        return unknownResult;
    }
   
    // Morphological analysis fallback
    // This identifies the likely part of speech but doesn't provide real definitions
    function analyzeMorphologically(word) {
        const w = word.toLowerCase();
    
    // Noun endings (2nd declension)
    if (/(us|um|i|o|orum|is)$/i.test(w)) {
        return { pos: 'noun', def: 'unknown' };
    }
    
    // Noun endings (1st declension)
    if (/(a|ae|am|arum)$/i.test(w)) {
        return { pos: 'noun', def: 'unknown' };
    }
    
    // Noun endings (3rd declension)
    if (/(em|es|is|e|ibus)$/i.test(w)) {
        return { pos: 'noun', def: 'unknown' };
    }
    
    // Verb endings
    if (/(o|as|at|amus|atis|ant|or|aris|atur|amur|antur)$/i.test(w) && !/um$/i.test(w)) {
        return { pos: 'verb', def: 'unknown' };
    }
    
    // Adjective endings
    if (/(us|a|um|is|e)$/i.test(w)) {
        return { pos: 'adjective', def: 'unknown' };
    }
    
    return { pos: 'unknown', def: 'unknown' };
        
    }
   
    function determinePosMorphologically(word) {
        const result = analyzeMorphologically(word);
        return result.pos;
    }
   
    // Enhanced definition lookup with API fallback
    function lookupDefinitionWithFallback(word) {
        const n = normalizeLatin(word);
        const localDef = LEXICON[n]?.def;
       
        if (localDef) {
            return localDef;
        }
       
        // Check cache for API result
        const cache = getWordCache();
        if (cache[n]) {
            return cache[n].def;
        }
       
        // Return undefined if not in local lexicon or cache
        // The API lookup will happen asynchronously later if needed
        return undefined;
    }
   
    // Function to enhance unknown words with API data
    async function enhanceUnknownWords(tokens) {
        console.log('[API ENHANCE] Called with', tokens.length, 'total tokens');
       
        // Only lookup truly unknown words - skip words already in lexicon
        const unknownTokens = tokens.filter(t => {
            if (!t.normalized) return false;
           
            // Check if word is in lexicon with a good definition
            const lexEntry = LEXICON[t.normalized];
            if (lexEntry && lexEntry.def && lexEntry.def !== 'unknown') {
                return false;
            }

            // If we have POS but no definition, still treat as unknown so API can fill it in
            if (t.pos && t.pos !== 'unknown' && (!t.definition || t.definition === 'unknown')) {
                return true;
            }

            if (lexEntry && (!lexEntry.def || lexEntry.def === 'unknown')) {
                return true;
            }

            if (t.pos === 'verb' && (!t.definition || t.definition === 'unknown')) {
                return true;
            }

            if (lexEntry && !lexEntry.def) {
                console.log('[API ENHANCE] Skipping', t.normalized, '- already in lexicon with definition:', lexEntry.def);
                return false;
            }
           
            // Only include if truly unknown
            return (t.pos === 'unknown' || !t.definition || t.definition === 'unknown');
        });
       
        console.log('[API ENHANCE] Found', unknownTokens.length, 'unknown tokens:',
            unknownTokens.map(t => t.normalized).join(', '));
       
        if (unknownTokens.length === 0) {
            console.log('[API ENHANCE] No unknown tokens, skipping API lookup');
            return;
        }
       
        // Lookup unknown words via API (with rate limiting)
        const lookupPromises = unknownTokens.slice(0, 10).map(async (t) => {
            console.log('[API ENHANCE] Looking up:', t.normalized);
            const apiResult = await lookupWordAPI(t.normalized);
            console.log('[API ENHANCE] Result for', t.normalized, ':', apiResult);
            if (apiResult.found) {
                t.pos = apiResult.pos;
                t.definition = apiResult.def;
               
                // Don't overwrite lexicon if it already has this word
                if (!LEXICON[t.normalized]) {
                    LEXICON[t.normalized] = { pos: apiResult.pos, def: apiResult.def };
                    console.log('[API ENHANCE] Added to lexicon:', t.normalized);
                } else {
                    console.log('[API ENHANCE] Token updated but lexicon preserved for:', t.normalized);
                }
            } else {
                console.log('[API ENHANCE] No definition found for:', t.normalized);
            }
        });
       
        await Promise.all(lookupPromises);
        console.log('[API ENHANCE] All lookups complete');
    }
   
    // Hook into the analyze function to enhance with API data
    const originalAnalyze = analyze;
    async function analyzeWithAPI(rawText, opts) {
        console.log('[ANALYZE WITH API] Called for text:', rawText);
        const result = originalAnalyze(rawText, opts);
        console.log('[ANALYZE WITH API] Analysis complete, tokens:', result.tokens.length);

        // Wait for enhancement to complete before returning (prevents flickering and incomplete data)
        console.log('[ANALYZE WITH API] Starting enhancement...');
        try {
            await enhanceUnknownWords(result.tokens);
            console.log('[ANALYZE WITH API] Enhancement complete');
        } catch (err) {
            console.error('[ANALYZE WITH API] Enhancement failed:', err);
            // Continue even if enhancement fails - we still have basic morphological analysis
        }

        return result;
    }
   
    // API fallback is now ENABLED
    // The system will try multiple Latin dictionary APIs when words are not found locally
    // If all APIs fail, it falls back to morphological analysis
    // All results are cached locally for 30 days to improve performance

    // Initialize counts
    updateWordCount();
// Prevent any clicks inside tooltip from closing it
tooltip.addEventListener('mousedown', (e) => {
    e.stopImmediatePropagation();
}, true);

tooltip.addEventListener('click', (e) => {
    e.stopImmediatePropagation();
    
    // If it's a link, manually open it
    if (e.target.tagName === 'A') {
        const href = e.target.getAttribute('href');
        if (href) {
            window.open(href, '_blank');
            hideTooltip(true); // Close after opening link
        }
    }
}, true);

// Global handler to close tooltip when clicking outside
document.addEventListener('mousedown', (e) => {
    // Ignore if clicking inside tooltip
    if (tooltip.contains(e.target)) {
        return;
    }
    
    // Ignore if clicking on a token (handled separately)
    if (e.target.closest('.token')) {
        return;
    }
    
    // Close the tooltip
    hideTooltip(true);
});
    
})();
    </script>
</body>
</html>  