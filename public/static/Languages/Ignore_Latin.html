<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Latin Text Analyzer</title>
    <style>
        :root {
            --hw-cream: #f5f2ea;
            --hw-white: #ffffff;
            --hw-red: #b3072c;
            --hw-red-dark: #8c0522;
            --hw-dark: #1f1f1f;
            --hw-muted: #716458;
            --hw-border: #e4ddd1;
            --hw-border-strong: #d6cbb9;
            --hw-shadow: 0 32px 80px rgba(60, 44, 33, 0.12);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            font-family: 'Work Sans', 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: var(--hw-cream);
            color: var(--hw-dark);
            min-height: 100vh;
            padding: 32px 24px 64px;
            line-height: 1.6;
        }

        a {
            color: inherit;
            text-decoration: none;
        }

        .top-bar {
            max-width: 1200px;
            margin: 0 auto 32px;
            padding: 16px 28px;
            border-radius: 20px;
            background: var(--hw-white);
            border: 1px solid var(--hw-border);
            box-shadow: var(--hw-shadow);
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .brand {
            font-weight: 700;
            letter-spacing: 0.14em;
            text-transform: uppercase;
            font-size: 0.95rem;
            color: var(--hw-red);
        }

        .nav-links {
            display: flex;
            gap: 28px;
        }

        .nav-link {
            font-weight: 600;
            font-size: 0.95rem;
            color: var(--hw-muted);
            position: relative;
            padding-bottom: 4px;
            transition: color 0.2s ease;
        }

        .nav-link::after {
            content: '';
            position: absolute;
            left: 0;
            bottom: -6px;
            width: 0;
            height: 2px;
            background: var(--hw-red);
            transition: width 0.2s ease;
        }

        .nav-link:hover {
            color: var(--hw-dark);
        }

        .nav-link:hover::after,
        .nav-link.active::after {
            width: 100%;
        }

        .page-container {
            max-width: 1120px;
            margin: 0 auto;
        }

        .container {
            background: var(--hw-white);
            border-radius: 28px;
            padding: 48px 56px 56px;
            box-shadow: var(--hw-shadow);
            border: 1px solid var(--hw-border);
        }

        .page-intro {
            text-align: center;
            margin-bottom: 44px;
        }

        .eyebrow {
            display: inline-block;
            font-size: 0.75rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            font-weight: 700;
            color: var(--hw-red);
            margin-bottom: 18px;
        }

        h1 {
            font-size: 2.85rem;
            font-weight: 800;
            color: var(--hw-dark);
            margin-bottom: 12px;
        }

        .subtitle {
            max-width: 640px;
            margin: 0 auto;
            color: var(--hw-muted);
            font-size: 1.05rem;
        }

        .section {
            margin-bottom: 32px;
        }

        .section-title {
            font-size: 0.8rem;
            letter-spacing: 0.22em;
            text-transform: uppercase;
            color: var(--hw-red);
            font-weight: 700;
            margin-bottom: 14px;
        }

        .mode-buttons {
            display: flex;
            gap: 16px;
            justify-content: center;
            flex-wrap: wrap;
        }

        button {
            padding: 12px 28px;
            font-size: 0.95rem;
            border-radius: 999px;
            font-weight: 700;
            letter-spacing: 0.08em;
            text-transform: uppercase;
            border: 1px solid var(--hw-border-strong);
            background: var(--hw-white);
            color: var(--hw-dark);
            cursor: pointer;
            transition: all 0.2s ease;
            min-width: 160px;
        }

        button:hover {
            border-color: var(--hw-red);
            color: var(--hw-red);
            box-shadow: 0 12px 26px rgba(30, 21, 15, 0.12);
        }

        button:disabled {
            background: #ebe2d4;
            border-color: #ded4c3;
            color: #a99c8d;
            cursor: not-allowed;
            box-shadow: none;
        }

        button:disabled:hover {
            color: #a99c8d;
            border-color: #ded4c3;
        }

        .mode-button {
            background: var(--hw-white);
            color: var(--hw-muted);
        }

        .mode-button:hover {
            background: rgba(179, 7, 44, 0.08);
        }

        .mode-button.active,
        .mode-button[aria-pressed="true"] {
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            box-shadow: 0 16px 30px rgba(179, 7, 44, 0.25);
        }

        .mode-button.active:hover {
            color: var(--hw-white);
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
        }

        input[type="text"],
        textarea {
            width: 100%;
            padding: 14px 18px;
            border: 1px solid var(--hw-border-strong);
            border-radius: 18px;
            font-size: 1rem;
            font-family: inherit;
            transition: border-color 0.2s ease, box-shadow 0.2s ease;
            background: var(--hw-white);
            color: var(--hw-dark);
        }

        input[type="text"]:focus,
        textarea:focus {
            outline: none;
            border-color: var(--hw-red);
            box-shadow: 0 0 0 4px rgba(179, 7, 44, 0.14);
        }

        textarea {
            resize: vertical;
            min-height: 140px;
            font-family: 'Georgia', serif;
            line-height: 1.68;
            border-radius: 22px;
        }

        #latin-input.overlay-active {
            color: transparent;
            caret-color: transparent;
        }

        #latin-input.overlay-active::selection {
            background: transparent;
            color: transparent;
        }

        .latin-input-wrapper {
            position: relative;
        }

        #latin-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            padding: 14px 18px;
            border-radius: 22px;
            font-size: 1rem;
            font-family: 'Georgia', serif;
            line-height: 1.68;
            pointer-events: none;
            background: transparent;
            white-space: pre-wrap;
            word-wrap: break-word;
            display: none;
        }

        .token {
            cursor: pointer;
            padding: 2px 0;
            border-radius: 4px;
            transition: background 0.2s ease, color 0.2s ease;
        }

        .token.highlight {
            font-weight: 600;
        }

        .token:hover {
            background: rgba(179, 7, 44, 0.12);
        }

        .word-count {
            text-align: right;
            font-size: 0.85rem;
            color: var(--hw-muted);
            margin-top: 6px;
            letter-spacing: 0.04em;
        }

        .input-warning {
            color: var(--hw-red);
            font-size: 0.9rem;
            margin-top: 6px;
            min-height: 20px;
            font-weight: 600;
        }

        #examine-btn {
            margin: 24px auto 8px;
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            box-shadow: 0 22px 40px rgba(179, 7, 44, 0.25);
            min-width: 220px;
        }

        #examine-btn:hover {
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
            color: var(--hw-white);
        }

        .analysis-output {
            background: #fbfaf7;
            border-radius: 22px;
            padding: 28px;
            margin-top: 24px;
            border: 1px solid var(--hw-border);
        }

        #group-legend {
            display: flex;
            flex-wrap: wrap;
            gap: 18px;
            margin-top: 18px;
        }

        .swatch {
            display: flex;
            align-items: center;
            gap: 10px;
            font-size: 0.95rem;
        }

        .dot {
            width: 18px;
            height: 18px;
            border-radius: 50%;
            display: inline-block;
            border: 1px solid rgba(0, 0, 0, 0.08);
        }

        #rendered-text {
            background: var(--hw-white);
            padding: 20px 24px;
            border-radius: 20px;
            margin-top: 18px;
            font-family: 'Georgia', serif;
            line-height: 1.82;
            border: 1px solid var(--hw-border);
        }

        .grammar-section {
            margin-top: 24px;
        }

        .grammar-item {
            background: var(--hw-white);
            padding: 16px 18px;
            margin-bottom: 12px;
            border-radius: 16px;
            border: 1px solid var(--hw-border);
            box-shadow: 0 8px 18px rgba(25, 17, 12, 0.08);
        }

        .grammar-name {
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.08em;
            color: var(--hw-red);
            margin-right: 10px;
            display: inline-block;
        }

        .grammar-text {
            color: var(--hw-muted);
            font-style: italic;
        }

        .translation-input {
            border: 1px solid var(--hw-border-strong);
        }

        .translation-correct {
            border-color: #2f9e44 !important;
            background: #effaf0;
        }

        .translation-incorrect {
            border-color: var(--hw-red) !important;
            background: #fef2f4;
        }

        #check-translation-btn {
            background: var(--hw-red);
            border-color: var(--hw-red);
            color: var(--hw-white);
            margin-top: 22px;
            box-shadow: 0 16px 28px rgba(179, 7, 44, 0.22);
        }

        #check-translation-btn:hover {
            background: var(--hw-red-dark);
            border-color: var(--hw-red-dark);
            color: var(--hw-white);
        }

        .translation-feedback {
            margin-top: 14px;
            font-weight: 600;
            min-height: 24px;
            color: var(--hw-muted);
        }

        .tooltip {
            position: fixed;
            background: rgba(30, 21, 15, 0.94);
            color: var(--hw-white);
            padding: 14px 18px;
            border-radius: 14px;
            font-size: 0.9rem;
            line-height: 1.55;
            z-index: 1000;
            pointer-events: none;
            max-width: 320px;
            box-shadow: 0 20px 40px rgba(30, 21, 15, 0.28);
        }

        .tooltip strong {
            color: var(--hw-white);
            font-size: 1rem;
            text-transform: uppercase;
            letter-spacing: 0.08em;
        }

        .hint {
            color: #bab1a6;
            font-size: 0.88rem;
        }

        [hidden] {
            display: none !important;
        }

        @media (max-width: 900px) {
            body {
                padding: 24px 18px 48px;
            }

            .top-bar {
                flex-direction: column;
                gap: 14px;
                align-items: flex-start;
                padding: 18px 22px;
            }

            .nav-links {
                gap: 18px;
                flex-wrap: wrap;
            }

            .container {
                padding: 36px 24px 44px;
            }

            h1 {
                font-size: 2.3rem;
            }
        }
    </style>
</head>
<body>
    <header class="top-bar">
        <div class="brand">Harvard-Westlake</div>
        <nav class="nav-links" aria-label="Primary navigation">
            <a href="#latin-analyzer" class="nav-link active">Home</a>
        </nav>
    </header>
    <main class="page-container" id="latin-analyzer">
        <div class="container">
            <div class="page-intro">
                <h1>Latin Text Analyzer</h1>
                <p class="subtitle">Analyze Latin poetry and prose with advanced grammatical insights.</p>
            </div>

            <!-- Mode Selection -->
            <div class="section">
                <div class="mode-buttons">
                    <button id="btn-poetry" class="mode-button" aria-pressed="false">Poetry Mode</button>
                    <button id="btn-prose" class="mode-button" aria-pressed="false">Prose Mode</button>
                </div>
            </div>

            <!-- Author Input -->
            <div class="section" id="author-section" hidden>
                <label class="section-title" for="author-input">Author (Optional)</label>
                <input type="text" id="author-input" placeholder="e.g., Vergil, Caesar, Ovid">
            </div>

            <!-- Latin Input -->
            <div class="section" id="latin-section" hidden>
                <label class="section-title" for="latin-input">Latin Text · Max 50 Words</label>
                <div class="latin-input-wrapper">
                    <textarea id="latin-input" placeholder="Enter your Latin text here..."></textarea>
                    <div id="latin-overlay" aria-hidden="true"></div>
                </div>
                <div class="word-count" id="word-count">0/50 words</div>
                <div class="input-warning" id="input-warning"></div>
            </div>

            <!-- Examine Button -->
            <button id="examine-btn" disabled>Examine Text</button>

            <!-- Analysis Output -->
            <div class="analysis-output" id="analysis-output" hidden>
                <div class="section-title">Translation Chunks</div>
                <div id="rendered-text"></div>
            </div>

            <!-- Grammar Section -->
            <div class="grammar-section section" id="grammar-section" hidden>
                <div class="section-title">Advanced Grammar Detected</div>
                <div id="grammar-list"></div>
            </div>

            <!-- Translation Section -->
            <div class="section" id="translation-section" hidden>
                <label class="section-title" for="translation-input">Your Translation</label>
                <textarea id="translation-input" class="translation-input" placeholder="Enter your English translation..."></textarea>
                <button id="check-translation-btn">Check Translation</button>
                <div class="translation-feedback" id="translation-feedback"></div>
            </div>

            <div id="mobile" aria-hidden="true"></div>
        </div>
    </main>

    <script>
// Latin Translator Logic
// Version: 2024-11-09-v33 - Implemented Translation Chunks system (replaces grammatical groups)
    console.log('Latin Translator loaded - Version 2024-11-09-v33');
(function() {
    const modeButtons = {
        poetry: document.getElementById('btn-poetry'),
        prose: document.getElementById('btn-prose')
    };
    const authorSection = document.getElementById('author-section');
    const authorInput = document.getElementById('author-input');
    const latinSection = document.getElementById('latin-section');
    const latinInput = document.getElementById('latin-input');
    const latinOverlay = document.getElementById('latin-overlay');
    const wordCount = document.getElementById('word-count');
    const inputWarning = document.getElementById('input-warning');
    const examineBtn = document.getElementById('examine-btn');
    const analysisOutput = document.getElementById('analysis-output');
    const renderedText = document.getElementById('rendered-text');
    const grammarSection = document.getElementById('grammar-section');
    const grammarList = document.getElementById('grammar-list');
    const translationSection = document.getElementById('translation-section');
    const translationInput = document.getElementById('translation-input');
    const checkTranslationBtn = document.getElementById('check-translation-btn');
    const translationFeedback = document.getElementById('translation-feedback');

    const STATE = {
        mode: null,
        lastValidLatin: '',
        overlayActive: false,
        tokens: [],
        groups: [],
        grammar: [],
        baselineEnglish: []
    };

    const COLOR_PALETTE = [
        '#fde047', '#60a5fa', '#34d399', '#f472b6', '#fb923c', '#a78bfa', '#f87171', '#22d3ee',
        '#fcd34d', '#93c5fd', '#6ee7b7', '#f9a8d4', '#fdba74', '#c4b5fd', '#fca5a5', '#67e8f9',
        '#fef08a', '#bfdbfe', '#a7f3d0', '#fbcfe8', '#fed7aa', '#ddd6fe', '#fecaca', '#a5f3fc'
    ];

    // Mode selection
    modeButtons.poetry.addEventListener('click', () => selectMode('poetry'));
    modeButtons.prose.addEventListener('click', () => selectMode('prose'));

    function selectMode(mode) {
        STATE.mode = mode;
        modeButtons.poetry.setAttribute('aria-pressed', String(mode === 'poetry'));
        modeButtons.prose.setAttribute('aria-pressed', String(mode === 'prose'));
        modeButtons.poetry.classList.toggle('active', mode === 'poetry');
        modeButtons.prose.classList.toggle('active', mode === 'prose');
        authorSection.hidden = false;
        latinSection.hidden = false;
        examineBtn.disabled = latinInput.value.trim().length === 0;
        resetAnalysisState();
    }

    function resetAnalysisState() {
        analysisOutput.hidden = true;
        grammarSection.hidden = true;
        translationSection.hidden = true;
        translationInput.value = '';
        translationFeedback.textContent = '';
        translationInput.classList.remove('translation-correct', 'translation-incorrect');
    }

    // Input handling with 50-word cap
    function tokenizeForCount(text) {
        const matches = text.match(/\p{L}+[\p{L}\-]*|\d+/gu) || [];
        return matches;
    }

    function updateWordCount() {
        const tokens = tokenizeForCount(latinInput.value);
        wordCount.textContent = `${tokens.length}/50 words`;
        examineBtn.disabled = tokens.length === 0;
    }

    function enforceCap(e) {
        const tokens = tokenizeForCount(latinInput.value);
        if (tokens.length > 50) {
            inputWarning.textContent = 'Limit is 50 words. Extra input was not added.';
            latinInput.value = STATE.lastValidLatin;
            setTimeout(() => inputWarning.textContent = '', 2000);
        } else {
            STATE.lastValidLatin = latinInput.value;
        }
        updateWordCount();
        if (STATE.overlayActive) hideOverlayForEditing();
        // Reset button to Examine! on any edit
        examineBtn.textContent = 'Examine!';
        examineBtn.disabled = tokenizeForCount(latinInput.value).length === 0;
    }

    latinInput.addEventListener('input', enforceCap);
    latinInput.addEventListener('focus', hideOverlayForEditing);

    // Examine -> analyze -> Ready
    examineBtn.addEventListener('click', async () => {
        if (examineBtn.disabled) return;
        examineBtn.disabled = true;
        examineBtn.textContent = 'Analyzing…';
        const text = latinInput.value;
        await new Promise(r => setTimeout(r, 30));
        const analysis = await analyzeWithAPI(text, {
            mode: STATE.mode,
            author: (authorInput.value || '').trim()
        });
        STATE.tokens = analysis.tokens;
        STATE.groups = analysis.groups;
        STATE.grammar = analysis.grammar;
        STATE.baselineEnglish = analysis.baselineEnglish;

        renderOverlay(text, STATE.tokens, STATE.groups);
        renderGrammar(STATE.grammar);

        analysisOutput.hidden = false;
        grammarSection.hidden = false;
        translationSection.hidden = false;
        examineBtn.textContent = 'Ready!';
        STATE.overlayActive = true;
    });

    // Tooltips
    const tooltip = createTooltip();

    function createTooltip() {
        const el = document.createElement('div');
        el.className = 'tooltip';
        el.style.display = 'none';
        document.body.appendChild(el);
        return el;
    }

    function showTooltip(html, x, y) {
        tooltip.innerHTML = html;
        tooltip.style.left = Math.max(12, x + 12) + 'px';
        tooltip.style.top = Math.max(12, y + 12) + 'px';
        tooltip.style.display = 'block';
    }

    function hideTooltip() {
        tooltip.style.display = 'none';
    }

    // Overlay rendering
    function renderOverlay(rawText, tokens, groups) {
        // Build a map from token index to group/color and tooltip
        const tokenMeta = new Map();
        const palette = COLOR_PALETTE;
        groups.forEach((g, idx) => {
            g.tokens.forEach(ti => {
                tokenMeta.set(ti, {
                    color: palette[idx % palette.length],
                    name: g.name
                });
            });
        });

        // Replace words with spans in order using regex
        let idx = 0;
        const overlayParts = [];
        const renderedParts = [];
        const regex = /\p{L}+[\p{L}\-]*/gu;
        let lastIndex = 0;
        let m;
        while ((m = regex.exec(rawText)) !== null) {
            const [word] = m;
            const spaceBefore = escapeHtml(rawText.slice(lastIndex, m.index));
            overlayParts.push(spaceBefore);
            renderedParts.push(spaceBefore);
            
            const t = tokens[idx] || null;
            const meta = tokenMeta.get(idx);
            const tooltipHtml = buildTooltipHtml(t);
            
            // For overlay: NO background highlighting, just tooltips
            overlayParts.push(`<span class="token" data-ti="${idx}">${escapeHtml(word)}</span>`);
            
            // For rendered text (Translation Chunks): WITH background highlighting
            const style = meta ? `style="background:${meta.color}33"` : '';
            const cls = meta ? 'token highlight' : 'token';
            renderedParts.push(`<span class="${cls}" data-ti="${idx}" ${style}>${escapeHtml(word)}</span>`);
            
            attachTokenHover(idx, tooltipHtml);
            idx++;
            lastIndex = regex.lastIndex;
        }
        const finalText = escapeHtml(rawText.slice(lastIndex));
        overlayParts.push(finalText);
        renderedParts.push(finalText);
        
        latinOverlay.innerHTML = overlayParts.join('');
        latinOverlay.style.display = 'block';
        latinOverlay.style.pointerEvents = 'auto';
        latinOverlay.setAttribute('aria-hidden', 'false');
        latinInput.classList.add('overlay-active');
        STATE.overlayActive = true;

        // Also render a read-only copy below for accessibility with highlighting
        renderedText.innerHTML = renderedParts.join('');
        bindRenderedTextTooltips();
    }

    function hideOverlayForEditing() {
        if (!STATE.overlayActive) return;
        latinOverlay.style.display = 'none';
        latinOverlay.style.pointerEvents = 'none';
        latinOverlay.setAttribute('aria-hidden', 'true');
        latinInput.classList.remove('overlay-active');
        STATE.overlayActive = false;
        hideTooltip();
        examineBtn.textContent = 'Examine!';
        examineBtn.disabled = tokenizeForCount(latinInput.value).length === 0;
    }

    function bindRenderedTextTooltips() {
        renderedText.querySelectorAll('.token').forEach(el => {
            const ti = Number(el.getAttribute('data-ti'));
            const t = STATE.tokens[ti];
            const html = buildTooltipHtml(t);
            el.addEventListener('mouseenter', (e) => showTooltip(html, e.clientX, e.clientY));
            el.addEventListener('mousemove', (e) => showTooltip(html, e.clientX, e.clientY));
            el.addEventListener('mouseleave', hideTooltip);
            el.addEventListener('click', (e) => {
                if (tooltip.style.display === 'block') { hideTooltip(); }
                else { showTooltip(html, e.clientX, e.clientY); }
            });
            el.addEventListener('focus', (e) => showTooltip(html, e.clientX || 0, e.clientY || 0));
            el.addEventListener('blur', hideTooltip);
            el.setAttribute('tabindex', '0');
        });
    }

    function attachTokenHover(index, html) {
        // Defer until after insert by event delegation on overlay
        // We'll add one-time listener to overlay
        if (!latinOverlay._bound) {
            latinOverlay.addEventListener('mouseover', tokenHoverHandler);
            latinOverlay.addEventListener('mousemove', tokenHoverHandler);
            latinOverlay.addEventListener('mouseout', tokenHoverOut);
            latinOverlay.addEventListener('click', tokenHoverHandler);
            latinOverlay._bound = true;
        }
    }

    function tokenHoverHandler(e) {
        const target = e.target.closest('.token');
        if (!target) {
            hideTooltip();
            return;
        }
        const ti = Number(target.getAttribute('data-ti'));
        const t = STATE.tokens[ti];
        if (!t) return;
        const html = buildTooltipHtml(t);
        showTooltip(html, e.clientX, e.clientY);
    }

    function tokenHoverOut() {
        hideTooltip();
    }

    function buildTooltipHtml(t) {
        if (!t) return '';
        const def = t.definition || 'Unknown';
        const pos = t.pos || 'Unknown';
        let extra = '';
        if (pos === 'noun') {
            extra = t.features.case ? `, case: ${t.features.case}` : '';
        } else if (pos === 'verb') {
            extra = t.features.tense ? `, tense: ${t.features.tense}` : '';
        } else if (pos === 'adjective') {
            extra = '';
        } else if (pos === 'gerundive') {
            extra = t.features.case ? `, case: ${t.features.case}` : '';
        } else if (pos === 'participle') {
            extra = t.features.tense ? `, tense: ${t.features.tense}` : '';
        }
        return `<strong>${escapeHtml(t.original)}</strong><br>${escapeHtml(def)}<br><span class="hint">${pos}${extra}</span>`;
    }

    // Legend removed - Translation Chunks don't need labels

    function renderGrammar(grammar) {
        grammarList.innerHTML = '';
        if (!grammar.length) {
            const none = document.createElement('div');
            none.className = 'grammar-item';
            none.innerHTML = `<span class="grammar-name">None detected</span><span class="grammar-text"></span>`;
            grammarList.appendChild(none);
            return;
        }
        grammar.forEach(g => {
            const div = document.createElement('div');
            div.className = 'grammar-item';
            const name = document.createElement('span');
            name.className = 'grammar-name';
            name.textContent = g.name + ':';
            const text = document.createElement('span');
            text.className = 'grammar-text';
            text.textContent = `"${g.text}"`;
            div.appendChild(name);
            div.appendChild(text);
            grammarList.appendChild(div);
        });
    }

    // Semantic antonym/contradiction dictionary for translation validation
    const SEMANTIC_OPPOSITES = {
        'good': ['bad', 'evil', 'wicked', 'poor', 'terrible', 'awful', 'horrible'],
        'bad': ['good', 'excellent', 'wonderful', 'great', 'fine', 'nice'],
        'great': ['small', 'tiny', 'little', 'minor', 'insignificant'],
        'large': ['small', 'tiny', 'little', 'petite'],
        'small': ['large', 'big', 'great', 'huge', 'enormous', 'giant'],
        'long': ['short', 'brief'],
        'short': ['long', 'tall', 'lengthy'],
        'high': ['low', 'short'],
        'low': ['high', 'tall'],
        'new': ['old', 'ancient', 'aged'],
        'old': ['new', 'young', 'recent', 'modern'],
        'many': ['few', 'little', 'scarce'],
        'few': ['many', 'numerous', 'multiple'],
        'all': ['none', 'nothing'],
        'none': ['all', 'everything', 'some'],
        'first': ['last', 'final'],
        'last': ['first', 'initial'],
        'beautiful': ['ugly', 'hideous', 'repulsive'],
        'ugly': ['beautiful', 'pretty', 'handsome'],
        'brave': ['cowardly', 'fearful', 'timid'],
        'strong': ['weak', 'feeble', 'frail'],
        'weak': ['strong', 'powerful', 'mighty'],
        'happy': ['sad', 'unhappy', 'miserable', 'depressed'],
        'sad': ['happy', 'joyful', 'cheerful', 'glad'],
        'joyful': ['sad', 'sorrowful', 'miserable'],
        'famous': ['unknown', 'obscure'],
        'known': ['unknown', 'unfamiliar'],
        'unknown': ['known', 'famous', 'familiar'],
        'true': ['false', 'untrue', 'fake'],
        'false': ['true', 'genuine', 'real'],
        'just': ['unjust', 'unfair'],
        'holy': ['unholy', 'profane', 'evil'],
        'sacred': ['profane', 'secular'],
        'free': ['enslaved', 'bound', 'captive'],
        'heavy': ['light', 'weightless'],
        'light': ['heavy', 'dark'],
        'hard': ['soft', 'easy'],
        'soft': ['hard', 'firm', 'rigid'],
        'fast': ['slow', 'sluggish'],
        'slow': ['fast', 'quick', 'swift', 'rapid'],
        'wise': ['foolish', 'stupid', 'unwise'],
        'foolish': ['wise', 'smart', 'intelligent'],
        'divine': ['mortal', 'human', 'earthly'],
        'human': ['divine', 'godly'],
        'public': ['private', 'personal'],
        'private': ['public', 'common'],
        'eternal': ['temporary', 'mortal', 'fleeting'],
        'love': ['hate', 'loathe', 'despise'],
        'hate': ['love', 'adore', 'cherish'],
        'war': ['peace'],
        'peace': ['war', 'conflict', 'battle'],
        'life': ['death'],
        'death': ['life', 'birth'],
        'day': ['night'],
        'night': ['day'],
        'light': ['darkness', 'dark'],
        'dark': ['light', 'bright'],
        'friend': ['enemy', 'foe'],
        'enemy': ['friend', 'ally'],
        'master': ['slave', 'servant'],
        'slave': ['master', 'lord', 'free'],
        'hope': ['despair', 'hopelessness'],
        'courage': ['cowardice', 'fear'],
        'virtue': ['vice', 'evil'],
        'glory': ['shame', 'disgrace'],
        'joy': ['sorrow', 'grief', 'sadness'],
        'pain': ['pleasure', 'comfort'],
        'always': ['never'],
        'never': ['always', 'forever'],
        'often': ['rarely', 'seldom'],
        'well': ['badly', 'poorly'],
        'badly': ['well', 'nicely'],
        'come': ['go', 'leave'],
        'go': ['come', 'arrive', 'stay'],
        'arrive': ['depart', 'leave'],
        'give': ['take', 'receive'],
        'take': ['give'],
        'open': ['close', 'shut'],
        'close': ['open'],
        'up': ['down'],
        'down': ['up'],
        'in': ['out'],
        'out': ['in'],
        'before': ['after'],
        'after': ['before'],
        'with': ['without'],
        'without': ['with']
    };

    // Stop words that don't carry much semantic meaning
    const STOP_WORDS = new Set(['the', 'a', 'an', 'is', 'are', 'was', 'were', 'am', 'be', 'been', 
        'have', 'has', 'had', 'do', 'does', 'did', 'will', 'would', 'should', 'could', 'may', 'might',
        'can', 'to', 'of', 'in', 'on', 'at', 'by', 'for', 'from', 'with', 'about', 'as', 'into',
        'through', 'during', 'before', 'after', 'above', 'below', 'between', 'under', 'again',
        'further', 'then', 'once', 'here', 'there', 'when', 'where', 'why', 'how', 'all', 'both',
        'each', 'more', 'most', 'other', 'some', 'such', 'no', 'nor', 'not', 'only', 'own', 'same',
        'so', 'than', 'too', 'very', 'just', 'but', 'if', 'or', 'because', 'while', 'who', 'which',
        'this', 'that', 'these', 'those', 'my', 'your', 'his', 'her', 'its', 'our', 'their']);

    // Translation evaluation with sophisticated grammatical analysis
    checkTranslationBtn.addEventListener('click', () => {
        const userTranslation = translationInput.value || '';
        
        if (!STATE.tokens || STATE.tokens.length === 0) {
            translationFeedback.textContent = 'Run Examine! first to analyze the Latin.';
            return;
        }

        // Perform sophisticated structural analysis
        const result = advancedTranslationCheck(STATE.tokens, userTranslation);
        
        translationInput.classList.toggle('translation-correct', result.isCorrect);
        translationInput.classList.toggle('translation-incorrect', !result.isCorrect);
        
        // Determine validation type for feedback
        const validationType = result.validationType || 'structural';
        translationFeedback.textContent = result.isCorrect ? 
            `Correct (${validationType} match) ✔` : 
            `Not quite — ${result.reason} ✘`;
    });

    function advancedTranslationCheck(latinTokens, englishText) {
        // Parse Latin sentence structure
        const latinStructure = parseLatinStructure(latinTokens);
        
        // Parse English sentence structure  
        const englishStructure = parseEnglishStructure(englishText);
        
        // Check if this is a complex multi-clause sentence
        // Complex sentences have: relative pronouns, multiple finite verbs, or many clauses
        const hasRelativePronouns = latinTokens.some(t => {
            const word = t.normalized.toLowerCase();
            return ['qui', 'quae', 'quod', 'quem', 'quam', 'quorum', 'quarum', 'quibus', 'quo', 'qua'].includes(word);
        });
        
        const multipleVerbs = latinStructure.allVerbs && latinStructure.allVerbs.length > 2;
        const longSentence = latinTokens.length > 15;
        
        // For complex sentences, use semantic validation instead of strict structural validation
        if (hasRelativePronouns && (multipleVerbs || longSentence)) {
            const result = semanticValidation(latinTokens, englishText, englishStructure);
            result.validationType = 'semantic';
            return result;
        }
        
        // For simple sentences, use strict structural validation
        const result = validateStructuralMatch(latinStructure, englishStructure);
        result.validationType = 'structural';
        return result;
    }
    
    function semanticValidation(latinTokens, englishText, englishStructure) {
        // Extract key Latin words (nouns, verbs, adjectives)
        let latinKeyWords = latinTokens
            .filter(t => ['noun', 'verb', 'adjective', 'pronoun'].includes(t.pos))
            .map(t => normalizeWord(t.definition || ''))
            .filter(w => w && w !== 'unknown');

        if (englishStructure.prepositionalPhrases && englishStructure.prepositionalPhrases.length) {
            englishStructure.prepositionalPhrases.forEach(phrase => {
                phrase.split(/\s+/).forEach(part => {
                    const normalized = normalizeWord(part);
                    if (normalized && !STOP_WORDS.has(normalized)) {
                        latinKeyWords.push(normalized);
                    }
                });
            });
        }
        
        // Extract English words
        const englishWords = (englishStructure.allWords || [])
            .map(w => normalizeWord(w))
            .filter(w => !STOP_WORDS.has(w));
        
        // Check what percentage of Latin key words appear in English
        let matchCount = 0;
        for (const latinWord of latinKeyWords) {
            // Check if this Latin word (or a related form) appears in English
            const found = englishWords.some(engWord => {
                return wordsMatch(latinWord, engWord);
            });
            if (found) {
                matchCount++;
            }
        }
        
        const coverage = latinKeyWords.length > 0 ? matchCount / latinKeyWords.length : 0;
        
        // Require at least 60% coverage for complex sentences (more lenient)
        if (coverage >= 0.6) {
            return { isCorrect: true, reason: '' };
        } else {
            return {
                isCorrect: false,
                reason: `incomplete translation (only ${Math.round(coverage * 100)}% of key words translated)`
            };
        }
    }

    // Helper function to determine verb person and number from ending
    function getVerbPersonNumber(verbToken) {
        const word = verbToken.normalized;
        const original = verbToken.original;
        
        // Check endings in order of specificity (most specific first)
        
        // First person plural: -mus ending
        if (/mus$/i.test(word)) {
            return { person: 1, number: 'plural', expectedSubject: 'we' };
        }
        
        // Second person plural: -tis ending
        if (/tis$/i.test(word)) {
            return { person: 2, number: 'plural', expectedSubject: 'you' };
        }
        
        // Third person plural: -nt ending
        if (/nt$/i.test(word)) {
            return { person: 3, number: 'plural', expectedSubject: 'they' };
        }
        
        // Third person singular: -t ending (but not -nt which was already checked)
        if (/t$/i.test(word) && !/nt$/i.test(word)) {
            return { person: 3, number: 'singular', expectedSubject: 'he/she/it' };
        }
        
        // Second person singular: -s ending (not -us, -is, -mus, -tis)
        if (/s$/i.test(word) && !/us$/i.test(word) && !/is$/i.test(word) && !/mus$/i.test(word) && !/tis$/i.test(word)) {
            return { person: 2, number: 'singular', expectedSubject: 'you' };
        }
        
        // First person singular: -o or -m endings (standard Latin present active indicative)
        // This catches all regular -o ending verbs (amo, constituo, puto, video, etc.)
        if (/[om]$/i.test(word)) {
            return { person: 1, number: 'singular', expectedSubject: 'I' };
        }
        
        // Default to third person singular for unknown
        return { person: 3, number: 'singular', expectedSubject: 'he/she/it' };
    }

    function parseLatinStructure(tokens) {
        const structure = {
            subject: null,
            subjectModifiers: [],
            verb: null,
            object: null,
            objectModifiers: [],
            prepositionalPhrases: [],
            hasInfinitive: false,
            isIndirectStatement: false,
            isDirectSpeech: false,
            infinitiveSubject: null,
            infinitiveVerb: null,
            infinitiveObject: null,
            mainVerbPerson: null,
            mainVerbNumber: null,
            mainVerbExpectedSubject: null,
            allNouns: [],
            allVerbs: [],
            allInfinitives: [],
            prepositionalTokenIndices: new Set()
        };
        const prepTokenIndices = structure.prepositionalTokenIndices;

        // First pass: identify all nouns, verbs, infinitives, and simple prepositional phrases
        tokens.forEach((token, idx) => {
            token.originalStart = token.start;
            token.originalEnd = token.end;
            if (token.pos === 'noun' || token.pos === 'pronoun' || token.pos === 'proper-noun') {
                structure.allNouns.push({ token, idx, case: token.features.case });
            }
            if (token.pos === 'verb') {
                if (token.features.tense === 'infinitive') {
                    structure.allInfinitives.push({ token, idx, definition: token.definition });
                    structure.hasInfinitive = true;
                } else {
                    structure.allVerbs.push({ token, idx, definition: token.definition });
                }
            }
            if (token.pos === 'preposition') {
                const phraseEntries = [{ token, idx }];
                for (let j = idx + 1; j < tokens.length; j++) {
                    const next = tokens[j];
                    if (next.pos === 'preposition') break;
                    phraseEntries.push({ token: next, idx: j });
                    if (next.pos === 'noun' || next.pos === 'pronoun') break;
                }
                const phraseDefs = phraseEntries
                    .map(entry => {
                        const t = entry.token;
                        return (t.definition && t.definition !== 'unknown') ? t.definition : (t.original || t.normalized);
                    })
                    .filter(Boolean);
                if (phraseEntries.length > 1) {
                    structure.prepositionalPhrases.push({
                        tokens: phraseEntries.map(entry => entry.token),
                        english: phraseDefs.join(' ')
                    });
                    phraseEntries.forEach(entry => prepTokenIndices.add(entry.idx));
                }
            }
        });

        // HEAD VERBS that take indirect statement (acc + inf)
        const indirectStatementVerbs = new Set(['say', 'think', 'believe', 'see', 'hear', 'know', 
            'perceive', 'learn', 'report', 'tell', 'show', 'teach', 'feel', 'understand', 'hope']);
        
        // IMPERSONAL VERBS that take acc + inf
        const impersonalVerbs = new Set(['be necessary', 'be fitting', 'please', 'be proper']);
        
        // COMMAND/PERMISSION VERBS that take acc + inf
        const commandVerbs = new Set(['order', 'command', 'forbid', 'allow', 'permit', 'force', 'compel']);

        // Check if we have an infinitive construction
        if (structure.hasInfinitive && structure.allInfinitives.length > 0) {
            const infIdx = structure.allInfinitives[0].idx;
            
            // Find the main finite verb
            let mainVerb = null;
            let mainVerbIdx = -1;
            for (const v of structure.allVerbs) {
                if (v.idx < infIdx) {  // Verb before infinitive
                    mainVerb = v;
                    mainVerbIdx = v.idx;
                    break;
                }
            }

            // Check if main verb is an indirect statement head
            if (mainVerb) {
                const mainVerbDef = normalizeWord(mainVerb.definition || '');
                const isIndirectHead = indirectStatementVerbs.has(mainVerbDef) || 
                                      impersonalVerbs.has(mainVerbDef) ||
                                      commandVerbs.has(mainVerbDef);

                if (isIndirectHead) {
                    structure.isIndirectStatement = true;
                    
                    // Main verb of the sentence
                    structure.verb = mainVerb;
                    
                    // Detect person and number of main verb
                    const personInfo = getVerbPersonNumber(mainVerb.token);
                    structure.mainVerbPerson = personInfo.person;
                    structure.mainVerbNumber = personInfo.number;
                    structure.mainVerbExpectedSubject = personInfo.expectedSubject;
                    
                    // Find subject of infinitive (accusative before infinitive)
                    let accBeforeInf = null;
                    let secondAcc = null;
                    
                    for (const noun of structure.allNouns) {
                        if (noun.case && /acc/i.test(noun.case)) {
                            if (noun.idx > mainVerbIdx && noun.idx < infIdx) {
                                // Accusative between main verb and infinitive = subject of infinitive
                                if (!accBeforeInf) {
                                    accBeforeInf = noun;
                                } else {
                                    secondAcc = noun;
                                }
                            } else if (noun.idx > infIdx) {
                                // Accusative after infinitive = object of infinitive
                                secondAcc = noun;
                            }
                        }
                    }
                    
                    if (accBeforeInf) {
                        structure.infinitiveSubject = { 
                            token: accBeforeInf.token, 
                            idx: accBeforeInf.idx, 
                            definition: accBeforeInf.token.definition 
                        };
                        structure.subject = structure.infinitiveSubject; // For translation checking
                    }
                    
                    structure.infinitiveVerb = structure.allInfinitives[0];
                    
                    if (secondAcc) {
                        structure.infinitiveObject = {
                            token: secondAcc.token,
                            idx: secondAcc.idx,
                            definition: secondAcc.token.definition
                        };
                        structure.object = structure.infinitiveObject;
                    }
                    
                    // Find subject of main verb (nominative, if any)
                    for (const noun of structure.allNouns) {
                        if (noun.case && /nom/i.test(noun.case)) {
                            if (noun.idx < mainVerbIdx) {
                                // This would be subject of main verb, but we focus on infinitive clause
                                break;
                            }
                        }
                    }
                }
            }
        }

        // Check for direct speech (reporting verb + finite verb, no infinitive)
        // e.g., "inquit, 'orator sum'" = He says, "I am an orator"
        let isDirectSpeech = false;
        if (!structure.hasInfinitive && structure.allVerbs.length > 1) {
            // Check if first verb is a reporting verb
            const firstVerb = structure.allVerbs[0];
            const firstVerbDef = normalizeWord(firstVerb.definition || '');
            
            // Check if definition contains any reporting verb (not exact match)
            const isReportingVerb = Array.from(indirectStatementVerbs).some(verb => 
                firstVerbDef.includes(verb)
            );
            
            if (isReportingVerb) {
                // Check if second verb is a finite form of "sum" (common in direct speech)
                const secondVerb = structure.allVerbs[1];
                const secondVerbWord = secondVerb.token.normalized;
                if (/^(sum|es|est|sumus|estis|sunt)$/i.test(secondVerbWord)) {
                    isDirectSpeech = true;
                    structure.isDirectSpeech = true;
                    // For direct speech, use the reporting verb as the main verb
                    structure.verb = firstVerb;
                    // Don't validate the structure of the quoted speech
                }
            }
        }

        // If NOT an indirect statement and NOT direct speech, use traditional parsing
        if (!structure.isIndirectStatement && !isDirectSpeech) {
            // Find nominative noun as subject
            for (const noun of structure.allNouns) {
                if (prepTokenIndices.has(noun.idx)) continue;
                if (noun.case && /nom/i.test(noun.case) && noun.token.definition && noun.token.definition !== 'unknown') {
                    structure.subject = { 
                        token: noun.token, 
                        idx: noun.idx, 
                        definition: noun.token.definition 
                    };
                    break; // Take first nominative with definition
                }
            }

            // Find accusative noun as object
            for (const noun of structure.allNouns) {
                if (prepTokenIndices.has(noun.idx)) continue;
                if (noun.case && /acc/i.test(noun.case)) {
                    // Skip if this accusative is already used as infinitive subject
                    if (structure.infinitiveSubject && noun.idx === structure.infinitiveSubject.idx) {
                        continue;
                    }
                    structure.object = { 
                        token: noun.token, 
                        idx: noun.idx, 
                        definition: noun.token.definition 
                    };
                    break; // Take first accusative
                }
            }

            // Find main finite verb
            if (structure.allVerbs.length > 0) {
                structure.verb = structure.allVerbs[0];
            }
        }

        // Identify modifiers (adjectives near subject and object)
        tokens.forEach((token, idx) => {
            if (token.pos === 'adjective' || token.pos === 'gerundive') {
                // Check if it modifies the subject
                if (structure.subject && Math.abs(idx - structure.subject.idx) <= 2) {
                    if (token.features.case && structure.subject.token.features.case &&
                        sameCaseBucket(token.features.case, structure.subject.token.features.case)) {
                        structure.subjectModifiers.push({ token, idx, definition: token.definition });
                    }
                }
                // Check if it modifies the object
                if (structure.object && Math.abs(idx - structure.object.idx) <= 2) {
                    if (token.features.case && structure.object.token.features.case &&
                        sameCaseBucket(token.features.case, structure.object.token.features.case)) {
                        structure.objectModifiers.push({ token, idx, definition: token.definition });
                    }
                }
            }
        });

        return structure;
    }

    function parseEnglishStructure(text) {
        const originalWords = text.match(/\b[\w']+\b/g) || [];
        const words = originalWords.map(w => w.toLowerCase());
        const structure = {
            subject: null,
            subjectModifiers: [],
            verb: null,
            object: null,
            objectModifiers: [],
            hasSubordinateClause: false,
            mainClauseSubject: null,
            mainClauseVerb: null,
            subordinateUsesInfinitive: false,
            prepositionalPhrases: [],
            allWords: words
        };
        const prepositionWords = ['for','in','on','at','by','with','from','into','onto','over','under','after','before','toward','towards'];
        const skipIndices = new Set();

        function isCandidateNoun(index) {
            const word = words[index];
            if (!word) return false;
            if (pronounWords.includes(word) || nounWords.includes(word)) return true;
            if (STOP_WORDS.has(word)) return false;
            if (verbPatterns.test(word)) return false;
            const original = originalWords[index] || word;
            if (/^[A-Z]/.test(original)) return true;
            return word.length > 3;
        }

        // Capture simple prepositional phrases such as "for accomplishing", "in the house"
        for (let i = 0; i < words.length - 1; i++) {
            const current = words[i];
            if (prepositionWords.includes(current)) {
                const phraseParts = [current];
                skipIndices.add(i);
                const nextWord = words[i + 1];
                if (nextWord) {
                    phraseParts.push(nextWord);
                    skipIndices.add(i + 1);
                    // include one more non-stop word if available
                    if (i + 2 < words.length) {
                        const third = words[i + 2];
                        if (!STOP_WORDS.has(third)) {
                            phraseParts.push(third);
                            skipIndices.add(i + 2);
                        }
                    }
                }
                structure.prepositionalPhrases.push(phraseParts.join(' '));
            }
        }


        // Noun and adjective word lists
        const nounWords = ['father', 'mother', 'son', 'daughter', 'man', 'woman', 'boy', 'girl', 
            'king', 'queen', 'leader', 'soldier', 'god', 'goddess', 'friend', 'brother', 'sister',
            'master', 'slave', 'city', 'people', 'war', 'peace', 'teacher', 'student', 'child',
            'servant', 'lord', 'enemy', 'citizen', 'orator', 'speaker', 'senator', 'general',
            'commander', 'philosopher', 'poet', 'hero', 'warrior', 'slave', 'thing', 'things'];
        
        const pronounWords = ['i', 'you', 'he', 'she', 'it', 'we', 'they', 'me', 'him', 'her', 'us', 'them',
            'myself', 'yourself', 'himself', 'herself', 'itself', 'ourselves', 'themselves',
            'this', 'that', 'these', 'those'];
        
        const adjectiveWords = ['good', 'bad', 'great', 'small', 'beautiful', 'brave', 'wise', 
            'happy', 'sad', 'old', 'new', 'young', 'strong', 'weak'];

        // Common verb forms
        const verbPatterns = /(be|am|is|are|was|were|been|being|love|loves|loved|loving|hate|hates|hated|see|sees|saw|seen|give|gives|gave|given|take|takes|took|taken|come|comes|came|go|goes|went|gone|lead|leads|led|send|sends|sent|call|calls|called|carry|carries|carried|teach|teaches|taught|fear|fears|feared|believe|believes|believed|say|says|said|think|thinks|thought|know|knows|knew|known|do|does|did|done|make|makes|made|have|has|had|order|orders|ordered|tell|tells|told|show|shows|showed|shown|hear|hears|heard|decide|decides|decided|establish|establishes|established|determine|determines|determined|resolve|resolves|resolved)/;

        // Reporting verbs that take indirect statements
        const reportingVerbsList = ['say', 'says', 'said', 'think', 'thinks', 'thought', 'believe', 'believes', 'believed', 
            'know', 'knows', 'knew', 'see', 'sees', 'saw', 'hear', 'hears', 'heard', 'tell', 'tells', 'told',
            'show', 'shows', 'showed', 'report', 'reports', 'reported', 'claim', 'claims', 'claimed'];
        
        // Check for "that" clause (indirect statement)
        const thatIdx = words.indexOf('that');
        
        // Also check for accusative + infinitive pattern (e.g., "says himself to be")
        let hasAccInfinitive = false;
        let reportingVerbIdx = -1;
        let accInfinitiveSubject = null;
        let accInfinitiveVerb = null;
        
        // Look for reporting verb followed by pronoun/noun + "to" + verb
        for (let i = 0; i < words.length - 2; i++) {
            if (reportingVerbsList.includes(words[i])) {
                // Check if followed by pronoun/noun + "to" + verb
                const nextWord = words[i + 1];
                const toIdx = i + 2;
                
                if (words[toIdx] === 'to' && (pronounWords.includes(nextWord) || nounWords.includes(nextWord))) {
                    // Found accusative + infinitive pattern
                    hasAccInfinitive = true;
                    reportingVerbIdx = i;
                    accInfinitiveSubject = nextWord;
                    
                    // Find the infinitive verb after "to"
                    if (toIdx + 1 < words.length && verbPatterns.test(words[toIdx + 1])) {
                        // Store as full infinitive "to verb"
                        accInfinitiveVerb = 'to ' + words[toIdx + 1];
                    }
                    break;
                }
            }
        }
        
        if (thatIdx !== -1) {
            structure.hasSubordinateClause = true;
            
            // First, extract the MAIN CLAUSE (before "that")
            // Find main clause verb (before "that")
            for (let i = 0; i < thatIdx; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.mainClauseVerb = words[i];
                    
                    // Find main clause subject (before main verb or after, if it exists)
                    for (let j = 0; j < thatIdx; j++) {
                        if (skipIndices.has(j)) continue;
                        if (pronounWords.includes(words[j]) || nounWords.includes(words[j])) {
                            structure.mainClauseSubject = words[j];
                            break;
                        }
                    }
                    break;
                }
            }
            
            // Then extract the SUBORDINATE CLAUSE (after "that")
            // Find verb after "that"
            let subordinateVerbIdx = -1;
            for (let i = thatIdx + 1; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.verb = words[i];
                    subordinateVerbIdx = i;
                    
                    // Check if there's "to" immediately before the verb (infinitive construction)
                    if (i > 0 && words[i - 1] === 'to') {
                        structure.subordinateUsesInfinitive = true;
                    }
                    break;
                }
            }
            
            // Find subject between "that" and subordinate verb
            if (subordinateVerbIdx !== -1) {
                for (let i = thatIdx + 1; i < subordinateVerbIdx; i++) {
                    if (skipIndices.has(i)) continue;
                    if (isCandidateNoun(i)) {
                        structure.subject = words[i];
                        
                        // Look for modifiers before this noun (after "that")
                        for (let j = thatIdx + 1; j < i; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.subjectModifiers.push(words[j]);
                            }
                        }
                        break;
                    }
                }
                
                // Find object after subordinate verb
                for (let i = subordinateVerbIdx + 1; i < words.length; i++) {
                    if (skipIndices.has(i)) continue;
                    if (isCandidateNoun(i)) {
                        structure.object = words[i];
                        
                        // Look for modifiers
                        for (let j = subordinateVerbIdx + 1; j < i; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.objectModifiers.push(words[j]);
                            }
                        }
                        for (let j = i + 1; j < words.length && (j - i) <= 2; j++) {
                            if (adjectiveWords.includes(words[j])) {
                                structure.objectModifiers.push(words[j]);
                            }
                        }
                        break;
                    }
                }
            }
        } else if (hasAccInfinitive) {
            // Accusative + Infinitive construction (e.g., "He says himself to be an orator")
            structure.hasSubordinateClause = true;
            
            // Set main clause verb (the reporting verb)
            structure.mainClauseVerb = words[reportingVerbIdx];
            
            // Find main clause subject (before the reporting verb)
            for (let i = 0; i < reportingVerbIdx; i++) {
                if (pronounWords.includes(words[i]) || nounWords.includes(words[i])) {
                    structure.mainClauseSubject = words[i];
                    break;
                }
            }
            
            // Map reflexive pronouns to subject forms for comparison
            const reflexiveMap = {
                'myself': 'i',
                'yourself': 'you',
                'himself': 'he',
                'herself': 'she',
                'itself': 'it',
                'ourselves': 'we',
                'yourselves': 'you',
                'themselves': 'they'
            };
            
            // Set subordinate clause subject (the accusative subject of infinitive)
            // Keep the actual pronoun form (don't map reflexives to personal pronouns)
            structure.subject = accInfinitiveSubject;
            
            // Set subordinate clause verb (the infinitive)
            structure.verb = accInfinitiveVerb;
            
            // Look for object after the infinitive verb
            const toIdx = reportingVerbIdx + 2; // position of "to"
            const infVerbIdx = toIdx + 1; // position of infinitive verb
            
            // Skip articles when looking for object
            const articles = ['a', 'an', 'the'];
            
            for (let i = infVerbIdx + 1; i < words.length; i++) {
                // Skip articles
                if (articles.includes(words[i])) {
                    continue;
                }
                
                if (nounWords.includes(words[i]) || pronounWords.includes(words[i])) {
                    structure.object = words[i];
                    
                    // Look for modifiers (adjectives, but not articles)
                    for (let j = infVerbIdx + 1; j < i; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }
        } else {
            // Simple sentence without "that" or acc+inf - use original logic
            // Find verb position
            let verbIdx = -1;
            for (let i = 0; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (verbPatterns.test(words[i])) {
                    structure.verb = words[i];
                    verbIdx = i;
                    
                    // Check if there's "to" immediately before the verb (might be indirect statement without "that")
                    if (i > 0 && words[i - 1] === 'to') {
                        // Could be an infinitive in a sentence that should use "that"
                        structure.subordinateUsesInfinitive = true;
                    }
                    break;
                }
            }

            if (verbIdx === -1) {
                // No clear verb found
                return structure;
            }

            // Look for subject before verb
            for (let i = verbIdx - 1; i >= 0; i--) {
                if (skipIndices.has(i)) continue;
                if (isCandidateNoun(i)) {
                    structure.subject = words[i];
                    
                    // Look for modifiers before this noun
                    for (let j = i - 1; j >= 0 && (i - j) <= 3; j--) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.subjectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }

            // Look for object after verb
            for (let i = verbIdx + 1; i < words.length; i++) {
                if (skipIndices.has(i)) continue;
                if (isCandidateNoun(i)) {
                    structure.object = words[i];
                    
                    // Look for modifiers
                    for (let j = verbIdx + 1; j < i; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    for (let j = i + 1; j < words.length && (j - i) <= 2; j++) {
                        if (adjectiveWords.includes(words[j])) {
                            structure.objectModifiers.push(words[j]);
                        }
                    }
                    break;
                }
            }
        }

        return structure;
    }

    function validateStructuralMatch(latinStruct, englishStruct) {
        const errors = [];

        // 0a. For direct speech, only validate the reporting verb, not the quoted content
        // e.g., "inquit, 'orator sum'" = "He says, 'I am an orator'"
        if (latinStruct.isDirectSpeech) {
            // Check if there's a reporting verb in the English
            const englishWords = englishStruct.allWords || [];
            const hasReportingVerb = englishWords.some(w => 
                ['say', 'says', 'said', 'tell', 'tells', 'told', 'ask', 'asks', 'asked'].includes(w)
            );
            
            if (!hasReportingVerb) {
                return {
                    isCorrect: false,
                    reason: 'missing reporting verb (e.g., "says", "said")'
                };
            }
            
            // Validate person/number of the reporting verb
            if (latinStruct.verb) {
                const personInfo = getVerbPersonNumber(latinStruct.verb.token);
                const expectedSubject = personInfo.expectedSubject.toLowerCase();
                
                // Find English subject (word before reporting verb)
                let englishSubject = null;
                for (let i = 0; i < englishWords.length; i++) {
                    if (['say', 'says', 'said', 'tell', 'tells', 'told', 'ask', 'asks', 'asked'].includes(englishWords[i])) {
                        if (i > 0) {
                            englishSubject = englishWords[i - 1].toLowerCase();
                        }
                        break;
                    }
                }
                
                // Check person/number agreement
                if (englishSubject) {
                    // For 3rd person singular: expect "he", "she", "it" (reject "they", "I", "we")
                    if (personInfo.person === 3 && personInfo.number === 'singular') {
                        if (englishSubject === 'they') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject number (Latin verb is singular, expected "he/she/it" not "they")'
                            };
                        } else if (['i', 'we', 'you'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 3rd person, expected "he/she/it")'
                            };
                        }
                    }
                    // For 3rd person plural: expect "they"
                    else if (personInfo.person === 3 && personInfo.number === 'plural') {
                        if (['he', 'she', 'it'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject number (Latin verb is plural, expected "they" not singular)'
                            };
                        } else if (['i', 'we'].includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 3rd person plural, expected "they")'
                            };
                        }
                    }
                    // For 1st person singular: expect "I"
                    else if (personInfo.person === 1 && personInfo.number === 'singular') {
                        if (englishSubject !== 'i') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 1st person singular, expected "I")'
                            };
                        }
                    }
                    // For 1st person plural: expect "we"
                    else if (personInfo.person === 1 && personInfo.number === 'plural') {
                        if (englishSubject !== 'we') {
                            return {
                                isCorrect: false,
                                reason: 'wrong subject person (Latin verb is 1st person plural, expected "we")'
                            };
                        }
                    }
                }
            }
            
            // Direct speech is correct if it has a reporting verb and correct person/number
            // Don't validate the internal structure of the quoted speech
            return { isCorrect: true };
        }

        // 0b. For simple sentences with no explicit subject, validate the subject implied by verb ending
        // This handles cases like "constituo" → "I decide" (not "she decides")
        if (!latinStruct.subject && latinStruct.verb && !latinStruct.isIndirectStatement && !latinStruct.isDirectSpeech) {
            // Get the person/number from the Latin verb
            const personInfo = getVerbPersonNumber(latinStruct.verb.token);
            
            // Get the English subject
            const englishSubject = (englishStruct.subject || englishStruct.mainClauseSubject || '').toLowerCase();
            
            if (englishSubject) {
                // Validate person/number agreement
                if (personInfo.person === 1 && personInfo.number === 'singular') {
                    if (englishSubject !== 'i') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 1st person singular, expected "I" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 2 && personInfo.number === 'singular') {
                    if (englishSubject !== 'you') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 2nd person singular, expected "you" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 3 && personInfo.number === 'singular') {
                    if (!['he', 'she', 'it'].includes(englishSubject)) {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 3rd person singular, expected "he/she/it" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 1 && personInfo.number === 'plural') {
                    if (englishSubject !== 'we') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 1st person plural, expected "we" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 2 && personInfo.number === 'plural') {
                    if (englishSubject !== 'you') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 2nd person plural, expected "you" but found "${englishSubject}")`
                        };
                    }
                } else if (personInfo.person === 3 && personInfo.number === 'plural') {
                    if (englishSubject !== 'they') {
                        return {
                            isCorrect: false,
                            reason: `wrong subject (Latin verb is 3rd person plural, expected "they" but found "${englishSubject}")`
                        };
                    }
                }
            }
        }

        // 0c. For indirect statements, first validate the MAIN CLAUSE
        if (latinStruct.isIndirectStatement && latinStruct.mainVerbExpectedSubject) {
            // Check if English incorrectly uses infinitive in subordinate clause
            // ONLY reject if using infinitive inside a "that" clause (should be finite verb)
            // ALLOW accusative + infinitive constructions without "that" (valid alternative)
            if (englishStruct.subordinateUsesInfinitive && englishStruct.hasSubordinateClause) {
                // Check if it has "that" - if so, shouldn't use infinitive after "that"
                const words = englishStruct.allWords || [];
                const hasThat = words.includes('that');
                
                if (hasThat) {
                    return {
                        isCorrect: false,
                        reason: 'incorrect infinitive form (use "he is" not "he to be" after "that")'
                    };
                }
                // If no "that", it's an acc+inf construction which is valid
            }
            
            if (!englishStruct.mainClauseSubject) {
                return {
                    isCorrect: false,
                    reason: 'missing main clause subject (e.g., "He says...")'
                };
            }
            
            const expectedSubject = latinStruct.mainVerbExpectedSubject.toLowerCase();
            const actualSubject = englishStruct.mainClauseSubject.toLowerCase();
            
            // Check if the subject matches based on person/number
            // For person 1 singular: expect "I"
            if (latinStruct.mainVerbPerson === 1 && latinStruct.mainVerbNumber === 'singular') {
                if (actualSubject !== 'i') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 1st person singular, expected "I" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 2 singular: expect "you"
            else if (latinStruct.mainVerbPerson === 2 && latinStruct.mainVerbNumber === 'singular') {
                if (actualSubject !== 'you') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 2nd person singular, expected "you" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 3 singular: expect "he", "she", "it", or a noun
            else if (latinStruct.mainVerbPerson === 3 && latinStruct.mainVerbNumber === 'singular') {
                if (!['he', 'she', 'it'].includes(actualSubject)) {
                    // If it's a noun, that's okay too - but should be singular
                    // For now, we'll be lenient and just reject first/second person pronouns
                    if (['i', 'we', 'you', 'they'].includes(actualSubject)) {
                        return {
                            isCorrect: false,
                            reason: `wrong main clause subject (Latin verb is 3rd person singular, expected "he/she/it" or a noun, but found "${englishStruct.mainClauseSubject}")`
                        };
                    }
                }
            }
            // For person 1 plural: expect "we"
            else if (latinStruct.mainVerbPerson === 1 && latinStruct.mainVerbNumber === 'plural') {
                if (actualSubject !== 'we') {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 1st person plural, expected "we" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
            // For person 3 plural: expect "they"
            else if (latinStruct.mainVerbPerson === 3 && latinStruct.mainVerbNumber === 'plural') {
                if (actualSubject !== 'they' && !['he', 'she', 'it'].includes(actualSubject)) {
                    return {
                        isCorrect: false,
                        reason: `wrong main clause subject (Latin verb is 3rd person plural, expected "they" but found "${englishStruct.mainClauseSubject}")`
                    };
                }
            }
        }

        // 1. Check subject match (subordinate clause or simple sentence)
        if (latinStruct.subject) {
            const latinSubjectDef = normalizeWord(latinStruct.subject.definition || '');
            const englishSubject = normalizeWord(englishStruct.subject || '');
            
            if (!englishSubject) {
                errors.push('missing subject');
            } else {
                // Special handling for reflexive pronouns
                // Latin "se" (himself/herself/itself/themselves) must refer back to main clause subject
                const isReflexive = latinSubjectDef.includes('himself') || latinSubjectDef.includes('herself') || 
                                   latinSubjectDef.includes('itself') || latinSubjectDef.includes('themselves');
                
                if (isReflexive) {
                    // For reflexive pronouns, the subordinate subject MUST be in reflexive form
                    const mainSubject = normalizeWord(englishStruct.mainClauseSubject || '');
                    
                    // If we don't have a main clause subject, this might be a simple sentence with reflexive
                    // In that case, still require a reflexive form
                    if (!mainSubject) {
                        const isReflexiveForm = ['himself', 'herself', 'itself', 'themselves', 'myself', 'yourself', 'ourselves', 'yourselves'].includes(englishSubject);
                        if (!isReflexiveForm) {
                            return {
                                isCorrect: false,
                                reason: `reflexive pronoun required (Latin "se" must be translated as "himself/herself/itself/themselves", not "${englishStruct.subject}")`
                            };
                        }
                    } else {
                        // We have a main subject, so validate proper reflexive matching
                        // Mapping: main subject → ONLY reflexive forms allowed
                        const reflexiveExpected = {
                            'he': ['himself'],
                            'she': ['herself'],
                            'it': ['itself'],
                            'they': ['themselves'],
                            'i': ['myself'],
                            'you': ['yourself', 'yourselves'],
                            'we': ['ourselves']
                        };
                        
                        const allowedSubjects = reflexiveExpected[mainSubject] || [];
                        
                        if (!allowedSubjects.includes(englishSubject)) {
                            return {
                                isCorrect: false,
                                reason: `reflexive pronoun required (main subject is "${englishStruct.mainClauseSubject}", so reflexive subject must be "${allowedSubjects.join(' or ')}", not "${englishStruct.subject}")`
                            };
                        }
                    }
                } else if (!wordsMatch(latinSubjectDef, englishSubject)) {
                    return {
                        isCorrect: false,
                        reason: `wrong subject (expected "${latinStruct.subject.definition}" but found "${englishStruct.subject}")`
                    };
                }
            }
        }

        // 2. Check object match
        if (latinStruct.object) {
            const latinObjectDef = normalizeWord(latinStruct.object.definition || '');
            const englishObject = normalizeWord(englishStruct.object || '');
            
            if (!englishObject) {
                errors.push('missing object');
            } else if (!wordsMatch(latinObjectDef, englishObject)) {
                return {
                    isCorrect: false,
                    reason: `wrong object (expected "${latinStruct.object.definition}" but found "${englishStruct.object}")`
                };
            }
        }

        // 3. Check verb match (use infinitive verb if it's an indirect statement)
        const latinVerbToCheck = latinStruct.infinitiveVerb || latinStruct.verb;
        if (latinVerbToCheck) {
            const latinVerbDef = normalizeWord(latinVerbToCheck.definition || '');
            let englishVerb = normalizeWord(englishStruct.verb || '');
            
            if (!englishVerb) {
                errors.push('missing verb');
            } else {
                // Strip "to " from English infinitives for comparison with Latin verb definitions
                // e.g., "to be" → "be" to match Latin "esse" → "be"
                const englishVerbBase = englishVerb.replace(/^to\s+/, '');
                
                if (!wordsMatch(latinVerbDef, englishVerbBase)) {
                    return {
                        isCorrect: false,
                        reason: `wrong verb (expected "${latinVerbToCheck.definition}" but found "${englishStruct.verb}")`
                    };
                }
            }
        }

        // 4. Check subject modifiers
        if (latinStruct.subjectModifiers.length > 0) {
            const latinMods = latinStruct.subjectModifiers.map(m => normalizeWord(m.definition || ''));
            const englishMods = englishStruct.subjectModifiers.map(m => normalizeWord(m));
            
            for (const latinMod of latinMods) {
                const matched = englishMods.some(eMod => wordsMatch(latinMod, eMod));
                if (!matched) {
                    // Check if there's a contradictory modifier
                    const contradiction = findContradictions([latinMod], englishMods.concat(englishStruct.objectModifiers));
                    if (contradiction.length > 0) {
                        return {
                            isCorrect: false,
                            reason: `wrong modifier (expected "${latinMod}" describing subject, but found "${contradiction[0].found}")`
                        };
                    }
                }
            }
        }

        // 5. Check object modifiers
        if (latinStruct.objectModifiers.length > 0) {
            const latinMods = latinStruct.objectModifiers.map(m => normalizeWord(m.definition || ''));
            const englishMods = englishStruct.objectModifiers.map(m => normalizeWord(m));
            
            for (const latinMod of latinMods) {
                const matched = englishMods.some(eMod => wordsMatch(latinMod, eMod));
                if (!matched) {
                    // Check if there's a contradictory modifier
                    const contradiction = findContradictions([latinMod], englishMods.concat(englishStruct.subjectModifiers));
                    if (contradiction.length > 0) {
                        return {
                            isCorrect: false,
                            reason: `wrong modifier (expected "${latinMod}" describing object, but found "${contradiction[0].found}")`
                        };
                    }
                }
            }
        }

        // 6. Final fallback: Check for semantic contradictions in all words
        if (STATE.baselineEnglish) {
            const userWords = (englishStruct.allWords || []).filter(w => !STOP_WORDS.has(w));
            const contradictions = findContradictions(STATE.baselineEnglish, userWords);
            if (contradictions.length > 0) {
                return {
                    isCorrect: false,
                    reason: `contradictory meaning (expected "${contradictions[0].expected}" but found "${contradictions[0].found}")`
                };
            }
        }

        // If we have errors, report them
        if (errors.length > 0) {
            return {
                isCorrect: false,
                reason: errors.join(', ')
            };
        }

        return { isCorrect: true, reason: '' };
    }

    function wordsMatch(word1, word2) {
        if (!word1 || !word2) return false;
        
        const w1 = normalizeWord(word1);
        const w2 = normalizeWord(word2);
        
        // If word1 contains multiple definitions (comma-separated), check if word2 matches ANY of them
        if (w1.includes(',')) {
            const definitions = w1.split(',').map(def => def.trim());
            for (const def of definitions) {
                // Direct match
                if (def === w2) return true;
                
                // Fuzzy match (allow small differences)
                if (levenshteinDistance(def, w2) <= 2) return true;
                
                // Stem match
                if (def.startsWith(w2) || w2.startsWith(def)) return true;
            }
            return false;
        }
        
        // Single definition - standard matching
        // Direct match
        if (w1 === w2) return true;
        
        // Fuzzy match (allow small differences)
        if (levenshteinDistance(w1, w2) <= 2) return true;
        
        // Stem match
        if (w1.startsWith(w2) || w2.startsWith(w1)) return true;
        
        return false;
    }

    function sameCaseBucket(a, b) {
        const aCases = extractCaseTags(a);
        const bCases = extractCaseTags(b);
        if (!aCases.length || !bCases.length) return false;
        return aCases.some(c => bCases.includes(c));
    }

    function extractCaseTags(info) {
        if (!info) return [];
        const matches = info.toLowerCase().match(/nom|gen|dat|acc|abl|voc|loc/g);
        return matches ? Array.from(new Set(matches)) : [];
    }

    function extractNumberTags(token) {
        const tags = new Set();
        const caseInfo = (token.features.case || '').toLowerCase();
        if (caseInfo.includes('sg')) tags.add('singular');
        if (caseInfo.includes('pl')) tags.add('plural');

        const num = token.features.number;
        if (Array.isArray(num)) {
            num.forEach(n => {
                const lower = (n || '').toLowerCase();
                if (/singular|sg/.test(lower)) tags.add('singular');
                if (/plural|pl/.test(lower)) tags.add('plural');
            });
        } else if (typeof num === 'string') {
            const lower = num.toLowerCase();
            if (/singular|sg/.test(lower)) tags.add('singular');
            if (/plural|pl/.test(lower)) tags.add('plural');
        }
        return Array.from(tags);
    }

    function extractGenderTags(token) {
        const tags = new Set();
        const caseInfo = (token.features.case || '').toLowerCase();
        if (caseInfo.includes('fem')) tags.add('feminine');
        if (caseInfo.includes('masc')) tags.add('masculine');
        if (caseInfo.includes('neut')) tags.add('neuter');

        const gender = token.features.gender;
        if (Array.isArray(gender)) {
            gender.forEach(g => {
                if (g) tags.add(g.toLowerCase());
            });
        } else if (typeof gender === 'string' && gender) {
            tags.add(gender.toLowerCase());
        }

        if (!tags.size) {
            const w = token.normalized || '';
            if (/(ae|am|arum|a)$/.test(w)) tags.add('feminine');
            else if (/(us|i|os|orum)$/.test(w) && !/(ius|bus)$/.test(w)) tags.add('masculine');
            else if (/(um|on|ia|ium|ibus)$/.test(w)) tags.add('neuter');

            if (token.pos === 'participle' || token.pos === 'gerundive') {
                if (/a$/.test(w)) tags.add('feminine');
                if (/(us|tus|sus|ctus|ptus|rsus)$/.test(w)) tags.add('masculine');
                if (/(um|tum|sum|ctum|ptum|rsum)$/.test(w)) tags.add('neuter');
            }
        }

        return Array.from(tags);
    }

    function tokensMorphologicallyAgree(a, b) {
        const aCases = extractCaseTags(a.features.case);
        const bCases = extractCaseTags(b.features.case);
        if (!aCases.length || !bCases.length || !aCases.some(c => bCases.includes(c))) {
            return false;
        }

        const numsA = extractNumberTags(a);
        const numsB = extractNumberTags(b);
        if (numsA.length && numsB.length && !numsA.some(n => numsB.includes(n))) {
            return false;
        }

        const gensA = extractGenderTags(a);
        const gensB = extractGenderTags(b);
        if (gensA.length && gensB.length && !gensA.some(g => gensB.includes(g))) {
            return false;
        }

        return true;
    }

    function findContradictions(expectedWords, userWords) {
        const contradictions = [];
        
        for (const expected of expectedWords) {
            const opposites = SEMANTIC_OPPOSITES[expected] || [];
            for (const userWord of userWords) {
                if (opposites.includes(userWord)) {
                    contradictions.push({ expected, found: userWord });
                }
            }
        }
        
        return contradictions;
    }

    function normalizeWord(word) {
        // Normalize to base form for better matching
        word = word.toLowerCase();
        
        // Handle common verb forms
        if (word.endsWith('ing')) return word.slice(0, -3); // loving -> lov
        if (word.endsWith('ed')) return word.slice(0, -2); // loved -> lov
        if (word.endsWith('es')) return word.slice(0, -2); // loves -> lov
        if (word.endsWith('s') && word.length > 3) return word.slice(0, -1); // loves -> love
        
        // Handle common plural forms
        if (word.endsWith('ies')) return word.slice(0, -3) + 'y'; // cities -> city
        
        return word;
    }

    function hasRelatedForm(word, wordList) {
        // Check if any word in the list is a related form
        const baseWord = word.length > 3 ? word.slice(0, -1) : word;
        return wordList.some(w => {
            return w === word || 
                   w.startsWith(baseWord) || 
                   baseWord.startsWith(w) ||
                   levenshteinDistance(word, w) <= 2;
        });
    }

    function isRelatedToAny(word, wordList) {
        return wordList.some(expected => {
            const dist = levenshteinDistance(word, expected);
            return dist <= 2 || word.startsWith(expected) || expected.startsWith(word);
        });
    }

    function levenshteinDistance(a, b) {
        if (a.length === 0) return b.length;
        if (b.length === 0) return a.length;
        
        const matrix = [];
        
        for (let i = 0; i <= b.length; i++) {
            matrix[i] = [i];
        }
        
        for (let j = 0; j <= a.length; j++) {
            matrix[0][j] = j;
        }
        
        for (let i = 1; i <= b.length; i++) {
            for (let j = 1; j <= a.length; j++) {
                if (b.charAt(i - 1) === a.charAt(j - 1)) {
                    matrix[i][j] = matrix[i - 1][j - 1];
                } else {
                    matrix[i][j] = Math.min(
                        matrix[i - 1][j - 1] + 1,
                        matrix[i][j - 1] + 1,
                        matrix[i - 1][j] + 1
                    );
                }
            }
        }
        
        return matrix[b.length][a.length];
    }

    // Analysis pipeline
    function analyze(rawText, opts) {
        const tokens = tokenize(rawText);
        const authorBias = inferAuthorBias(opts.author, opts.mode);
        tokens.forEach(t => annotateToken(t, authorBias));
        const groups = buildTranslationChunks(rawText, tokens, authorBias);
        const grammar = detectComplexGrammar(tokens, authorBias);
        const baselineEnglish = buildBaselineEnglish(tokens);
        return { tokens, groups, grammar, baselineEnglish };
    }

    function tokenize(text) {
        const regex = /\p{L}+[\p{L}\-]*/gu;
        const tokens = [];
        let m;
        while ((m = regex.exec(text)) !== null) {
            const word = m[0];
            const start = m.index;
            tokens.push({
                original: word,
                normalized: normalizeLatin(word),
                pos: 'unknown',
                features: {},
                definition: lookupDefinition(word),
                start,
                end: start + word.length
            });
        }
        return tokens;
    }

    function normalizeLatin(w) {
        return w
            .toLowerCase()
            .normalize('NFD').replace(/[\u0300-\u036f]/g, '') // strip diacritics
            .replace(/j/g, 'i')
            .replace(/v/g, 'u');
    }

    function annotateToken(t, bias) {
        const w = t.normalized;
        
        // FIRST: Check if word exists in LEXICON
        const lexEntry = LEXICON[w];
        if (lexEntry && lexEntry.pos) {
            t.pos = lexEntry.pos;
            t.definition = lexEntry.def; // Set definition from lexicon!
            
            // Set appropriate features based on part of speech
            if (lexEntry.pos === 'noun' || lexEntry.pos === 'adjective' || lexEntry.pos === 'participle' || lexEntry.pos === 'gerundive') {
                // If lexicon has case information, use it (for irregular forms like "omnis")
                if (lexEntry.case) {
                    t.features.case = lexEntry.case;
                } else {
                    // Try to determine case from word endings
                    if (/(ae|am|as|arum|a)$/.test(w)) {
                        t.features.case = caseFromEnding1st(w);
                    } else if (/(us|i|o|um|os|orum)$/.test(w)) {
                        t.features.case = caseFromEnding2nd(w);
                    } else if (/(em|es|is|e|ibus|um|ium)$/.test(w)) {
                        t.features.case = caseFromEnding3rd(w);
                    } else if (/er$/.test(w)) {
                        t.features.case = 'nom sg';
                    } else if (/(or|x)$/.test(w)) {
                        t.features.case = 'nom sg';
                    }
                }
            }
            if (lexEntry.pos === 'verb') {
                // Try to determine tense from word endings
                if (/re$|sse$/.test(w)) {
                    t.features.tense = 'infinitive';
                } else if (/(vi|vit|visti|xit|si|sit)$/.test(w)) {
                    t.features.tense = 'perfect';
                } else if (/nt$/.test(w)) {
                    t.features.tense = 'present';
                } else {
                    t.features.tense = 'present';
                }
            }
            if (lexEntry.pos === 'participle') {
                // Set tense for participles
                if (/(urus|ura|urum)$/.test(w)) {
                    t.features.tense = 'future';
                } else if (/n(s|t[ieao]|tis|tem|tes|tia|tium|tibus)$/.test(w)) {
                    t.features.tense = 'present';
                } else {
                    t.features.tense = 'perfect'; // Most common
                }
            }
            if (lexEntry.pos === 'gerundive') {
                t.features.voice = 'passive';
                if (!t.features.tense) {
                    t.features.tense = 'future';
                }
            }
            return;
        }
        
        // SECOND: Fall back to morphology heuristics if not in LEXICON
        // Check for participles FIRST (before verbs) to avoid misclassification
        
        // Perfect participles: -tus, -ta, -tum, -sus, -sa, -sum, -ctus, -ptus, -rsus
        if (/(tus|ta|tum|sus|sa|sum|ctus|cta|ctum|ptus|pta|ptum|rsus|rsa|rsum)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'perfect';
            // Also assign case based on ending
            if (/a$/.test(w)) {
                t.features.case = 'nom/abl sg fem';
            } else if (/(us|tus|sus|ctus|ptus|rsus)$/.test(w)) {
                t.features.case = 'nom sg masc';
            } else if (/(um|tum|sum|ctum|ptum|rsum)$/.test(w)) {
                t.features.case = 'nom/acc sg neut';
            }
            return;
        }
        
        // Future active participles: -urus, -ura, -urum
        if (/(urus|ura|urum)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'future';
            return;
        }
        
        // Present active participles: -ns, -ntis, -ntem, -ntes (but not verb endings)
        // Check for -ns or -nt- followed by vowels (case endings)
        if (/n(s|t[ieao]|tis|tem|tes|tia|tium|tibus)$/.test(w)) {
            t.pos = 'participle';
            t.features.tense = 'present';
            return;
        }
        
        // NOW check verb patterns (after participles)
        if (/\b(sum|es|est|sumus|estis|sunt)\b/.test(w)) {
            t.pos = 'verb';
            t.features.tense = 'present';
            t.definition ||= 'be';
            return;
        }
        // Infinitives (before other verb endings)
        if (/re$/.test(w) && !/(urus|ura|urum)$/.test(w)) {
            t.pos = 'verb';
            t.features.tense = 'infinitive';
            return;
        }
        // Finite verb forms
        if (/nt$/.test(w) || /t$/.test(w) || /(o|m)$/.test(w)) {
            // Make sure it's not a participle we missed
            if (!/(tus|sus|ctus|ptus|rsus)$/.test(w)) {
                t.pos = 'verb';
                t.features.tense = /it$|erunt$/.test(w) ? 'perfect' : 'present';
                return;
            }
        }
        // Noun/adjective endings (very simplified)
        if (/(ae|am|as|arum)$/.test(w) || /(a)$/.test(w)) {
            t.pos = guessAdjOrNoun(w);
            t.features.case = caseFromEnding1st(w);
            return;
        }
        if (/(us|i|o|um|os|orum)$/.test(w)) {
            t.pos = guessAdjOrNoun(w);
            t.features.case = caseFromEnding2nd(w);
            return;
        }
        if (/(em|es|is|e|ibus|um|ium)$/.test(w)) {
            t.pos = 'noun';
            t.features.case = caseFromEnding3rd(w);
            return;
        }
        if (/que$|ve$|ne$/.test(w)) {
            t.pos = 'particle';
            return;
        }
        // fallback
        t.pos = t.pos || 'unknown';
    }

    function guessAdjOrNoun(w) {
        return LEXICON[w]?.pos || (/(us|a|um|i|ae)$/.test(w) ? 'adjective' : 'noun');
    }

    function caseFromEnding1st(w) {
        if (/ae$/.test(w)) return 'gen/dat sg or nom pl';
        if (/am$/.test(w)) return 'acc sg';
        if (/arum$/.test(w)) return 'gen pl';
        if (/a$/.test(w)) return 'nom/abl sg';
        return undefined;
    }

    function caseFromEnding2nd(w) {
        if (/i$/.test(w)) return 'gen sg or nom pl';
        if (/o$/.test(w)) return 'dat/abl sg';
        if (/um$/.test(w)) return 'acc sg (or nom/acc sg neuter)';
        if (/os$/.test(w)) return 'acc pl';
        if (/orum$/.test(w)) return 'gen pl';
        if (/us$/.test(w)) return 'nom sg';
        return undefined;
    }

    function caseFromEnding3rd(w) {
        if (/em$/.test(w)) return 'acc sg';
        if (/es$/.test(w)) return 'nom/acc pl';
        if (/is$/.test(w)) return 'gen sg or dat sg';
        if (/e$/.test(w)) return 'abl sg';
        if (/ibus$/.test(w)) return 'dat/abl pl';
        if (/um$/.test(w)) return 'gen pl';
        if (/ium$/.test(w)) return 'gen pl (i-stem)';
        return undefined;
    }

    // Helper: Detect if a verb is subjunctive based on endings
    function isSubjunctive(token) {
        if (token.pos !== 'verb') return false;
        const w = token.normalized;
        // Present subjunctive: -em, -am, -et, -at, -emus, -amus, -etis, -atis, -ent, -ant
        if (/(em|am|et|at|emus|amus|etis|atis|ent|ant)$/.test(w)) return true;
        // Imperfect subjunctive: -rem, -res, -ret, -remus, -retis, -rent
        if (/(rem|res|ret|remus|retis|rent)$/.test(w)) return true;
        // Perfect subjunctive: -erim, -eris, -erit, -erimus, -eritis, -erint
        if(/(erim|eris|erit|erimus|eritis|erint)$/.test(w)) return true;
        // Pluperfect subjunctive: -issem, -isses, -isset, -issemus, -issetis, -issent
        if(/(issem|isses|isset|issemus|issetis|issent)$/.test(w)) return true;
        return false;
    }

    // Helper: Check if "cum" is preposition (with abl) or conjunction (with verb)
    function isCumPreposition(tokens, cumIdx) {
        if (cumIdx + 1 >= tokens.length) return false;
        const nextToken = tokens[cumIdx + 1];
        // Check if next word is ablative
        const nextCase = nextToken.features.case || '';
        return /abl/.test(nextCase) || nextToken.normalized.endsWith('o');
    }

    // Helper: Check if "ut" introduces subjunctive clause
    function isUtClause(tokens, utIdx) {
        // Look ahead 1-3 words for a verb
        for (let i = utIdx + 1; i <= Math.min(utIdx + 3, tokens.length - 1); i++) {
            if (tokens[i].pos === 'verb') {
                return isSubjunctive(tokens[i]);
            }
        }
        return false; // Default to not a clause if no verb found
    }

    // Helper: Detect ablative absolute (abl noun + abl participle)
    function findAblativeAbsolutes(tokens) {
        const ablAbsolutes = [];
        for (let i = 0; i < tokens.length - 1; i++) {
            const t1 = tokens[i];
            const t2 = tokens[i + 1];
            if ((t1.pos === 'noun' || t1.pos === 'pronoun') && t2.pos === 'participle') {
                if (tokensMorphologicallyAgree(t1, t2)) {
                    const nounCases = extractCaseTags(t1.features.case);
                    const partCases = extractCaseTags(t2.features.case);
                    if (nounCases.includes('abl') && partCases.includes('abl')) {
                        ablAbsolutes.push([i, i + 1]);
                    }
                }
            }
        }
        return ablAbsolutes;
    }

    function buildTranslationChunks(rawText, tokens, bias) {
        if (!tokens || tokens.length === 0) return [];
        
        const chunks = [];
        const assigned = new Array(tokens.length).fill(false);
        
        function isComparativeOrSuperlative(token) {
            if (!token) return false;
            const w = token.normalized || '';
            if (!w) return false;
            if (/(ior|ius)$/.test(w)) return true; // comparative endings
            if (/(issim|issum|issa|errim|errum|erra|lim|limum|lima)$/.test(w)) return true; // superlative stems
            if (/^(maxim|minim|plur|plus|magis|maior|minor|melior|peior|optim|pessim)/.test(w)) return true;
            return false;
        }
        
        function hasFiniteVerbAhead(idx, maxLook = 6) {
            const limit = Math.min(tokens.length - 1, idx + maxLook);
            for (let i = idx + 1; i <= limit; i++) {
                const tok = tokens[i];
                if (!tok) continue;
                if (tok.pos === 'verb' && tok.features.tense !== 'infinitive') {
                    return true;
                }
            }
            return false;
        }
        
        function findNextPunctuation(startChar, endChar) {
            if (startChar >= endChar) return null;
            const slice = rawText.slice(startChar, endChar);
            const match = slice.match(/[,;:]/);
            if (!match) return null;
            return startChar + match.index;
        }
        
        function findTokenIndexAtOrAfter(charIdx, fromIdx, toIdx) {
            for (let i = fromIdx; i <= toIdx; i++) {
                if (tokens[i] && tokens[i].start >= charIdx) {
                    return i;
                }
            }
            return toIdx + 1;
        }
        
        const boundariesForSplit = [];
        
        function splitChunkByPunctuation(chunk) {
            const tokenIdxs = chunk.tokens;
            if (!tokenIdxs || tokenIdxs.length <= 1) return [chunk];
            
            const segments = [];
            let segmentStart = 0;
            let chunkType = chunk.type;
            
            for (let i = 1; i < tokenIdxs.length; i++) {
                const prevToken = tokens[tokenIdxs[i - 1]];
                const currToken = tokens[tokenIdxs[i]];
                const between = rawText.slice(prevToken.end, currToken.start);
                if (between.includes(',')) {
                    const commaIdx = prevToken.end + between.indexOf(',');
                    const nextBoundary = boundariesForSplit.find(b => b > commaIdx);
                    const remaining = tokenIdxs.slice(i);
                    const hasInfinitiveAhead = remaining.some(ti => {
                        const t = tokens[ti];
                        return t.pos === 'verb' && t.features.tense === 'infinitive';
                    });
                    const currentSegment = tokenIdxs.slice(segmentStart, i);
                    const hasInfinitiveCurrent = currentSegment.some(ti => {
                        const t = tokens[ti];
                        return t.pos === 'verb' && t.features.tense === 'infinitive';
                    });
                    if (hasInfinitiveCurrent && hasInfinitiveAhead && (!nextBoundary || nextBoundary > currToken.start)) {
                        if (currentSegment.length > 0) {
                            segments.push({ tokens: currentSegment, type: chunkType });
                        }
                        chunkType = 'infinitive-phrase';
                        segmentStart = i;
                    }
                }
            }
            
            const finalSegment = tokenIdxs.slice(segmentStart);
            if (finalSegment.length > 0) {
                segments.push({ tokens: finalSegment, type: chunkType });
            }
            return segments;
        }
        
        // Relative pronouns
        const relativePronouns = new Set(['qui','quae','quod','quem','quam','quos','quas','quo','qua','quibus','cui','cuius','quorum','quarum']);
        
        // Subordinate conjunctions
        const subordinateConjs = new Set(['cum', 'ut', 'ne', 'si', 'nisi', 'dum', 'donec', 'antequam', 'priusquam', 
                                          'quamquam', 'etsi', 'licet', 'quod', 'quia', 'quoniam']);
        
        // Indirect question words
        const indirectQWords = new Set(['cur', 'quomodo', 'ubi', 'quando', 'quis', 'quid', 'quo', 'unde']);
        
        // Step 1: Find ablative absolutes (highest priority)
        const ablAbsolutes = findAblativeAbsolutes(tokens);
        ablAbsolutes.forEach(([start, end]) => {
            const chunkTokens = [];
            for (let i = start; i <= end; i++) {
                chunkTokens.push(i);
            }
            chunks.push({ tokens: chunkTokens, type: 'ablative-absolute' });
        });
        
        // Step 2: Find chunk boundaries
        const boundaries = []; // Array of {idx, type, priority, startChar}
        
        for (let i = 0; i < tokens.length; i++) {
            const t = tokens[i];
            const w = t.normalized;
            
            // Relative pronouns
            if (relativePronouns.has(w)) {
                if (w === 'quam') {
                    let foundFinite = false;
                    for (let j = i + 1; j < tokens.length; j++) {
                        const gap = rawText.slice(tokens[j - 1].end, tokens[j].start);
                        if (/,|;|:/.test(gap)) break;
                        const tok = tokens[j];
                        if (tok.pos === 'verb' && tok.features.tense !== 'infinitive') {
                            foundFinite = true;
                            break;
                        }
                    }
                    if (!foundFinite) {
                        continue; // comparative/adverbial "quam", not clause boundary
                    }
                }
                boundaries.push({ idx: i, type: 'relative', priority: 2, startChar: t.start });
            }
            
            // Cum clauses
            else if (w === 'cum' && !isCumPreposition(tokens, i)) {
                boundaries.push({ idx: i, type: 'cum-clause', priority: 2, startChar: t.start });
            }
            
            // Ut/ne clauses
            else if ((w === 'ut' || w === 'ne') && isUtClause(tokens, i)) {
                boundaries.push({ idx: i, type: 'ut-clause', priority: 2, startChar: t.start });
            }
            
            // Other subordinate conjunctions
            else if (subordinateConjs.has(w) && w !== 'cum' && w !== 'ut' && w !== 'ne') {
                boundaries.push({ idx: i, type: 'subordinate', priority: 2, startChar: t.start });
            }
        }
        
        // Sort boundaries by index
        boundaries.sort((a, b) => a.idx - b.idx);
        
        // Step 3: Create chunks between boundaries
        let chunkStart = 0;
        
        for (const boundary of boundaries) {
            let clauseStart = boundary.idx;
            if (boundary.type === 'relative') {
                const antecedentIdx = boundary.idx - 1;
                if (antecedentIdx >= chunkStart) {
                    const antecedent = tokens[antecedentIdx];
                    const boundaryToken = tokens[boundary.idx];
                    if (antecedent && (antecedent.pos === 'noun' || antecedent.pos === 'pronoun')) {
                        const between = rawText.slice(antecedent.end, boundaryToken.start);
                        if (!/[,;:]/.test(between)) {
                            clauseStart = antecedentIdx;
                        }
                    }
                }
            }
            
            // Add chunk from chunkStart to clauseStart (exclusive)
            if (clauseStart > chunkStart) {
                const chunkTokens = [];
                for (let i = chunkStart; i < clauseStart; i++) {
                    chunkTokens.push(i);
                }
                if (chunkTokens.length > 0) {
                    chunks.push({ tokens: chunkTokens, type: 'main' });
                }
            }
            
            // Find end of this boundary's clause
            let clauseEnd = boundary.idx;
            
            // Look for next boundary or end of sentence
            const nextBoundaryIdx = boundaries.find(b => b.idx > boundary.idx)?.idx || tokens.length;
            
            // For relative/subordinate clauses, include up to next boundary
            clauseEnd = nextBoundaryIdx - 1;
            
            if (['relative', 'cum-clause', 'ut-clause', 'subordinate'].includes(boundary.type)) {
                const startToken = tokens[clauseStart];
                const searchStart = startToken ? startToken.end : tokens[boundary.idx].end;
                const searchEnd = nextBoundaryIdx < tokens.length ? tokens[nextBoundaryIdx].start : rawText.length;
                const punctIdx = findNextPunctuation(searchStart, searchEnd);
                if (punctIdx !== null) {
                    const trimmedIdx = findTokenIndexAtOrAfter(punctIdx, clauseStart + 1, clauseEnd);
                    const newClauseEnd = Math.max(clauseStart, trimmedIdx - 1);
                    if (newClauseEnd < clauseEnd) {
                        clauseEnd = newClauseEnd;
                    }
                }
            }
            
            // Create chunk for this clause
            const clauseTokens = [];
            for (let i = clauseStart; i <= Math.min(clauseEnd, tokens.length - 1); i++) {
                clauseTokens.push(i);
            }
            if (clauseTokens.length > 0) {
                chunks.push({ tokens: clauseTokens, type: boundary.type });
            }
            
            chunkStart = clauseEnd + 1;
        }
        
        // Add final chunk if there's remaining tokens
        if (chunkStart < tokens.length) {
            const chunkTokens = [];
            for (let i = chunkStart; i < tokens.length; i++) {
                chunkTokens.push(i);
            }
            if (chunkTokens.length > 0) {
                chunks.push({ tokens: chunkTokens, type: 'main' });
            }
        }
        
        // If no boundaries found, make entire sentence one chunk
        if (chunks.length === 0) {
            const allTokens = [];
            for (let i = 0; i < tokens.length; i++) {
                allTokens.push(i);
            }
            chunks.push({ tokens: allTokens, type: 'main' });
        }
        
        // Remove empty chunks
        const filtered = chunks.filter(chunk => chunk.tokens && chunk.tokens.length > 0);
        const refined = [];
        boundariesForSplit.length = 0;
        boundaries.forEach(b => {
            if (typeof b.startChar === 'number') {
                boundariesForSplit.push(b.startChar);
            } else {
                const token = tokens[b.idx];
                if (token) boundariesForSplit.push(token.start);
            }
        });
        filtered.forEach(chunk => {
            splitChunkByPunctuation(chunk).forEach(c => {
                if (c.tokens && c.tokens.length > 0) {
                    refined.push(c);
                }
            });
        });
        return refined;
    }

    function sameCaseBucket(a, b) {
        const aCases = extractCaseTags(a);
        const bCases = extractCaseTags(b);
        if (!aCases.length || !bCases.length) return false;
        return aCases.some(c => bCases.includes(c));
    }

    function mergeSets(sets) {
        const result = [];
        sets.forEach(s => {
            let merged = false;
            for (const r of result) {
                if ([...s].some(x => r.has(x))) { [...s].forEach(x => r.add(x)); merged = true; break; }
            }
            if (!merged) result.push(new Set(s));
        });
        return result;
    }

    function detectComplexGrammar(tokens, bias) {
        const found = [];
        // Ablative absolute: ablative noun + participle nearby
        for (let i = 0; i < tokens.length - 1; i++) {
            const a = tokens[i];
            const b = tokens[i+1];
            if ((a.pos === 'noun' || a.pos === 'pronoun') && b.pos === 'participle') {
                const nounCases = extractCaseTags(a.features.case);
                const partCases = extractCaseTags(b.features.case);
                if (nounCases.includes('abl') && partCases.includes('abl') && tokensMorphologicallyAgree(a, b)) {
                    found.push({ name: 'Ablative Absolute', text: `${a.original} ${b.original}` });
                }
            }
        }
        // Supine (accusative -um after motion verb)
        const motion = new Set(['venit','veniunt','venimus','venio','eo','iit','iit','ierunt','ibat','ibant','iit','ivimus','adeo','redeo']);
        for (let i = 0; i < tokens.length - 1; i++) {
            if (motion.has(tokens[i].normalized) && /um$/.test(tokens[i+1].normalized)) {
                found.push({ name: 'Accusative Supine', text: tokens[i+1].original });
            }
        }
        // Indirect statement: reporting verb + accusative noun(s) + infinitive
        const reportingVerbs = new Set(['dico', 'dicis', 'dicit', 'dicimus', 'dicitis', 'dicunt', 'dixit', 'dixerunt', 'puto', 'putas', 'putat', 'putamus', 'putatis', 'putant', 'putavi', 'putavit', 'credo', 'credis', 'credit', 'credimus', 'creditis', 'credunt', 'credidi', 'video', 'vides', 'videt', 'videmus', 'videtis', 'vident', 'vidi', 'viderunt', 'audio', 'audis', 'audit', 'audimus', 'auditis', 'audiunt', 'audivi', 'audivit', 'spero', 'speras', 'sperat', 'speramus', 'scio', 'scis', 'scit', 'scimus', 'scitis', 'sciunt', 'narro', 'narras', 'narrat', 'narramus']);
        for (let i = 0; i < tokens.length; i++) {
            const t = tokens[i];
            // Look for infinitives
            if (t.pos === 'verb' && t.features.tense === 'infinitive') {
                // Check if there's a reporting verb before this infinitive
                let reportingVerbIdx = -1;
                for (let k = Math.max(0, i - 6); k < i; k++) {
                    if (tokens[k].pos === 'verb' && reportingVerbs.has(tokens[k].normalized)) {
                        reportingVerbIdx = k;
                        break;
                    }
                }
                
                if (reportingVerbIdx >= 0) {
                    // Find accusative nouns/pronouns in the indirect statement
                    const accSubjects = [];
                    
                    // Look between reporting verb and infinitive
                    for (let j = reportingVerbIdx + 1; j < i; j++) {
                        const token = tokens[j];
                        if (token.pos === 'noun' || token.pos === 'pronoun') {
                            const tokenCase = token.features.case || '';
                            const isAccusative = /^acc/.test(tokenCase);
                            const accPronouns = ['me', 'te', 'se', 'nos', 'vos', 'eum', 'eam', 'eos', 'eas', 'id'];
                            const isAccPronoun = accPronouns.includes(token.normalized);
                            
                            if (isAccusative || isAccPronoun) {
                                accSubjects.push(token.original);
                            }
                        }
                    }
                    
                    // Also look after infinitive for predicate accusatives
                    for (let j = i + 1; j <= Math.min(i + 2, tokens.length - 1); j++) {
                        const token = tokens[j];
                        if (token.pos === 'noun' || token.pos === 'pronoun') {
                            const tokenCase = token.features.case || '';
                            const isAccusative = /^acc/.test(tokenCase);
                            const accPronouns = ['me', 'te', 'se', 'nos', 'vos', 'eum', 'eam', 'eos', 'eas', 'id'];
                            const isAccPronoun = accPronouns.includes(token.normalized);
                            
                            if (isAccusative || isAccPronoun) {
                                accSubjects.push(token.original);
                            }
                        }
                    }
                    
                    // If we found accusative noun(s)/pronoun(s), report the indirect statement
                    if (accSubjects.length > 0) {
                        const span = [tokens[reportingVerbIdx].original, ...accSubjects, t.original].join(' ');
                        found.push({ name: 'Indirect Statement', text: span });
                        break; // Only report once per infinitive
                    }
                }
            }
        }
        // Relative Clauses: relative pronoun followed by clause
        const relSet = new Set(['qui','quae','quod','quem','quam','quos','quas','quo','qua','quibus','cui','cuius','quorum','quarum']);
        for (let i = 0; i < tokens.length; i++) {
            if (relSet.has(tokens[i].normalized)) {
                // Find the span from relative pronoun to next verb
                const span = [tokens[i].original];
                for (let j = i + 1; j < tokens.length && j <= i + 5; j++) {
                    span.push(tokens[j].original);
                    if (tokens[j].pos === 'verb' && tokens[j].features.tense !== 'infinitive') {
                        break;
                    }
                }
                if (span.length > 1) {
                    found.push({ name: 'Relative Clause', text: span.join(' ') });
                }
            }
        }
        // Gerundives, with special attention to purpose constructions (ad + accusative + gerundive)
        const gerundiveSeen = new Set();
        for (let i = 0; i < tokens.length; i++) {
            const ger = tokens[i];
            if (ger.pos !== 'gerundive') continue;

            let start = i;
            let hasAd = false;
            for (let j = i - 1; j >= Math.max(0, i - 4); j--) {
                const candidate = tokens[j];
                if (!candidate) break;
                if (candidate.pos === 'punctuation') break;
                if (candidate.normalized === 'ad') {
                    start = j;
                    hasAd = true;
                    break;
                }
                if (candidate.pos === 'noun' || candidate.pos === 'pronoun' || candidate.pos === 'adjective') {
                    start = j;
                    continue;
                }
                if (candidate.pos === 'preposition') {
                    break;
                }
            }
            const phraseTokens = tokens.slice(start, i + 1);
            const text = phraseTokens.map(t => t.original).join(' ');
            const key = `${hasAd ? 'purpose' : 'gerundive'}|${text}`;
            if (!gerundiveSeen.has(key)) {
                gerundiveSeen.add(key);
                const label = hasAd ? 'Gerundive of Purpose' : 'Gerundive';
                found.push({ name: label, text });
            }
        }
        // Participial Phrases: participle + associated noun (with case agreement)
        // First, track which participles are already in noun-adjective agreement with closer words
        const participlesInAdjGroups = new Set();
        
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].pos === 'participle') {
                for (let j = Math.max(0, i - 2); j <= Math.min(tokens.length - 1, i + 2); j++) {
                    if (j !== i && (tokens[j].pos === 'noun' || tokens[j].pos === 'pronoun')) {
                        if (tokensMorphologicallyAgree(tokens[i], tokens[j])) {
                            participlesInAdjGroups.add(i);
                            break;
                        }
                    }
                }
            }
        }
        
        // Now detect participial phrases, but skip participles already in adjective groups
        for (let i = 0; i < tokens.length; i++) {
            if (tokens[i].pos === 'participle' && !participlesInAdjGroups.has(i)) {
                const windowSize = 3;
                let nearestNoun = null;
                let bestDist = Infinity;
                
                for (let j = Math.max(0, i - windowSize); j <= Math.min(tokens.length - 1, i + windowSize); j++) {
                    if (j !== i && (tokens[j].pos === 'noun' || tokens[j].pos === 'pronoun')) {
                        if (tokensMorphologicallyAgree(tokens[i], tokens[j])) {
                            const d = Math.abs(j - i);
                            if (d < bestDist) {
                                nearestNoun = tokens[j];
                                bestDist = d;
                            }
                        }
                    }
                }
                if (nearestNoun) {
                    found.push({ name: 'Participial Phrase', text: `${tokens[i].original} + ${nearestNoun.original}` });
                }
            }
        }
        return found;
    }

    function buildBaselineEnglish(tokens) {
        const english = [];
        tokens.forEach(t => {
            const gloss = (t.definition || '').toLowerCase();
            if (!gloss) return;
            const keep = gloss.split(/[^a-z]+/).filter(x => x && x.length > 1);
            keep.forEach(k => english.push(k));
        });
        return Array.from(new Set(english));
    }

    function inferAuthorBias(author, mode) {
        const a = (author || '').toLowerCase();
        const poetryAuthors = ['vergil','virgil','ovid','horace','catullus','propertius','tibullus'];
        const proseAuthors = ['caesar','cicero','sallust','livy','pliny'];
        return {
            poetry: mode === 'poetry' || poetryAuthors.some(x => a.includes(x)),
            prose: mode === 'prose' || proseAuthors.some(x => a.includes(x))
        };
    }

    function renderSafe(text) {
        return text.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
    }

    function escapeHtml(s) {
        return s.replace(/[&<>"']/g, ch => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;','\'':'&#39;'}[ch]));
    }

    // Comprehensive Latin dictionary based on https://personal.math.ubc.ca/~cass/frivs/latin/latin-dict-full.html
    const LEXICON = {
        // Common verbs (with infinitives)
        'amo': { pos: 'verb', def: 'love' }, 'amas': { pos: 'verb', def: 'love' }, 'amat': { pos: 'verb', def: 'love' }, 'amamus': { pos: 'verb', def: 'love' }, 'amant': { pos: 'verb', def: 'love' }, 'amare': { pos: 'verb', def: 'love' },
        'spero': { pos: 'verb', def: 'hope' }, 'speras': { pos: 'verb', def: 'hope' }, 'sperat': { pos: 'verb', def: 'hope' }, 'speramus': { pos: 'verb', def: 'hope' }, 'sperant': { pos: 'verb', def: 'hope' }, 'sperare': { pos: 'verb', def: 'hope' },
        'laboro': { pos: 'verb', def: 'work' }, 'laboras': { pos: 'verb', def: 'work' }, 'laborat': { pos: 'verb', def: 'work' }, 'laboramus': { pos: 'verb', def: 'work' }, 'laborant': { pos: 'verb', def: 'work' }, 'laborare': { pos: 'verb', def: 'work' },
        'paro': { pos: 'verb', def: 'prepare' }, 'paras': { pos: 'verb', def: 'prepare' }, 'parat': { pos: 'verb', def: 'prepare' }, 'paramus': { pos: 'verb', def: 'prepare' }, 'parant': { pos: 'verb', def: 'prepare' }, 'parare': { pos: 'verb', def: 'prepare' },
        'voco': { pos: 'verb', def: 'call' }, 'vocas': { pos: 'verb', def: 'call' }, 'vocat': { pos: 'verb', def: 'call' }, 'vocamus': { pos: 'verb', def: 'call' }, 'vocant': { pos: 'verb', def: 'call' }, 'vocare': { pos: 'verb', def: 'call' },
        'uoco': { pos: 'verb', def: 'call' }, 'uocas': { pos: 'verb', def: 'call' }, 'uocat': { pos: 'verb', def: 'call' }, 'uocamus': { pos: 'verb', def: 'call' }, 'uocant': { pos: 'verb', def: 'call' }, 'uocare': { pos: 'verb', def: 'call' },
        'laudo': { pos: 'verb', def: 'praise' }, 'laudas': { pos: 'verb', def: 'praise' }, 'laudat': { pos: 'verb', def: 'praise' }, 'laudamus': { pos: 'verb', def: 'praise' }, 'laudant': { pos: 'verb', def: 'praise' }, 'laudare': { pos: 'verb', def: 'praise' },
        'puto': { pos: 'verb', def: 'think' }, 'putas': { pos: 'verb', def: 'think' }, 'putat': { pos: 'verb', def: 'think' }, 'putamus': { pos: 'verb', def: 'think' }, 'putant': { pos: 'verb', def: 'think' }, 'putare': { pos: 'verb', def: 'think' },
        'sum': { pos: 'verb', def: 'be' }, 'es': { pos: 'verb', def: 'be' }, 'est': { pos: 'verb', def: 'be' }, 'sumus': { pos: 'verb', def: 'be' }, 'estis': { pos: 'verb', def: 'be' }, 'sunt': { pos: 'verb', def: 'be' }, 'esse': { pos: 'verb', def: 'be' },
        'video': { pos: 'verb', def: 'see' }, 'vides': { pos: 'verb', def: 'see' }, 'videt': { pos: 'verb', def: 'see' }, 'videmus': { pos: 'verb', def: 'see' }, 'videtis': { pos: 'verb', def: 'see' }, 'vident': { pos: 'verb', def: 'see' }, 'vidi': { pos: 'verb', def: 'see' }, 'visum': { pos: 'verb', def: 'see' }, 'videre': { pos: 'verb', def: 'see' },
        'uideo': { pos: 'verb', def: 'see' }, 'uides': { pos: 'verb', def: 'see' }, 'uidet': { pos: 'verb', def: 'see' }, 'uidemus': { pos: 'verb', def: 'see' }, 'uidetis': { pos: 'verb', def: 'see' }, 'uident': { pos: 'verb', def: 'see' }, 'uidi': { pos: 'verb', def: 'see' }, 'uisum': { pos: 'verb', def: 'see' }, 'uidere': { pos: 'verb', def: 'see' },
        'dico': { pos: 'verb', def: 'say' }, 'dicis': { pos: 'verb', def: 'say' }, 'dicit': { pos: 'verb', def: 'say' }, 'dicimus': { pos: 'verb', def: 'say' }, 'dicitis': { pos: 'verb', def: 'say' }, 'dicunt': { pos: 'verb', def: 'say' }, 'dixit': { pos: 'verb', def: 'say' }, 'dicere': { pos: 'verb', def: 'say' },
        'inquam': { pos: 'verb', def: 'say, I say' }, 'inquis': { pos: 'verb', def: 'say, you say' }, 'inquit': { pos: 'verb', def: 'say, he/she says' }, 'inquiunt': { pos: 'verb', def: 'say, they say' },
        'facio': { pos: 'verb', def: 'do, make' }, 'facit': { pos: 'verb', def: 'do, make' }, 'feci': { pos: 'verb', def: 'do, make' }, 'factum': { pos: 'verb', def: 'do, make' }, 'facere': { pos: 'verb', def: 'do, make' },
        'venio': { pos: 'verb', def: 'come' }, 'venit': { pos: 'verb', def: 'come' }, 'veni': { pos: 'verb', def: 'come' }, 'ventum': { pos: 'verb', def: 'come' }, 'venire': { pos: 'verb', def: 'come' },
        'uenio': { pos: 'verb', def: 'come' }, 'uenit': { pos: 'verb', def: 'come' }, 'ueni': { pos: 'verb', def: 'come' }, 'uentum': { pos: 'verb', def: 'come' }, 'uenire': { pos: 'verb', def: 'come' },
        'do': { pos: 'verb', def: 'give' }, 'dat': { pos: 'verb', def: 'give' }, 'dedi': { pos: 'verb', def: 'give' }, 'datum': { pos: 'verb', def: 'give' }, 'dare': { pos: 'verb', def: 'give' },
        'ago': { pos: 'verb', def: 'do, drive, act' }, 'agit': { pos: 'verb', def: 'do, drive' }, 'egi': { pos: 'verb', def: 'do, drive' }, 'actum': { pos: 'verb', def: 'do, drive' }, 'agere': { pos: 'verb', def: 'do, drive' },
        'pono': { pos: 'verb', def: 'put, place' }, 'ponit': { pos: 'verb', def: 'put, place' }, 'posui': { pos: 'verb', def: 'put, place' }, 'positum': { pos: 'verb', def: 'put, place' }, 'ponere': { pos: 'verb', def: 'put, place' },
        'capio': { pos: 'verb', def: 'take, capture' }, 'capit': { pos: 'verb', def: 'take, capture' }, 'cepi': { pos: 'verb', def: 'take, capture' }, 'captum': { pos: 'verb', def: 'take, capture' }, 'capere': { pos: 'verb', def: 'take, capture' },
        'habeo': { pos: 'verb', def: 'have, hold' }, 'habet': { pos: 'verb', def: 'have, hold' }, 'habui': { pos: 'verb', def: 'have, hold' }, 'habitum': { pos: 'verb', def: 'have, hold' }, 'habere': { pos: 'verb', def: 'have, hold' },
        'vivo': { pos: 'verb', def: 'live' }, 'vivit': { pos: 'verb', def: 'live' }, 'vixi': { pos: 'verb', def: 'live' }, 'victum': { pos: 'verb', def: 'live' }, 'vivere': { pos: 'verb', def: 'live' },
        'uiuo': { pos: 'verb', def: 'live' }, 'uiuit': { pos: 'verb', def: 'live' }, 'uixi': { pos: 'verb', def: 'live' }, 'uictum': { pos: 'verb', def: 'live' }, 'uiuere': { pos: 'verb', def: 'live' },
        'eo': { pos: 'verb', def: 'go' }, 'it': { pos: 'verb', def: 'go' }, 'ire': { pos: 'verb', def: 'go' }, 'iit': { pos: 'verb', def: 'go' }, 'ierunt': { pos: 'verb', def: 'go' },
        'duco': { pos: 'verb', def: 'lead' }, 'ducit': { pos: 'verb', def: 'lead' }, 'duxi': { pos: 'verb', def: 'lead' }, 'ductum': { pos: 'verb', def: 'lead' }, 'ducere': { pos: 'verb', def: 'lead' },
        'audio': { pos: 'verb', def: 'hear' }, 'audis': { pos: 'verb', def: 'hear' }, 'audit': { pos: 'verb', def: 'hear' }, 'audimus': { pos: 'verb', def: 'hear' }, 'auditis': { pos: 'verb', def: 'hear' }, 'audiunt': { pos: 'verb', def: 'hear' }, 'audivi': { pos: 'verb', def: 'hear' }, 'auditum': { pos: 'verb', def: 'hear' }, 'audire': { pos: 'verb', def: 'hear' },
        'scribo': { pos: 'verb', def: 'write' }, 'scribit': { pos: 'verb', def: 'write' }, 'scripsi': { pos: 'verb', def: 'write' }, 'scriptum': { pos: 'verb', def: 'write' }, 'scribere': { pos: 'verb', def: 'write' },
        'lego': { pos: 'verb', def: 'read, choose' }, 'legit': { pos: 'verb', def: 'read, choose' }, 'legi': { pos: 'verb', def: 'read, choose' }, 'lectum': { pos: 'verb', def: 'read, choose' }, 'legere': { pos: 'verb', def: 'read, choose' },
        'mitto': { pos: 'verb', def: 'send' }, 'mittit': { pos: 'verb', def: 'send' }, 'misi': { pos: 'verb', def: 'send' }, 'missum': { pos: 'verb', def: 'send' }, 'mittere': { pos: 'verb', def: 'send' },
        'porto': { pos: 'verb', def: 'carry' }, 'portat': { pos: 'verb', def: 'carry' }, 'portavi': { pos: 'verb', def: 'carry' }, 'portatum': { pos: 'verb', def: 'carry' }, 'portare': { pos: 'verb', def: 'carry' },
        'puto': { pos: 'verb', def: 'think, suppose' }, 'putas': { pos: 'verb', def: 'think' }, 'putat': { pos: 'verb', def: 'think' }, 'putamus': { pos: 'verb', def: 'think' }, 'putatis': { pos: 'verb', def: 'think' }, 'putant': { pos: 'verb', def: 'think' }, 'putavi': { pos: 'verb', def: 'think' }, 'putatum': { pos: 'verb', def: 'think' }, 'putare': { pos: 'verb', def: 'think' },
        'vinco': { pos: 'verb', def: 'conquer, win' }, 'vincit': { pos: 'verb', def: 'conquer' }, 'vici': { pos: 'verb', def: 'conquer' }, 'victum': { pos: 'verb', def: 'conquer' }, 'vincere': { pos: 'verb', def: 'conquer' },
        'uinco': { pos: 'verb', def: 'conquer, win' }, 'uincit': { pos: 'verb', def: 'conquer' }, 'uici': { pos: 'verb', def: 'conquer' }, 'uictum': { pos: 'verb', def: 'conquer' }, 'uincere': { pos: 'verb', def: 'conquer' },
        'moveo': { pos: 'verb', def: 'move' }, 'movet': { pos: 'verb', def: 'move' }, 'movi': { pos: 'verb', def: 'move' }, 'motum': { pos: 'verb', def: 'move' }, 'movere': { pos: 'verb', def: 'move' },
        'teneo': { pos: 'verb', def: 'hold' }, 'tenet': { pos: 'verb', def: 'hold' }, 'tenui': { pos: 'verb', def: 'hold' }, 'tentum': { pos: 'verb', def: 'hold' }, 'tenere': { pos: 'verb', def: 'hold' },
        'moneo': { pos: 'verb', def: 'warn, advise' }, 'monet': { pos: 'verb', def: 'warn' }, 'monui': { pos: 'verb', def: 'warn' }, 'monitum': { pos: 'verb', def: 'warn' }, 'monere': { pos: 'verb', def: 'warn' },
        'timeo': { pos: 'verb', def: 'fear' }, 'timet': { pos: 'verb', def: 'fear' }, 'timui': { pos: 'verb', def: 'fear' }, 'timere': { pos: 'verb', def: 'fear' },
        'credo': { pos: 'verb', def: 'believe, trust' }, 'credis': { pos: 'verb', def: 'believe' }, 'credit': { pos: 'verb', def: 'believe' }, 'credimus': { pos: 'verb', def: 'believe' }, 'creditis': { pos: 'verb', def: 'believe' }, 'credunt': { pos: 'verb', def: 'believe' }, 'credidi': { pos: 'verb', def: 'believe' }, 'creditum': { pos: 'verb', def: 'believe' }, 'credere': { pos: 'verb', def: 'believe' },
        'laudo': { pos: 'verb', def: 'praise' }, 'laudat': { pos: 'verb', def: 'praise' }, 'laudavi': { pos: 'verb', def: 'praise' }, 'laudatum': { pos: 'verb', def: 'praise' },
        'specto': { pos: 'verb', def: 'watch, look at' }, 'spectat': { pos: 'verb', def: 'watch' }, 'spectavi': { pos: 'verb', def: 'watch' }, 'spectatum': { pos: 'verb', def: 'watch' },
        'paro': { pos: 'verb', def: 'prepare' }, 'parat': { pos: 'verb', def: 'prepare' }, 'paravi': { pos: 'verb', def: 'prepare' }, 'paratum': { pos: 'verb', def: 'prepare' },
        'narro': { pos: 'verb', def: 'tell, narrate' }, 'narrat': { pos: 'verb', def: 'tell' }, 'narravi': { pos: 'verb', def: 'tell' }, 'narratum': { pos: 'verb', def: 'tell' },
        'voco': { pos: 'verb', def: 'call' }, 'vocat': { pos: 'verb', def: 'call' }, 'vocavi': { pos: 'verb', def: 'call' }, 'vocatum': { pos: 'verb', def: 'call' },
        'iuvo': { pos: 'verb', def: 'help' }, 'iuvat': { pos: 'verb', def: 'help' }, 'iuvi': { pos: 'verb', def: 'help' }, 'iutum': { pos: 'verb', def: 'help' },
        'relinquo': { pos: 'verb', def: 'leave behind' }, 'relinquit': { pos: 'verb', def: 'leave behind' }, 'reliqui': { pos: 'verb', def: 'leave behind' }, 'relictum': { pos: 'verb', def: 'leave behind' },
        'disco': { pos: 'verb', def: 'learn' }, 'discit': { pos: 'verb', def: 'learn' }, 'didici': { pos: 'verb', def: 'learn' },
        'doceo': { pos: 'verb', def: 'teach' }, 'docet': { pos: 'verb', def: 'teach' }, 'docui': { pos: 'verb', def: 'teach' }, 'doctum': { pos: 'verb', def: 'teach' },
        'possum': { pos: 'verb', def: 'be able' }, 'potest': { pos: 'verb', def: 'be able' }, 'potui': { pos: 'verb', def: 'be able' }, 'posse': { pos: 'verb', def: 'be able' },
        'debeo': { pos: 'verb', def: 'ought, owe' }, 'debet': { pos: 'verb', def: 'ought' }, 'debui': { pos: 'verb', def: 'ought' }, 'debitum': { pos: 'verb', def: 'ought' },
        'iubeo': { pos: 'verb', def: 'order' }, 'iubet': { pos: 'verb', def: 'order' }, 'iussi': { pos: 'verb', def: 'order' }, 'iussum': { pos: 'verb', def: 'order' },
        'nolo': { pos: 'verb', def: 'not want' }, 'non': { pos: 'adverb', def: 'not' }, 'volo': { pos: 'verb', def: 'want, wish' }, 'vult': { pos: 'verb', def: 'want' }, 'volui': { pos: 'verb', def: 'want' }, 'velle': { pos: 'verb', def: 'want' },
        'peto': { pos: 'verb', def: 'seek, attack' }, 'petit': { pos: 'verb', def: 'seek' }, 'petivi': { pos: 'verb', def: 'seek' }, 'petitum': { pos: 'verb', def: 'seek' },
        'quaero': { pos: 'verb', def: 'seek, ask' }, 'quaerit': { pos: 'verb', def: 'seek' }, 'quaesivi': { pos: 'verb', def: 'seek' }, 'quaesitum': { pos: 'verb', def: 'seek' },
        'respondeo': { pos: 'verb', def: 'answer' }, 'respondet': { pos: 'verb', def: 'answer' }, 'respondi': { pos: 'verb', def: 'answer' }, 'responsum': { pos: 'verb', def: 'answer' },
        'rogo': { pos: 'verb', def: 'ask' }, 'rogat': { pos: 'verb', def: 'ask' }, 'rogavi': { pos: 'verb', def: 'ask' }, 'rogatum': { pos: 'verb', def: 'ask' },
        'cupio': { pos: 'verb', def: 'desire' }, 'cupit': { pos: 'verb', def: 'desire' }, 'cupivi': { pos: 'verb', def: 'desire' }, 'cupitum': { pos: 'verb', def: 'desire' },
        'curo': { pos: 'verb', def: 'care for' }, 'curat': { pos: 'verb', def: 'care for' }, 'curavi': { pos: 'verb', def: 'care for' }, 'curatum': { pos: 'verb', def: 'care for' },
        'pugno': { pos: 'verb', def: 'fight' }, 'pugnat': { pos: 'verb', def: 'fight' }, 'pugnavi': { pos: 'verb', def: 'fight' }, 'pugnatum': { pos: 'verb', def: 'fight' },
        'sto': { pos: 'verb', def: 'stand' }, 'stat': { pos: 'verb', def: 'stand' }, 'steti': { pos: 'verb', def: 'stand' }, 'statum': { pos: 'verb', def: 'stand' },
        'sedeo': { pos: 'verb', def: 'sit' }, 'sedet': { pos: 'verb', def: 'sit' }, 'sedi': { pos: 'verb', def: 'sit' }, 'sessum': { pos: 'verb', def: 'sit' },
        'curro': { pos: 'verb', def: 'run' }, 'currit': { pos: 'verb', def: 'run' }, 'cucurri': { pos: 'verb', def: 'run' }, 'cursum': { pos: 'verb', def: 'run' },
        'ambulo': { pos: 'verb', def: 'walk' }, 'ambulat': { pos: 'verb', def: 'walk' }, 'ambulavi': { pos: 'verb', def: 'walk' }, 'ambulatum': { pos: 'verb', def: 'walk' },
        'sto': { pos: 'verb', def: 'stand' }, 'supero': { pos: 'verb', def: 'overcome' }, 'impero': { pos: 'verb', def: 'command' }, 'iudico': { pos: 'verb', def: 'judge' },
        'accedo': { pos: 'verb', def: 'approach' }, 'accipio': { pos: 'verb', def: 'receive' }, 'adsum': { pos: 'verb', def: 'be present' }, 'aperio': { pos: 'verb', def: 'open' },
        'cedo': { pos: 'verb', def: 'yield' }, 'cogito': { pos: 'verb', def: 'think' }, 'cognosco': { pos: 'verb', def: 'learn, know' }, 
        'adduco': { pos: 'verb', def: 'lead, draw, induce' }, 'adducti': { pos: 'participle', def: 'led, induced' },
        'permoveo': { pos: 'verb', def: 'move deeply, influence' }, 'permoti': { pos: 'participle', def: 'moved, influenced' },
        'constituo': { pos: 'verb', def: 'establish, decide, determine, resolve' }, 'constituerunt': { pos: 'verb', def: 'they decided, they established' },
        'proficiscor': { pos: 'verb', def: 'set out, depart' }, 'proficiscendum': { pos: 'noun', case: 'acc sg', def: 'setting out, departure' },
        'pertineo': { pos: 'verb', def: 'extend, pertain' }, 'pertinerent': { pos: 'verb', def: 'they might pertain' },
        'comparo': { pos: 'verb', def: 'prepare, acquire' }, 'comparare': { pos: 'verb', def: 'to prepare, acquire' },
        'coemo': { pos: 'verb', def: 'buy up' }, 'coemere': { pos: 'verb', def: 'to buy up' },
        'conficio': { pos: 'verb', def: 'make, accomplish, complete' }, 'conficiendum': { pos: 'noun', case: 'acc sg', def: 'the finishing, completing' },
        'conficiendas': { pos: 'gerundive', def: 'to be completed, for completing', case: 'acc pl fem' }, 'conficere': { pos: 'verb', def: 'to make, to accomplish' },
        'deligo': { pos: 'verb', def: 'choose, select' }, 'deligit': { pos: 'verb', def: 'he/she chooses' }, 'deligi': { pos: 'verb', def: 'to be chosen' }, 'deligitur': { pos: 'verb', def: 'is chosen' },
        'suppeto': { pos: 'verb', def: 'be available, suffice' }, 'suppeteret': { pos: 'verb', def: 'might be available, might suffice' },
        'confirmo': { pos: 'verb', def: 'strengthen, assure, establish' }, 'confirmare': { pos: 'verb', def: 'to strengthen, assure, establish' },
        'defendo': { pos: 'verb', def: 'defend' }, 'deleo': { pos: 'verb', def: 'destroy' }, 'discedo': { pos: 'verb', def: 'depart' }, 'fero': { pos: 'verb', def: 'bear, carry' },
        'fugio': { pos: 'verb', def: 'flee' }, 'gero': { pos: 'verb', def: 'carry on, wage' }, 'intro': { pos: 'verb', def: 'enter' }, 'iacio': { pos: 'verb', def: 'throw' },
        'invenio': { pos: 'verb', def: 'find' }, 'maneo': { pos: 'verb', def: 'remain' }, 'ostendo': { pos: 'verb', def: 'show' }, 'pervenio': { pos: 'verb', def: 'arrive' },
        'prohibeo': { pos: 'verb', def: 'prevent' }, 'promitto': { pos: 'verb', def: 'promise' }, 'redeo': { pos: 'verb', def: 'return' }, 'regno': { pos: 'verb', def: 'rule' },
        'servo': { pos: 'verb', def: 'save, protect' }, 'supero': { pos: 'verb', def: 'overcome' }, 'trado': { pos: 'verb', def: 'hand over' }, 'traho': { pos: 'verb', def: 'drag' },
        'verto': { pos: 'verb', def: 'turn' }, 'vigilo': { pos: 'verb', def: 'watch' }, 'vulnero': { pos: 'verb', def: 'wound' },
        
        // Common nouns
        'homo': { pos: 'noun', def: 'man, human' }, 'hominis': { pos: 'noun', def: 'man, human' }, 'hominem': { pos: 'noun', def: 'man, human' }, 'homines': { pos: 'noun', def: 'men, humans' },
        'vir': { pos: 'noun', def: 'man, hero' }, 'viri': { pos: 'noun', def: 'man, hero' }, 'virum': { pos: 'noun', def: 'man, hero' },
        'uir': { pos: 'noun', def: 'man, hero' }, 'uiri': { pos: 'noun', def: 'man, hero' }, 'uirum': { pos: 'noun', def: 'man, hero' },
        'femina': { pos: 'noun', def: 'woman' }, 'feminae': { pos: 'noun', def: 'woman' }, 'feminam': { pos: 'noun', def: 'woman' },
        'puella': { pos: 'noun', def: 'girl' }, 'puellae': { pos: 'noun', def: 'girl' }, 'puellam': { pos: 'noun', def: 'girl' },
        'puer': { pos: 'noun', def: 'boy' }, 'pueri': { pos: 'noun', def: 'boy' }, 'puerum': { pos: 'noun', def: 'boy' },
        'rex': { pos: 'noun', def: 'king' }, 'regis': { pos: 'noun', def: 'king' }, 'regem': { pos: 'noun', def: 'king' }, 'reges': { pos: 'noun', def: 'kings' },
        'dux': { pos: 'noun', def: 'leader' }, 'ducis': { pos: 'noun', def: 'leader' }, 'ducem': { pos: 'noun', def: 'leader' },
        'miles': { pos: 'noun', def: 'soldier' }, 'militis': { pos: 'noun', def: 'soldier' }, 'militem': { pos: 'noun', def: 'soldier' },
        'deus': { pos: 'noun', def: 'god' }, 'dei': { pos: 'noun', def: 'god' }, 'deum': { pos: 'noun', def: 'god' }, 'di': { pos: 'noun', def: 'gods' }, 'dii': { pos: 'noun', def: 'gods' },
        'dea': { pos: 'noun', def: 'goddess' }, 'deae': { pos: 'noun', def: 'goddess' }, 'deam': { pos: 'noun', def: 'goddess' },
        'amicus': { pos: 'noun', def: 'friend' }, 'amici': { pos: 'noun', def: 'friend' }, 'amicum': { pos: 'noun', def: 'friend' },
        'pater': { pos: 'noun', def: 'father' }, 'patris': { pos: 'noun', def: 'father' }, 'patrem': { pos: 'noun', def: 'father' }, 'patres': { pos: 'noun', def: 'fathers' },
        'mater': { pos: 'noun', def: 'mother' }, 'matris': { pos: 'noun', def: 'mother' }, 'matrem': { pos: 'noun', def: 'mother' }, 'matres': { pos: 'noun', def: 'mothers' },
        'filius': { pos: 'noun', def: 'son' }, 'filii': { pos: 'noun', def: 'son' }, 'filium': { pos: 'noun', def: 'son' },
        'filia': { pos: 'noun', def: 'daughter' }, 'filiae': { pos: 'noun', def: 'daughter' }, 'filiam': { pos: 'noun', def: 'daughter' },
        'frater': { pos: 'noun', def: 'brother' }, 'fratris': { pos: 'noun', def: 'brother' }, 'fratrem': { pos: 'noun', def: 'brother' },
        'soror': { pos: 'noun', def: 'sister' }, 'sororis': { pos: 'noun', def: 'sister' }, 'sororem': { pos: 'noun', def: 'sister' },
        'uxor': { pos: 'noun', def: 'wife' }, 'uxoris': { pos: 'noun', def: 'wife' }, 'uxorem': { pos: 'noun', def: 'wife' },
        'dominus': { pos: 'noun', def: 'master, lord' }, 'domini': { pos: 'noun', def: 'master' }, 'dominum': { pos: 'noun', def: 'master' },
        'domina': { pos: 'noun', def: 'mistress, lady' }, 'dominae': { pos: 'noun', def: 'mistress' }, 'dominam': { pos: 'noun', def: 'mistress' },
        'servus': { pos: 'noun', def: 'slave, servant' }, 'servi': { pos: 'noun', def: 'slave' }, 'servum': { pos: 'noun', def: 'slave' },
        'urbs': { pos: 'noun', def: 'city' }, 'urbis': { pos: 'noun', def: 'city' }, 'urbem': { pos: 'noun', def: 'city' },
        'civitas': { pos: 'noun', def: 'state, citizenship' }, 'civitatis': { pos: 'noun', def: 'state' }, 'civitatem': { pos: 'noun', def: 'state' },
        'domus': { pos: 'noun', def: 'house, home' }, 'domi': { pos: 'noun', def: 'at home' }, 'domum': { pos: 'noun', def: 'house' },
        'villa': { pos: 'noun', def: 'country house, villa' }, 'villae': { pos: 'noun', def: 'villa' }, 'villam': { pos: 'noun', def: 'villa' },
        'templum': { pos: 'noun', def: 'temple' }, 'templi': { pos: 'noun', def: 'temple' },
        'bellum': { pos: 'noun', def: 'war' }, 'belli': { pos: 'noun', def: 'war' },
        'pax': { pos: 'noun', def: 'peace' }, 'pacis': { pos: 'noun', def: 'peace' }, 'pacem': { pos: 'noun', def: 'peace' },
        'terra': { pos: 'noun', def: 'earth, land' }, 'terrae': { pos: 'noun', def: 'earth' }, 'terram': { pos: 'noun', def: 'earth' },
        'aqua': { pos: 'noun', def: 'water' }, 'aquae': { pos: 'noun', def: 'water' }, 'aquam': { pos: 'noun', def: 'water' },
        'mare': { pos: 'noun', def: 'sea' }, 'maris': { pos: 'noun', def: 'sea' },
        'navis': { pos: 'noun', def: 'ship' }, 'navis': { pos: 'noun', def: 'ship' }, 'navem': { pos: 'noun', def: 'ship' },
        'porta': { pos: 'noun', def: 'gate' }, 'portae': { pos: 'noun', def: 'gate' }, 'portam': { pos: 'noun', def: 'gate' },
        'via': { pos: 'noun', def: 'road, way' }, 'viae': { pos: 'noun', def: 'road' }, 'viam': { pos: 'noun', def: 'road' },
        'corpus': { pos: 'noun', def: 'body' }, 'corporis': { pos: 'noun', def: 'body' },
        'caput': { pos: 'noun', def: 'head' }, 'capitis': { pos: 'noun', def: 'head' },
        'manus': { pos: 'noun', def: 'hand' }, 'manum': { pos: 'noun', def: 'hand' },
        'pes': { pos: 'noun', def: 'foot' }, 'pedis': { pos: 'noun', def: 'foot' }, 'pedem': { pos: 'noun', def: 'foot' },
        'oculus': { pos: 'noun', def: 'eye' }, 'oculi': { pos: 'noun', def: 'eye' }, 'oculum': { pos: 'noun', def: 'eye' },
        'cor': { pos: 'noun', def: 'heart' }, 'cordis': { pos: 'noun', def: 'heart' },
        'animus': { pos: 'noun', def: 'mind, soul' }, 'animi': { pos: 'noun', def: 'mind' }, 'animum': { pos: 'noun', def: 'mind' },
        'anima': { pos: 'noun', def: 'soul, life' }, 'animae': { pos: 'noun', def: 'soul' }, 'animam': { pos: 'noun', def: 'soul' },
        'vita': { pos: 'noun', def: 'life' }, 'vitae': { pos: 'noun', def: 'life' }, 'vitam': { pos: 'noun', def: 'life' },
        'mors': { pos: 'noun', def: 'death' }, 'mortis': { pos: 'noun', def: 'death' }, 'mortem': { pos: 'noun', def: 'death' },
        'tempus': { pos: 'noun', def: 'time' }, 'temporis': { pos: 'noun', def: 'time' },
        'dies': { pos: 'noun', def: 'day' }, 'diei': { pos: 'noun', def: 'day' }, 'diem': { pos: 'noun', def: 'day' },
        'nox': { pos: 'noun', def: 'night' }, 'noctis': { pos: 'noun', def: 'night' }, 'noctem': { pos: 'noun', def: 'night' },
        'annus': { pos: 'noun', def: 'year' }, 'anni': { pos: 'noun', def: 'year' }, 'annum': { pos: 'noun', def: 'year' },
        'hora': { pos: 'noun', def: 'hour' }, 'horae': { pos: 'noun', def: 'hour' }, 'horam': { pos: 'noun', def: 'hour' },
        'lux': { pos: 'noun', def: 'light' }, 'lucis': { pos: 'noun', def: 'light' }, 'lucem': { pos: 'noun', def: 'light' },
        'sol': { pos: 'noun', def: 'sun' }, 'solis': { pos: 'noun', def: 'sun' }, 'solem': { pos: 'noun', def: 'sun' },
        'luna': { pos: 'noun', def: 'moon' }, 'lunae': { pos: 'noun', def: 'moon' }, 'lunam': { pos: 'noun', def: 'moon' },
        'stella': { pos: 'noun', def: 'star' }, 'stellae': { pos: 'noun', def: 'star' }, 'stellam': { pos: 'noun', def: 'star' },
        'caelum': { pos: 'noun', def: 'sky, heaven' }, 'caeli': { pos: 'noun', def: 'sky' },
        'ignis': { pos: 'noun', def: 'fire' }, 'ignem': { pos: 'noun', def: 'fire' },
        'ventus': { pos: 'noun', def: 'wind' }, 'venti': { pos: 'noun', def: 'wind' }, 'ventum': { pos: 'noun', def: 'wind' },
        'mons': { pos: 'noun', def: 'mountain' }, 'montis': { pos: 'noun', def: 'mountain' }, 'montem': { pos: 'noun', def: 'mountain' },
        'silva': { pos: 'noun', def: 'forest' }, 'silvae': { pos: 'noun', def: 'forest' }, 'silvam': { pos: 'noun', def: 'forest' },
        'flumen': { pos: 'noun', def: 'river' }, 'fluminis': { pos: 'noun', def: 'river' },
        'campus': { pos: 'noun', def: 'field, plain' }, 'campi': { pos: 'noun', def: 'field' }, 'campum': { pos: 'noun', def: 'field' },
        'arbor': { pos: 'noun', def: 'tree' }, 'arboris': { pos: 'noun', def: 'tree' }, 'arborem': { pos: 'noun', def: 'tree' },
        'flos': { pos: 'noun', def: 'flower' }, 'floris': { pos: 'noun', def: 'flower' }, 'florem': { pos: 'noun', def: 'flower' },
        'equus': { pos: 'noun', def: 'horse' }, 'equi': { pos: 'noun', def: 'horse' }, 'equum': { pos: 'noun', def: 'horse' },
        'canis': { pos: 'noun', def: 'dog' }, 'canem': { pos: 'noun', def: 'dog' },
        'animal': { pos: 'noun', def: 'animal' }, 'animalis': { pos: 'noun', def: 'animal' },
        'liber': { pos: 'noun', def: 'book' }, 'libri': { pos: 'noun', def: 'book' }, 'librum': { pos: 'noun', def: 'book' },
        'verbum': { pos: 'noun', def: 'word' }, 'verbi': { pos: 'noun', def: 'word' },
        'nomen': { pos: 'noun', def: 'name' }, 'nominis': { pos: 'noun', def: 'name' },
        'vox': { pos: 'noun', def: 'voice, word' }, 'vocis': { pos: 'noun', def: 'voice' }, 'vocem': { pos: 'noun', def: 'voice' },
        'res': { pos: 'noun', def: 'thing, matter' }, 'rei': { pos: 'noun', case: 'gen/dat sg', def: 'thing' }, 'rem': { pos: 'noun', case: 'acc sg', def: 'thing' }, 'rebus': { pos: 'noun', case: 'dat/abl pl', def: 'things' },
        'auctoritas': { pos: 'noun', def: 'authority, influence' }, 'auctoritatem': { pos: 'noun', case: 'acc sg', def: 'authority' }, 'auctoritate': { pos: 'noun', case: 'abl sg', def: 'authority' },
        'orgetorix': { pos: 'proper-noun', def: 'Orgetorix' }, 'orgetorigis': { pos: 'proper-noun', case: 'gen sg', def: 'of Orgetorix' },
        'iumentum': { pos: 'noun', def: 'pack animal, beast of burden' }, 'iumenta': { pos: 'noun', def: 'pack animals' }, 'iumentorum': { pos: 'noun', case: 'gen pl', def: 'of pack animals' },
        'carrus': { pos: 'noun', def: 'cart, wagon' }, 'carri': { pos: 'noun', def: 'cart' }, 'carrorum': { pos: 'noun', case: 'gen pl', def: 'of carts' },
        'numerus': { pos: 'noun', def: 'number' }, 'numeri': { pos: 'noun', def: 'number' }, 'numerum': { pos: 'noun', case: 'acc sg', def: 'number' },
        'semen': { pos: 'noun', def: 'seed' }, 'sementes': { pos: 'noun', case: 'acc pl', def: 'seeds' },
        'iter': { pos: 'noun', def: 'journey, route' }, 'itinere': { pos: 'noun', case: 'abl sg', def: 'on the journey' },
        'frumentum': { pos: 'noun', def: 'grain, corn' }, 'frumenti': { pos: 'noun', case: 'gen sg', def: 'of grain' },
        'civitas': { pos: 'noun', def: 'state, tribe, citizenship' }, 'civitati': { pos: 'noun', def: 'to the state' }, 'civitatibus': { pos: 'noun', case: 'dat/abl pl', def: 'to/with the states' },
        'amicitia': { pos: 'noun', def: 'friendship' }, 'amicitiam': { pos: 'noun', case: 'acc sg', def: 'friendship' },
        'causa': { pos: 'noun', def: 'cause, reason, case' }, 'causae': { pos: 'noun', def: 'cause' }, 'causam': { pos: 'noun', def: 'cause' },
        'lex': { pos: 'noun', def: 'law' }, 'legis': { pos: 'noun', def: 'law' }, 'legem': { pos: 'noun', def: 'law' },
        'ius': { pos: 'noun', def: 'right, law' }, 'iuris': { pos: 'noun', def: 'right' },
        'virtus': { pos: 'noun', def: 'courage, virtue' }, 'virtutis': { pos: 'noun', def: 'virtue' }, 'virtutem': { pos: 'noun', def: 'virtue' },
        'gloria': { pos: 'noun', def: 'glory' }, 'gloriae': { pos: 'noun', def: 'glory' }, 'gloriam': { pos: 'noun', def: 'glory' },
        'amor': { pos: 'noun', def: 'love' }, 'amoris': { pos: 'noun', def: 'love' }, 'amorem': { pos: 'noun', def: 'love' },
        'odium': { pos: 'noun', def: 'hatred' }, 'odii': { pos: 'noun', def: 'hatred' },
        'gaudium': { pos: 'noun', def: 'joy' }, 'gaudii': { pos: 'noun', def: 'joy' },
        'dolor': { pos: 'noun', def: 'pain, grief' }, 'doloris': { pos: 'noun', def: 'pain' }, 'dolorem': { pos: 'noun', def: 'pain' },
        'spes': { pos: 'noun', def: 'hope' }, 'spei': { pos: 'noun', def: 'hope' }, 'spem': { pos: 'noun', def: 'hope' },
        'timor': { pos: 'noun', def: 'fear' }, 'timoris': { pos: 'noun', def: 'fear' }, 'timorem': { pos: 'noun', def: 'fear' },
        'consul': { pos: 'noun', def: 'consul' }, 'consulis': { pos: 'noun', def: 'consul' }, 'consulem': { pos: 'noun', def: 'consul' },
        'senatus': { pos: 'noun', def: 'senate' }, 'senatus': { pos: 'noun', def: 'senate' },
        'populus': { pos: 'noun', def: 'people' }, 'populi': { pos: 'noun', def: 'people' }, 'populum': { pos: 'noun', def: 'people' },
        'plebs': { pos: 'noun', def: 'common people' }, 'plebis': { pos: 'noun', def: 'common people' }, 'plebem': { pos: 'noun', def: 'common people' },
        'gens': { pos: 'noun', def: 'nation, clan' }, 'gentis': { pos: 'noun', def: 'nation' }, 'gentem': { pos: 'noun', def: 'nation' },
        'locus': { pos: 'noun', def: 'place' }, 'loci': { pos: 'noun', def: 'place' }, 'locum': { pos: 'noun', def: 'place' },
        'numerus': { pos: 'noun', def: 'number' }, 'numeri': { pos: 'noun', def: 'number' }, 'numerum': { pos: 'noun', def: 'number' },
        'pars': { pos: 'noun', def: 'part' }, 'partis': { pos: 'noun', def: 'part' }, 'partem': { pos: 'noun', def: 'part' }, 'partes': { pos: 'noun', def: 'parts' }, 'partium': { pos: 'noun', def: 'parts' },
        'lingua': { pos: 'noun', def: 'tongue, language' }, 'linguae': { pos: 'noun', def: 'language' }, 'linguam': { pos: 'noun', def: 'language' },
        'gallia': { pos: 'noun', def: 'Gaul' }, 'galliae': { pos: 'noun', def: 'Gaul' }, 'galliam': { pos: 'noun', def: 'Gaul' },
        'belgae': { pos: 'noun', def: 'Belgians' }, 'belgarum': { pos: 'noun', def: 'Belgians' },
        'aquitani': { pos: 'noun', def: 'Aquitanians' }, 'aquitanorum': { pos: 'noun', def: 'Aquitanians' },
        'celtae': { pos: 'noun', def: 'Celts' }, 'celtarum': { pos: 'noun', def: 'Celts' },
        'galli': { pos: 'noun', def: 'Gauls' }, 'gallorum': { pos: 'noun', def: 'Gauls' }, 'gallos': { pos: 'noun', def: 'Gauls' },
        'modus': { pos: 'noun', def: 'manner, way' }, 'modi': { pos: 'noun', def: 'manner' }, 'modum': { pos: 'noun', def: 'manner' },
        'consilium': { pos: 'noun', def: 'plan, advice' }, 'consilii': { pos: 'noun', def: 'plan' },
        'imperium': { pos: 'noun', def: 'command, empire' }, 'imperii': { pos: 'noun', def: 'command' },
        'regnum': { pos: 'noun', def: 'kingdom' }, 'regni': { pos: 'noun', def: 'kingdom' },
        'arma': { pos: 'noun', def: 'arms, weapons' }, 'armorum': { pos: 'noun', def: 'arms' },
        'telum': { pos: 'noun', def: 'weapon, javelin' }, 'teli': { pos: 'noun', def: 'weapon' },
        'gladius': { pos: 'noun', def: 'sword' }, 'gladii': { pos: 'noun', def: 'sword' }, 'gladium': { pos: 'noun', def: 'sword' },
        'copia': { pos: 'noun', def: 'abundance, forces' }, 'copiae': { pos: 'noun', def: 'forces' }, 'copiam': { pos: 'noun', def: 'abundance' },
        'fortuna': { pos: 'noun', def: 'fortune, luck' }, 'fortunae': { pos: 'noun', def: 'fortune' }, 'fortunam': { pos: 'noun', def: 'fortune' },
        'fatum': { pos: 'noun', def: 'fate' }, 'fati': { pos: 'noun', def: 'fate' },
        'natura': { pos: 'noun', def: 'nature' }, 'naturae': { pos: 'noun', def: 'nature' }, 'naturam': { pos: 'noun', def: 'nature' },
        'fides': { pos: 'noun', def: 'faith, trust' }, 'fidei': { pos: 'noun', def: 'faith' }, 'fidem': { pos: 'noun', def: 'faith' },
        'veritas': { pos: 'noun', def: 'truth' }, 'veritatis': { pos: 'noun', def: 'truth' }, 'veritatem': { pos: 'noun', def: 'truth' },
        
        // Adjectives
        'bonus': { pos: 'adjective', def: 'good' }, 'bona': { pos: 'adjective', def: 'good' }, 'bonum': { pos: 'adjective', def: 'good' },
        'malus': { pos: 'adjective', def: 'bad, evil' }, 'mala': { pos: 'adjective', def: 'bad' }, 'malum': { pos: 'adjective', def: 'bad' },
        'magnus': { pos: 'adjective', def: 'great, large' }, 'magna': { pos: 'adjective', def: 'great' }, 'magnum': { pos: 'adjective', def: 'great' },
        'parvus': { pos: 'adjective', def: 'small' }, 'parva': { pos: 'adjective', def: 'small' }, 'parvum': { pos: 'adjective', def: 'small' },
        'longus': { pos: 'adjective', def: 'long' }, 'longa': { pos: 'adjective', def: 'long' }, 'longum': { pos: 'adjective', def: 'long' },
        'brevis': { pos: 'adjective', def: 'short, brief' }, 'breve': { pos: 'adjective', def: 'short' },
        'altus': { pos: 'adjective', def: 'high, deep' }, 'alta': { pos: 'adjective', def: 'high' }, 'altum': { pos: 'adjective', def: 'high' },
        'novus': { pos: 'adjective', def: 'new' }, 'nova': { pos: 'adjective', def: 'new' }, 'novum': { pos: 'adjective', def: 'new' },
        'vetus': { pos: 'adjective', def: 'old' }, 'veteris': { pos: 'adjective', def: 'old' },
        'multus': { pos: 'adjective', def: 'much, many' }, 'multa': { pos: 'adjective', def: 'much' }, 'multum': { pos: 'adjective', def: 'much' }, 'multi': { pos: 'adjective', def: 'many' },
        'paucus': { pos: 'adjective', def: 'few' }, 'pauca': { pos: 'adjective', def: 'few' }, 'paucum': { pos: 'adjective', def: 'few' }, 'pauci': { pos: 'adjective', def: 'few' },
        'totus': { pos: 'adjective', def: 'whole, all' }, 'tota': { pos: 'adjective', def: 'whole' }, 'totum': { pos: 'adjective', def: 'whole' },
        'omnis': { pos: 'adjective', def: 'all, every', case: 'nom/gen sg' }, 'omne': { pos: 'adjective', def: 'all', case: 'nom/acc sg neut' }, 'omnes': { pos: 'adjective', def: 'all', case: 'nom/acc pl' },
        'nullus': { pos: 'adjective', def: 'no, none' }, 'nulla': { pos: 'adjective', def: 'no' }, 'nullum': { pos: 'adjective', def: 'no' },
        'primus': { pos: 'adjective', def: 'first' }, 'prima': { pos: 'adjective', def: 'first' }, 'primum': { pos: 'adjective', def: 'first' },
        'ultimus': { pos: 'adjective', def: 'last, farthest' }, 'ultima': { pos: 'adjective', def: 'last' }, 'ultimum': { pos: 'adjective', def: 'last' },
        'summus': { pos: 'adjective', def: 'highest, greatest' }, 'summa': { pos: 'adjective', def: 'highest' }, 'summum': { pos: 'adjective', def: 'highest' },
        'medius': { pos: 'adjective', def: 'middle' }, 'media': { pos: 'adjective', def: 'middle' }, 'medium': { pos: 'adjective', def: 'middle' },
        'alius': { pos: 'adjective', def: 'other, another' }, 'alia': { pos: 'adjective', def: 'other' }, 'aliud': { pos: 'adjective', def: 'other' },
        'alter': { pos: 'adjective', def: 'other (of two)' }, 'altera': { pos: 'adjective', def: 'other' }, 'alterum': { pos: 'adjective', def: 'other' },
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' },
        'duo': { pos: 'adjective', def: 'two' }, 'duae': { pos: 'adjective', def: 'two' },
        'tres': { pos: 'adjective', def: 'three' }, 'tria': { pos: 'adjective', def: 'three' },
        'pulcher': { pos: 'adjective', def: 'beautiful' }, 'pulchra': { pos: 'adjective', def: 'beautiful' }, 'pulchrum': { pos: 'adjective', def: 'beautiful' },
        'fortis': { pos: 'adjective', def: 'brave, strong' }, 'forte': { pos: 'adjective', def: 'brave' },
        'felix': { pos: 'adjective', def: 'happy, fortunate' }, 'felicis': { pos: 'adjective', def: 'happy' }, 'felicem': { pos: 'adjective', def: 'happy' },
        'miser': { pos: 'adjective', def: 'wretched, unhappy' }, 'misera': { pos: 'adjective', def: 'wretched' }, 'miserum': { pos: 'adjective', def: 'wretched' },
        'laetus': { pos: 'adjective', def: 'happy, joyful' }, 'laeta': { pos: 'adjective', def: 'happy' }, 'laetum': { pos: 'adjective', def: 'happy' },
        'tristis': { pos: 'adjective', def: 'sad' }, 'triste': { pos: 'adjective', def: 'sad' },
        'clarus': { pos: 'adjective', def: 'clear, famous' }, 'clara': { pos: 'adjective', def: 'clear' }, 'clarum': { pos: 'adjective', def: 'clear' },
        'notus': { pos: 'adjective', def: 'known, famous' }, 'nota': { pos: 'adjective', def: 'known' }, 'notum': { pos: 'adjective', def: 'known' },
        'ignotus': { pos: 'adjective', def: 'unknown' }, 'ignota': { pos: 'adjective', def: 'unknown' }, 'ignotum': { pos: 'adjective', def: 'unknown' },
        'certus': { pos: 'adjective', def: 'certain, sure' }, 'certa': { pos: 'adjective', def: 'certain' }, 'certum': { pos: 'adjective', def: 'certain' },
        'verus': { pos: 'adjective', def: 'true, real' }, 'vera': { pos: 'adjective', def: 'true' }, 'verum': { pos: 'adjective', def: 'true' },
        'falsus': { pos: 'adjective', def: 'false' }, 'falsa': { pos: 'adjective', def: 'false' }, 'falsum': { pos: 'adjective', def: 'false' },
        'iustus': { pos: 'adjective', def: 'just, fair' }, 'iusta': { pos: 'adjective', def: 'just' }, 'iustum': { pos: 'adjective', def: 'just' },
        'sanctus': { pos: 'adjective', def: 'holy, sacred' }, 'sancta': { pos: 'adjective', def: 'holy' }, 'sanctum': { pos: 'adjective', def: 'holy' },
        'sacer': { pos: 'adjective', def: 'sacred' }, 'sacra': { pos: 'adjective', def: 'sacred' }, 'sacrum': { pos: 'adjective', def: 'sacred' },
        'liber': { pos: 'adjective', def: 'free' }, 'libera': { pos: 'adjective', def: 'free' }, 'liberum': { pos: 'adjective', def: 'free' },
        'gravis': { pos: 'adjective', def: 'heavy, serious' }, 'grave': { pos: 'adjective', def: 'heavy' },
        'levis': { pos: 'adjective', def: 'light, slight' }, 'leve': { pos: 'adjective', def: 'light' },
        'durus': { pos: 'adjective', def: 'hard' }, 'dura': { pos: 'adjective', def: 'hard' }, 'durum': { pos: 'adjective', def: 'hard' },
        'mollis': { pos: 'adjective', def: 'soft' }, 'molle': { pos: 'adjective', def: 'soft' },
        'celer': { pos: 'adjective', def: 'swift, quick' }, 'celeris': { pos: 'adjective', def: 'swift' }, 'celere': { pos: 'adjective', def: 'swift' },
        'tardus': { pos: 'adjective', def: 'slow' }, 'tarda': { pos: 'adjective', def: 'slow' }, 'tardum': { pos: 'adjective', def: 'slow' },
        'sapiens': { pos: 'adjective', def: 'wise' }, 'sapientis': { pos: 'adjective', def: 'wise' },
        'stultus': { pos: 'adjective', def: 'foolish' }, 'stulta': { pos: 'adjective', def: 'foolish' }, 'stultum': { pos: 'adjective', def: 'foolish' },
        'divinus': { pos: 'adjective', def: 'divine' }, 'divina': { pos: 'adjective', def: 'divine' }, 'divinum': { pos: 'adjective', def: 'divine' },
        'humanus': { pos: 'adjective', def: 'human' }, 'humana': { pos: 'adjective', def: 'human' }, 'humanum': { pos: 'adjective', def: 'human' },
        'publicus': { pos: 'adjective', def: 'public' }, 'publica': { pos: 'adjective', def: 'public' }, 'publicum': { pos: 'adjective', def: 'public' },
        'privatus': { pos: 'adjective', def: 'private' }, 'privata': { pos: 'adjective', def: 'private' }, 'privatum': { pos: 'adjective', def: 'private' },
        'proprius': { pos: 'adjective', def: 'one\'s own' }, 'propria': { pos: 'adjective', def: 'one\'s own' }, 'proprium': { pos: 'adjective', def: 'one\'s own' },
        'communis': { pos: 'adjective', def: 'common, shared' }, 'commune': { pos: 'adjective', def: 'common' },
        'perpetuus': { pos: 'adjective', def: 'continuous, perpetual' }, 'perpetua': { pos: 'adjective', def: 'continuous' }, 'perpetuum': { pos: 'adjective', def: 'continuous' },
        'aeternus': { pos: 'adjective', def: 'eternal' }, 'aeterna': { pos: 'adjective', def: 'eternal' }, 'aeternum': { pos: 'adjective', def: 'eternal' },
        'suus': { pos: 'adjective', def: 'his/her/its own' }, 'sua': { pos: 'adjective', def: 'his/her/its own' }, 'suum': { pos: 'adjective', def: 'his/her/its own' },
        
        // Pronouns and adjectives for pronouns
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' }, 'unam': { pos: 'adjective', def: 'one' }, 'unius': { pos: 'adjective', def: 'one' },
        'alius': { pos: 'adjective', def: 'another, other' }, 'alia': { pos: 'adjective', def: 'another' }, 'aliud': { pos: 'adjective', def: 'another' }, 'aliam': { pos: 'adjective', def: 'another' },
        'tertius': { pos: 'adjective', def: 'third' }, 'tertia': { pos: 'adjective', def: 'third' }, 'tertium': { pos: 'adjective', def: 'third' }, 'tertiam': { pos: 'adjective', def: 'third' },
        'noster': { pos: 'adjective', def: 'our' }, 'nostra': { pos: 'adjective', def: 'our' }, 'nostrum': { pos: 'adjective', def: 'our' }, 'nostri': { pos: 'adjective', def: 'our' },
        'vester': { pos: 'adjective', def: 'your' }, 'vestra': { pos: 'adjective', def: 'your' }, 'vestrum': { pos: 'adjective', def: 'your' },
        'ipse': { pos: 'pronoun', def: 'himself, herself, itself' }, 'ipsa': { pos: 'pronoun', def: 'herself' }, 'ipsum': { pos: 'pronoun', def: 'itself' }, 'ipsorum': { pos: 'pronoun', def: 'of themselves' }, 'ipsius': { pos: 'pronoun', def: 'of himself/herself' },
        'ego': { pos: 'pronoun', def: 'I' }, 'mei': { pos: 'pronoun', def: 'me' }, 'mihi': { pos: 'pronoun', def: 'to me' }, 'me': { pos: 'pronoun', def: 'me' },
        'tu': { pos: 'pronoun', def: 'you (sg.)' }, 'tui': { pos: 'pronoun', def: 'you' }, 'tibi': { pos: 'pronoun', def: 'to you' }, 'te': { pos: 'pronoun', def: 'you' },
        'nos': { pos: 'pronoun', def: 'we' }, 'nostri': { pos: 'pronoun', def: 'us' }, 'nobis': { pos: 'pronoun', def: 'to us, us' },
        'vos': { pos: 'pronoun', def: 'you (pl.)' }, 'vestri': { pos: 'pronoun', def: 'you' }, 'vobis': { pos: 'pronoun', def: 'to you, you' },
        'se': { pos: 'pronoun', case: 'acc/abl', def: 'himself, herself, itself, themselves' }, 'sui': { pos: 'pronoun', case: 'gen', def: 'of himself/herself' }, 'sibi': { pos: 'pronoun', case: 'dat', def: 'to himself/herself' },
        'is': { pos: 'pronoun', def: 'he, this' }, 'ea': { pos: 'pronoun', def: 'she, this' }, 'id': { pos: 'pronoun', def: 'it, this' },
        'eum': { pos: 'pronoun', def: 'him' }, 'eam': { pos: 'pronoun', def: 'her' }, 'eos': { pos: 'pronoun', def: 'them (m.)' }, 'eas': { pos: 'pronoun', def: 'them (f.)' },
        'hic': { pos: 'pronoun', def: 'this' }, 'haec': { pos: 'pronoun', def: 'this' }, 'hoc': { pos: 'pronoun', def: 'this' }, 'his': { pos: 'pronoun', case: 'dat/abl pl', number: 'plural', def: 'these' },
        'ille': { pos: 'pronoun', def: 'that' }, 'illa': { pos: 'pronoun', def: 'that' }, 'illud': { pos: 'pronoun', def: 'that' },
        'iste': { pos: 'pronoun', def: 'that (of yours)' }, 'ista': { pos: 'pronoun', def: 'that' }, 'istud': { pos: 'pronoun', def: 'that' },
        'ipse': { pos: 'pronoun', def: 'himself, herself, itself' }, 'ipsa': { pos: 'pronoun', def: 'herself' }, 'ipsum': { pos: 'pronoun', def: 'itself' },
        'qui': { pos: 'pronoun', def: 'who, which' }, 'quae': { pos: 'pronoun', def: 'who, which' }, 'quod': { pos: 'pronoun', def: 'which, that' }, 'quarum': { pos: 'pronoun', def: 'of whom/which' }, 'quorum': { pos: 'pronoun', def: 'of whom/which' }, 'quos': { pos: 'pronoun', def: 'whom/which' }, 'quas': { pos: 'pronoun', def: 'whom/which' },
        'quem': { pos: 'pronoun', def: 'whom' }, 'quam': { pos: 'pronoun', def: 'whom, which' }, 'quo': { pos: 'pronoun', def: 'by whom/which' },
        'quos': { pos: 'pronoun', def: 'whom (pl.)' }, 'quas': { pos: 'pronoun', def: 'whom (pl.)' },
        'cui': { pos: 'pronoun', def: 'to whom' }, 'cuius': { pos: 'pronoun', def: 'whose' }, 'quorum': { pos: 'pronoun', def: 'whose (pl.)' }, 'quarum': { pos: 'pronoun', def: 'whose (pl.)' },
        'quibus': { pos: 'pronoun', def: 'to/by whom (pl.)' },
        'quis': { pos: 'pronoun', def: 'who?, what?' }, 'quid': { pos: 'pronoun', def: 'what?' },
        'aliquis': { pos: 'pronoun', def: 'someone, something' }, 'aliquid': { pos: 'pronoun', def: 'something' },
        'nemo': { pos: 'pronoun', def: 'no one' }, 'nihil': { pos: 'pronoun', def: 'nothing' },
        
        // Prepositions & Conjunctions
        'in': { pos: 'preposition', def: 'in, into, on' },
        'ad': { pos: 'preposition', def: 'to, toward, at' },
        'ex': { pos: 'preposition', def: 'out of, from' }, 'e': { pos: 'preposition', def: 'out of, from' },
        'de': { pos: 'preposition', def: 'from, down from, about, concerning' },
        'cum': { pos: 'preposition', def: 'with' },
        'sine': { pos: 'preposition', def: 'without' },
        'pro': { pos: 'preposition', def: 'for, on behalf of, in front of' },
        'per': { pos: 'preposition', def: 'through, by means of' },
        'inter': { pos: 'preposition', def: 'between, among' },
        'propter': { pos: 'preposition', def: 'on account of, because of' },
        'post': { pos: 'preposition', def: 'after, behind' },
        'ante': { pos: 'preposition', def: 'before, in front of' },
        'sub': { pos: 'preposition', def: 'under, beneath' },
        'super': { pos: 'preposition', def: 'over, above' },
        'trans': { pos: 'preposition', def: 'across' },
        'circum': { pos: 'preposition', def: 'around' },
        'contra': { pos: 'preposition', def: 'against' },
        'apud': { pos: 'preposition', def: 'at, near, among' },
        'ab': { pos: 'preposition', def: 'from, by' }, 'a': { pos: 'preposition', def: 'from, by' },
        'et': { pos: 'conjunction', def: 'and' },
        'sed': { pos: 'conjunction', def: 'but' },
        'aut': { pos: 'conjunction', def: 'or' },
        'vel': { pos: 'conjunction', def: 'or' },
        'ac': { pos: 'conjunction', def: 'and' },
        'atque': { pos: 'conjunction', def: 'and' },
        'neque': { pos: 'conjunction', def: 'and not, nor' }, 'nec': { pos: 'conjunction', def: 'and not, nor' },
        'enim': { pos: 'conjunction', def: 'for' },
        'autem': { pos: 'conjunction', def: 'but, however' },
        'igitur': { pos: 'conjunction', def: 'therefore' },
        'ergo': { pos: 'conjunction', def: 'therefore' },
        'itaque': { pos: 'conjunction', def: 'and so, therefore' },
        'quoque': { pos: 'adverb', def: 'also, too' },
        'nam': { pos: 'conjunction', def: 'for' },
        'tamen': { pos: 'conjunction', def: 'however, nevertheless' },
        'si': { pos: 'conjunction', def: 'if' },
        'nisi': { pos: 'conjunction', def: 'if not, unless' },
        'ut': { pos: 'conjunction', def: 'as, when, that, so that' },
        'ne': { pos: 'conjunction', def: 'that not, lest' },
        'cum': { pos: 'conjunction', def: 'when, since, although' },
        'dum': { pos: 'conjunction', def: 'while, until' },
        'quod': { pos: 'conjunction', def: 'because, that' },
        'quia': { pos: 'conjunction', def: 'because' },
        'quoniam': { pos: 'conjunction', def: 'since, because' },
        'quando': { pos: 'conjunction', def: 'when' },
        'ubi': { pos: 'adverb', def: 'where, when' },
        
        // Adverbs
        'semper': { pos: 'adverb', def: 'always' },
        'numquam': { pos: 'adverb', def: 'never' },
        'saepe': { pos: 'adverb', def: 'often' },
        'iam': { pos: 'adverb', def: 'now, already' },
        'nunc': { pos: 'adverb', def: 'now' },
        'tunc': { pos: 'adverb', def: 'then' },
        'tum': { pos: 'adverb', def: 'then' },
        'hodie': { pos: 'adverb', def: 'today' },
        'heri': { pos: 'adverb', def: 'yesterday' },
        'cras': { pos: 'adverb', def: 'tomorrow' },
        'mox': { pos: 'adverb', def: 'soon' },
        'statim': { pos: 'adverb', def: 'immediately' },
        'diu': { pos: 'adverb', def: 'for a long time' },
        'bene': { pos: 'adverb', def: 'well' },
        'male': { pos: 'adverb', def: 'badly' },
        'valde': { pos: 'adverb', def: 'very, greatly' },
        'nimis': { pos: 'adverb', def: 'too much' },
        'satis': { pos: 'adverb', def: 'enough' },
        'parum': { pos: 'adverb', def: 'too little' },
        'ita': { pos: 'adverb', def: 'thus, so' },
        'sic': { pos: 'adverb', def: 'thus, so' },
        'tam': { pos: 'adverb', def: 'so' },
        'quam': { pos: 'adverb', def: 'than, as' },
        'magis': { pos: 'adverb', def: 'more' },
        'maxime': { pos: 'adverb', def: 'most, especially' },
        'minus': { pos: 'adverb', def: 'less' },
        'minime': { pos: 'adverb', def: 'least, not at all' },
        'etiam': { pos: 'adverb', def: 'also, even' },
        'quoque': { pos: 'adverb', def: 'also' },
        'tantum': { pos: 'adverb', def: 'only' },
        'solum': { pos: 'adverb', def: 'only' },
        'modo': { pos: 'adverb', def: 'only, just' },
        'quidem': { pos: 'adverb', def: 'indeed' },
        'certe': { pos: 'adverb', def: 'certainly' },
        'vero': { pos: 'adverb', def: 'truly, indeed' },
        'forte': { pos: 'adverb', def: 'by chance' },
        'forsitan': { pos: 'adverb', def: 'perhaps' },
        'fortasse': { pos: 'adverb', def: 'perhaps' },
        'hic': { pos: 'adverb', def: 'here' },
        'ibi': { pos: 'adverb', def: 'there' },
        'illic': { pos: 'adverb', def: 'there' },
        'hinc': { pos: 'adverb', def: 'from here' },
        'inde': { pos: 'adverb', def: 'from there' },
        'unde': { pos: 'adverb', def: 'from where' },
        'quo': { pos: 'adverb', def: 'to where' },
        'cur': { pos: 'adverb', def: 'why' },
        'quare': { pos: 'adverb', def: 'why, wherefore' },
        'quomodo': { pos: 'adverb', def: 'how' },
        
        // === AENEID-SPECIFIC VOCABULARY ===
        // Epic nouns - arma/bellum/war vocabulary
        'arma': { pos: 'noun', def: 'arms, weapons' }, 'armis': { pos: 'noun', def: 'arms, weapons' }, 'armorum': { pos: 'noun', def: 'arms, weapons' },
        'bellum': { pos: 'noun', def: 'war' }, 'belli': { pos: 'noun', def: 'war' }, 'bello': { pos: 'noun', def: 'war' }, 'bella': { pos: 'noun', def: 'wars' }, 'bellis': { pos: 'noun', def: 'wars' },
        'proelium': { pos: 'noun', def: 'battle' }, 'proelia': { pos: 'noun', def: 'battles' }, 'proelio': { pos: 'noun', def: 'battle' },
        'pugna': { pos: 'noun', def: 'fight, battle' }, 'pugnae': { pos: 'noun', def: 'fight, battle' }, 'pugnam': { pos: 'noun', def: 'fight, battle' },
        'gladius': { pos: 'noun', def: 'sword' }, 'gladii': { pos: 'noun', def: 'sword' }, 'gladio': { pos: 'noun', def: 'sword' }, 'gladium': { pos: 'noun', def: 'sword' },
        'telum': { pos: 'noun', def: 'weapon, missile' }, 'tela': { pos: 'noun', def: 'weapons' }, 'telis': { pos: 'noun', def: 'weapons' },
        'hasta': { pos: 'noun', def: 'spear' }, 'hastae': { pos: 'noun', def: 'spear' }, 'hastam': { pos: 'noun', def: 'spear' },
        'sagitta': { pos: 'noun', def: 'arrow' }, 'sagittae': { pos: 'noun', def: 'arrow' }, 'sagittam': { pos: 'noun', def: 'arrow' },
        
        // Important Aeneid characters and places
        'troianus': { pos: 'adjective', def: 'Trojan' }, 'troiana': { pos: 'adjective', def: 'Trojan' }, 'troianum': { pos: 'adjective', def: 'Trojan' },
        'troia': { pos: 'noun', def: 'Troy' }, 'troiae': { pos: 'noun', def: 'Troy' }, 'troiam': { pos: 'noun', def: 'Troy' },
        'ilium': { pos: 'noun', def: 'Ilium, Troy' }, 'ilii': { pos: 'noun', def: 'Ilium, Troy' }, 'ilio': { pos: 'noun', def: 'Ilium, Troy' },
        'aeneas': { pos: 'noun', def: 'Aeneas' }, 'aeneae': { pos: 'noun', def: 'Aeneas' }, 'aenean': { pos: 'noun', def: 'Aeneas' },
        'italia': { pos: 'noun', def: 'Italy' }, 'italiae': { pos: 'noun', def: 'Italy' }, 'italiam': { pos: 'noun', def: 'Italy' },
        'latium': { pos: 'noun', def: 'Latium' }, 'latii': { pos: 'noun', def: 'Latium' }, 'latio': { pos: 'noun', def: 'Latium' },
        'roma': { pos: 'noun', def: 'Rome' }, 'romae': { pos: 'noun', def: 'Rome' }, 'romam': { pos: 'noun', def: 'Rome' },
        'carthago': { pos: 'noun', def: 'Carthage' }, 'carthaginis': { pos: 'noun', def: 'Carthage' }, 'carthagine': { pos: 'noun', def: 'Carthage' },
        
        // Epic verbs - commonly used in Aeneid
        'cano': { pos: 'verb', def: 'sing' }, 'canis': { pos: 'verb', def: 'sing' }, 'canit': { pos: 'verb', def: 'sing' }, 'canimus': { pos: 'verb', def: 'sing' }, 'canunt': { pos: 'verb', def: 'sing' }, 'cecini': { pos: 'verb', def: 'sang' }, 'canere': { pos: 'verb', def: 'sing' },
        'fero': { pos: 'verb', def: 'carry, bear' }, 'fers': { pos: 'verb', def: 'carry' }, 'fert': { pos: 'verb', def: 'carry' }, 'ferimus': { pos: 'verb', def: 'carry' }, 'ferunt': { pos: 'verb', def: 'carry' }, 'tuli': { pos: 'verb', def: 'carried' }, 'latum': { pos: 'verb', def: 'carried' }, 'ferre': { pos: 'verb', def: 'carry' },
        'fugio': { pos: 'verb', def: 'flee' }, 'fugis': { pos: 'verb', def: 'flee' }, 'fugit': { pos: 'verb', def: 'flee' }, 'fugimus': { pos: 'verb', def: 'flee' }, 'fugiunt': { pos: 'verb', def: 'flee' }, 'fugi': { pos: 'verb', def: 'fled' }, 'fugere': { pos: 'verb', def: 'flee' },
        'cado': { pos: 'verb', def: 'fall' }, 'cadis': { pos: 'verb', def: 'fall' }, 'cadit': { pos: 'verb', def: 'fall' }, 'cadunt': { pos: 'verb', def: 'fall' }, 'cecidi': { pos: 'verb', def: 'fell' }, 'casum': { pos: 'verb', def: 'fallen' }, 'cadere': { pos: 'verb', def: 'fall' },
        'peto': { pos: 'verb', def: 'seek, attack' }, 'petis': { pos: 'verb', def: 'seek' }, 'petunt': { pos: 'verb', def: 'seek' }, 'petere': { pos: 'verb', def: 'seek' },
        'vinco': { pos: 'verb', def: 'conquer' }, 'vincis': { pos: 'verb', def: 'conquer' }, 'vincere': { pos: 'verb', def: 'conquer' },
        'appello': { pos: 'verb', def: 'call, name' }, 'appellat': { pos: 'verb', def: 'call' }, 'appellantur': { pos: 'verb', def: 'are called' }, 'appellare': { pos: 'verb', def: 'call' },
        'incolo': { pos: 'verb', def: 'inhabit, dwell' }, 'incolunt': { pos: 'verb', def: 'inhabit' }, 'incolere': { pos: 'verb', def: 'inhabit' },
        'divido': { pos: 'verb', def: 'divide' }, 'diuido': { pos: 'verb', def: 'divide' }, 'dividit': { pos: 'verb', def: 'divide' }, 'diuidit': { pos: 'verb', def: 'divide' }, 
        'divisa': { pos: 'participle', def: 'divided, having been divided' }, 'diuisa': { pos: 'participle', def: 'divided, having been divided' }, 
        'divisus': { pos: 'participle', def: 'divided, having been divided' }, 'diuisus': { pos: 'participle', def: 'divided, having been divided' }, 
        'divisum': { pos: 'participle', def: 'divided' }, 'diuisum': { pos: 'participle', def: 'divided' }, 
        'divisi': { pos: 'participle', def: 'divided' }, 'diuisi': { pos: 'participle', def: 'divided' }, 
        'dividere': { pos: 'verb', def: 'divide' }, 'diuidere': { pos: 'verb', def: 'divide' },
        'occido': { pos: 'verb', def: 'kill' }, 'occidis': { pos: 'verb', def: 'kill' }, 'occidit': { pos: 'verb', def: 'kill' }, 'occidunt': { pos: 'verb', def: 'kill' }, 'occidere': { pos: 'verb', def: 'kill' },
        'condo': { pos: 'verb', def: 'found, establish' }, 'condis': { pos: 'verb', def: 'found' }, 'condit': { pos: 'verb', def: 'found' }, 'condunt': { pos: 'verb', def: 'found' }, 'condidi': { pos: 'verb', def: 'founded' }, 'conditum': { pos: 'verb', def: 'founded' }, 'condere': { pos: 'verb', def: 'found' },
        'pello': { pos: 'verb', def: 'drive, push' }, 'pellis': { pos: 'verb', def: 'drive' }, 'pellit': { pos: 'verb', def: 'drive' }, 'pellere': { pos: 'verb', def: 'drive' },
        'sequor': { pos: 'verb', def: 'follow' }, 'sequitur': { pos: 'verb', def: 'follow' }, 'sequuntur': { pos: 'verb', def: 'follow' }, 'secutus': { pos: 'verb', def: 'followed' }, 'sequi': { pos: 'verb', def: 'follow' },
        'patior': { pos: 'verb', def: 'suffer, endure' }, 'patitur': { pos: 'verb', def: 'suffer' }, 'patiuntur': { pos: 'verb', def: 'suffer' }, 'passus': { pos: 'verb', def: 'suffered' }, 'pati': { pos: 'verb', def: 'suffer' },
        'relinquo': { pos: 'verb', def: 'leave behind' }, 'relinquis': { pos: 'verb', def: 'leave' }, 'relinquere': { pos: 'verb', def: 'leave' },
        'iacio': { pos: 'verb', def: 'throw' }, 'iacis': { pos: 'verb', def: 'throw' }, 'iacit': { pos: 'verb', def: 'throw' }, 'iaciunt': { pos: 'verb', def: 'throw' }, 'ieci': { pos: 'verb', def: 'threw' }, 'iactum': { pos: 'verb', def: 'thrown' }, 'iacere': { pos: 'verb', def: 'throw' },
        'tango': { pos: 'verb', def: 'touch' }, 'tangis': { pos: 'verb', def: 'touch' }, 'tangit': { pos: 'verb', def: 'touch' }, 'tangere': { pos: 'verb', def: 'touch' },
        'tendo': { pos: 'verb', def: 'stretch, strive' }, 'tendis': { pos: 'verb', def: 'stretch' }, 'tendit': { pos: 'verb', def: 'stretch' }, 'tendunt': { pos: 'verb', def: 'stretch' }, 'tendere': { pos: 'verb', def: 'stretch' },
        'claudo': { pos: 'verb', def: 'close, shut' }, 'claudis': { pos: 'verb', def: 'close' }, 'claudit': { pos: 'verb', def: 'close' }, 'clausit': { pos: 'verb', def: 'closed' }, 'claudere': { pos: 'verb', def: 'close' },
        'iuvo': { pos: 'verb', def: 'help' }, 'iuvas': { pos: 'verb', def: 'help' }, 'iuvare': { pos: 'verb', def: 'help' },
        'rego': { pos: 'verb', def: 'rule, guide' }, 'regis': { pos: 'verb', def: 'rule' }, 'regit': { pos: 'verb', def: 'rule' }, 'regunt': { pos: 'verb', def: 'rule' }, 'rexi': { pos: 'verb', def: 'ruled' }, 'rectum': { pos: 'verb', def: 'ruled' }, 'regere': { pos: 'verb', def: 'rule' },
        'paro': { pos: 'verb', def: 'prepare' }, 'paras': { pos: 'verb', def: 'prepare' }, 'parare': { pos: 'verb', def: 'prepare' },
        
        // Epic nouns - people, gods, fate
        'fatum': { pos: 'noun', def: 'fate' }, 'fati': { pos: 'noun', def: 'fate' }, 'fato': { pos: 'noun', def: 'fate' }, 'fata': { pos: 'noun', def: 'fates' }, 'fatis': { pos: 'noun', def: 'fates' },
        'fortuna': { pos: 'noun', def: 'fortune, luck' }, 'fortunae': { pos: 'noun', def: 'fortune' }, 'fortunam': { pos: 'noun', def: 'fortune' },
        'deus': { pos: 'noun', def: 'god' }, 'dei': { pos: 'noun', def: 'god' }, 'deo': { pos: 'noun', def: 'god' }, 'deum': { pos: 'noun', def: 'god' }, 'di': { pos: 'noun', def: 'gods' }, 'dis': { pos: 'noun', def: 'gods' }, 'deos': { pos: 'noun', def: 'gods' }, 'deorum': { pos: 'noun', def: 'gods' },
        'dea': { pos: 'noun', def: 'goddess' }, 'deae': { pos: 'noun', def: 'goddess' }, 'deam': { pos: 'noun', def: 'goddess' },
        'divus': { pos: 'adjective', def: 'divine' }, 'diva': { pos: 'adjective', def: 'divine' }, 'divum': { pos: 'adjective', def: 'divine' },
        'numen': { pos: 'noun', def: 'divine will, deity' }, 'numinis': { pos: 'noun', def: 'divine will' }, 'numine': { pos: 'noun', def: 'divine will' }, 'numina': { pos: 'noun', def: 'divine wills' },
        'rex': { pos: 'noun', def: 'king' }, 'regis': { pos: 'noun', def: 'king' }, 'regi': { pos: 'noun', def: 'king' }, 'regem': { pos: 'noun', def: 'king' }, 'rege': { pos: 'noun', def: 'king' }, 'reges': { pos: 'noun', def: 'kings' }, 'regum': { pos: 'noun', def: 'kings' },
        'regina': { pos: 'noun', def: 'queen' }, 'reginae': { pos: 'noun', def: 'queen' }, 'reginam': { pos: 'noun', def: 'queen' },
        'dux': { pos: 'noun', def: 'leader' }, 'ducis': { pos: 'noun', def: 'leader' }, 'duci': { pos: 'noun', def: 'leader' }, 'ducem': { pos: 'noun', def: 'leader' }, 'duce': { pos: 'noun', def: 'leader' }, 'duces': { pos: 'noun', def: 'leaders' },
        'heros': { pos: 'noun', def: 'hero' }, 'herois': { pos: 'noun', def: 'hero' }, 'heroa': { pos: 'noun', def: 'hero' }, 'heroas': { pos: 'noun', def: 'heroes' },
        'orator': { pos: 'noun', def: 'orator, speaker' }, 'oratoris': { pos: 'noun', def: 'orator' }, 'oratori': { pos: 'noun', def: 'orator' }, 'oratorem': { pos: 'noun', def: 'orator' }, 'oratore': { pos: 'noun', def: 'orator' }, 'oratores': { pos: 'noun', def: 'orators' },
        'senator': { pos: 'noun', def: 'senator' }, 'senatoris': { pos: 'noun', def: 'senator' }, 'senatori': { pos: 'noun', def: 'senator' }, 'senatorem': { pos: 'noun', def: 'senator' }, 'senatore': { pos: 'noun', def: 'senator' },
        'imperator': { pos: 'noun', def: 'general, commander' }, 'imperatoris': { pos: 'noun', def: 'general' }, 'imperatori': { pos: 'noun', def: 'general' }, 'imperatorem': { pos: 'noun', def: 'general' }, 'imperatore': { pos: 'noun', def: 'general' },
        'consul': { pos: 'noun', def: 'consul' }, 'consulis': { pos: 'noun', def: 'consul' }, 'consuli': { pos: 'noun', def: 'consul' }, 'consulem': { pos: 'noun', def: 'consul' }, 'consule': { pos: 'noun', def: 'consul' },
        'civis': { pos: 'noun', def: 'citizen' }, 'civis': { pos: 'noun', def: 'citizen' }, 'civi': { pos: 'noun', def: 'citizen' }, 'civem': { pos: 'noun', def: 'citizen' }, 'cive': { pos: 'noun', def: 'citizen' }, 'cives': { pos: 'noun', def: 'citizens' },
        'miles': { pos: 'noun', def: 'soldier' }, 'militis': { pos: 'noun', def: 'soldier' }, 'militi': { pos: 'noun', def: 'soldier' }, 'militem': { pos: 'noun', def: 'soldier' }, 'milite': { pos: 'noun', def: 'soldier' }, 'milites': { pos: 'noun', def: 'soldiers' },
        'poeta': { pos: 'noun', def: 'poet' }, 'poetae': { pos: 'noun', def: 'poet' }, 'poetam': { pos: 'noun', def: 'poet' }, 'poetis': { pos: 'noun', def: 'poets' },
        'philosophus': { pos: 'noun', def: 'philosopher' }, 'philosophi': { pos: 'noun', def: 'philosopher' }, 'philosopho': { pos: 'noun', def: 'philosopher' }, 'philosophum': { pos: 'noun', def: 'philosopher' },
        'vir': { pos: 'noun', def: 'man' }, 'viri': { pos: 'noun', def: 'man' }, 'viro': { pos: 'noun', def: 'man' }, 'virum': { pos: 'noun', def: 'man' }, 'virorum': { pos: 'noun', def: 'men' }, 'viros': { pos: 'noun', def: 'men' }, 'viris': { pos: 'noun', def: 'men' },
        'femina': { pos: 'noun', def: 'woman' }, 'feminae': { pos: 'noun', def: 'woman' }, 'feminam': { pos: 'noun', def: 'woman' },
        'gens': { pos: 'noun', def: 'race, nation' }, 'gentis': { pos: 'noun', def: 'race' }, 'genti': { pos: 'noun', def: 'race' }, 'gentem': { pos: 'noun', def: 'race' }, 'gente': { pos: 'noun', def: 'race' }, 'gentes': { pos: 'noun', def: 'races' }, 'gentium': { pos: 'noun', def: 'races' },
        'populus': { pos: 'noun', def: 'people' }, 'populi': { pos: 'noun', def: 'people' }, 'populo': { pos: 'noun', def: 'people' }, 'populum': { pos: 'noun', def: 'people' },
        
        // Epic nouns - places, nature
        'caelum': { pos: 'noun', def: 'sky, heaven' }, 'caeli': { pos: 'noun', def: 'sky' }, 'caelo': { pos: 'noun', def: 'sky' }, 'caelorum': { pos: 'noun', def: 'skies' },
        'terra': { pos: 'noun', def: 'earth, land' }, 'terrae': { pos: 'noun', def: 'earth' }, 'terram': { pos: 'noun', def: 'earth' }, 'terris': { pos: 'noun', def: 'lands' },
        'mare': { pos: 'noun', def: 'sea' }, 'maris': { pos: 'noun', def: 'sea' }, 'mari': { pos: 'noun', def: 'sea' }, 'maria': { pos: 'noun', def: 'seas' },
        'pontus': { pos: 'noun', def: 'sea' }, 'ponti': { pos: 'noun', def: 'sea' }, 'ponto': { pos: 'noun', def: 'sea' },
        'fluctus': { pos: 'noun', def: 'wave' }, 'fluctuum': { pos: 'noun', def: 'waves' }, 'fluctibus': { pos: 'noun', def: 'waves' },
        'unda': { pos: 'noun', def: 'wave, water' }, 'undae': { pos: 'noun', def: 'wave' }, 'undam': { pos: 'noun', def: 'wave' }, 'undis': { pos: 'noun', def: 'waves' },
        'litus': { pos: 'noun', def: 'shore' }, 'litoris': { pos: 'noun', def: 'shore' }, 'litore': { pos: 'noun', def: 'shore' }, 'litora': { pos: 'noun', def: 'shores' },
        'navis': { pos: 'noun', def: 'ship' }, 'navis': { pos: 'noun', def: 'ship' }, 'navi': { pos: 'noun', def: 'ship' }, 'navem': { pos: 'noun', def: 'ship' }, 'nave': { pos: 'noun', def: 'ship' }, 'naves': { pos: 'noun', def: 'ships' }, 'navium': { pos: 'noun', def: 'ships' }, 'navibus': { pos: 'noun', def: 'ships' },
        'classis': { pos: 'noun', def: 'fleet' }, 'classis': { pos: 'noun', def: 'fleet' }, 'classi': { pos: 'noun', def: 'fleet' }, 'classem': { pos: 'noun', def: 'fleet' }, 'classe': { pos: 'noun', def: 'fleet' },
        'urbs': { pos: 'noun', def: 'city' }, 'urbis': { pos: 'noun', def: 'city' }, 'urbi': { pos: 'noun', def: 'city' }, 'urbem': { pos: 'noun', def: 'city' }, 'urbe': { pos: 'noun', def: 'city' }, 'urbes': { pos: 'noun', def: 'cities' }, 'urbium': { pos: 'noun', def: 'cities' },
        'moenia': { pos: 'noun', def: 'walls, fortifications' }, 'moenibus': { pos: 'noun', def: 'walls' },
        'porta': { pos: 'noun', def: 'gate' }, 'portae': { pos: 'noun', def: 'gate' }, 'portam': { pos: 'noun', def: 'gate' }, 'portis': { pos: 'noun', def: 'gates' },
        'domus': { pos: 'noun', def: 'house, home' }, 'domui': { pos: 'noun', def: 'house' }, 'domum': { pos: 'noun', def: 'house' }, 'domo': { pos: 'noun', def: 'house' }, 'domibus': { pos: 'noun', def: 'houses' },
        'regia': { pos: 'noun', def: 'palace' }, 'regiae': { pos: 'noun', def: 'palace' }, 'regiam': { pos: 'noun', def: 'palace' },
        'templum': { pos: 'noun', def: 'temple' }, 'templi': { pos: 'noun', def: 'temple' }, 'templo': { pos: 'noun', def: 'temple' }, 'templa': { pos: 'noun', def: 'temples' },
        'ara': { pos: 'noun', def: 'altar' }, 'arae': { pos: 'noun', def: 'altar' }, 'aram': { pos: 'noun', def: 'altar' }, 'aris': { pos: 'noun', def: 'altars' },
        'silva': { pos: 'noun', def: 'forest' }, 'silvae': { pos: 'noun', def: 'forest' }, 'silvam': { pos: 'noun', def: 'forest' }, 'silvis': { pos: 'noun', def: 'forests' },
        'mons': { pos: 'noun', def: 'mountain' }, 'montis': { pos: 'noun', def: 'mountain' }, 'monti': { pos: 'noun', def: 'mountain' }, 'montem': { pos: 'noun', def: 'mountain' }, 'monte': { pos: 'noun', def: 'mountain' }, 'montes': { pos: 'noun', def: 'mountains' }, 'montium': { pos: 'noun', def: 'mountains' },
        'campus': { pos: 'noun', def: 'plain, field' }, 'campi': { pos: 'noun', def: 'field' }, 'campo': { pos: 'noun', def: 'field' }, 'campos': { pos: 'noun', def: 'fields' },
        
        // Epic adjectives
        'magnus': { pos: 'adjective', def: 'great, large' }, 'magna': { pos: 'adjective', def: 'great' }, 'magnum': { pos: 'adjective', def: 'great' }, 'magni': { pos: 'adjective', def: 'great' }, 'magno': { pos: 'adjective', def: 'great' },
        'parvus': { pos: 'adjective', def: 'small' }, 'parva': { pos: 'adjective', def: 'small' }, 'parvum': { pos: 'adjective', def: 'small' },
        'longus': { pos: 'adjective', def: 'long' }, 'longa': { pos: 'adjective', def: 'long' }, 'longum': { pos: 'adjective', def: 'long' },
        'altus': { pos: 'adjective', def: 'high, deep' }, 'alta': { pos: 'adjective', def: 'high, deep' }, 'altum': { pos: 'adjective', def: 'high, deep' }, 'altis': { pos: 'adjective', def: 'high, deep' },
        'clarus': { pos: 'adjective', def: 'clear, famous' }, 'clara': { pos: 'adjective', def: 'clear, famous' }, 'clarum': { pos: 'adjective', def: 'clear, famous' },
        'fortis': { pos: 'adjective', def: 'brave, strong' }, 'forte': { pos: 'adjective', def: 'brave, strong' }, 'fortes': { pos: 'adjective', def: 'brave, strong' }, 'fortium': { pos: 'adjective', def: 'brave, strong' },
        'felix': { pos: 'adjective', def: 'happy, fortunate' }, 'felicis': { pos: 'adjective', def: 'happy' }, 'felicem': { pos: 'adjective', def: 'happy' },
        'infelix': { pos: 'adjective', def: 'unhappy, unfortunate' }, 'infelicis': { pos: 'adjective', def: 'unhappy' }, 'infelicem': { pos: 'adjective', def: 'unhappy' },
        'sacer': { pos: 'adjective', def: 'sacred' }, 'sacra': { pos: 'adjective', def: 'sacred' }, 'sacrum': { pos: 'adjective', def: 'sacred' }, 'sacri': { pos: 'adjective', def: 'sacred' },
        'sanctus': { pos: 'adjective', def: 'holy, sacred' }, 'sancta': { pos: 'adjective', def: 'holy' }, 'sanctum': { pos: 'adjective', def: 'holy' },
        'pius': { pos: 'adjective', def: 'pious, dutiful' }, 'pia': { pos: 'adjective', def: 'pious' }, 'pium': { pos: 'adjective', def: 'pious' },
        'impius': { pos: 'adjective', def: 'impious' }, 'impia': { pos: 'adjective', def: 'impious' }, 'impium': { pos: 'adjective', def: 'impious' },
        'acer': { pos: 'adjective', def: 'sharp, fierce' }, 'acris': { pos: 'adjective', def: 'sharp, fierce' }, 'acre': { pos: 'adjective', def: 'sharp, fierce' },
        'saevus': { pos: 'adjective', def: 'savage, cruel' }, 'saeva': { pos: 'adjective', def: 'savage' }, 'saevum': { pos: 'adjective', def: 'savage' },
        'dirus': { pos: 'adjective', def: 'dreadful, ominous' }, 'dira': { pos: 'adjective', def: 'dreadful' }, 'dirum': { pos: 'adjective', def: 'dreadful' },
        'aeternus': { pos: 'adjective', def: 'eternal' }, 'aeterna': { pos: 'adjective', def: 'eternal' }, 'aeternum': { pos: 'adjective', def: 'eternal' },
        'immensus': { pos: 'adjective', def: 'immense, boundless' }, 'immensa': { pos: 'adjective', def: 'immense' }, 'immensum': { pos: 'adjective', def: 'immense' },
        'vastus': { pos: 'adjective', def: 'vast, huge' }, 'vasta': { pos: 'adjective', def: 'vast' }, 'vastum': { pos: 'adjective', def: 'vast' },
        'celsus': { pos: 'adjective', def: 'high, lofty' }, 'celsa': { pos: 'adjective', def: 'high' }, 'celsum': { pos: 'adjective', def: 'high' },
        'arduus': { pos: 'adjective', def: 'steep, difficult' }, 'ardua': { pos: 'adjective', def: 'steep' }, 'arduum': { pos: 'adjective', def: 'steep' },
        
        // Abstract nouns
        'animus': { pos: 'noun', def: 'mind, spirit' }, 'animi': { pos: 'noun', def: 'mind' }, 'animo': { pos: 'noun', def: 'mind' }, 'animum': { pos: 'noun', def: 'mind' }, 'animis': { pos: 'noun', def: 'minds' },
        'anima': { pos: 'noun', def: 'soul, life' }, 'animae': { pos: 'noun', def: 'soul' }, 'animam': { pos: 'noun', def: 'soul' },
        'pectus': { pos: 'noun', def: 'breast, heart' }, 'pectoris': { pos: 'noun', def: 'breast' }, 'pectore': { pos: 'noun', def: 'breast' }, 'pectora': { pos: 'noun', def: 'breasts' },
        'cor': { pos: 'noun', def: 'heart' }, 'cordis': { pos: 'noun', def: 'heart' }, 'cordi': { pos: 'noun', def: 'heart' }, 'corde': { pos: 'noun', def: 'heart' },
        'virtus': { pos: 'noun', def: 'virtue, courage' }, 'virtutis': { pos: 'noun', def: 'virtue' }, 'virtute': { pos: 'noun', def: 'virtue' }, 'virtutes': { pos: 'noun', def: 'virtues' },
        'gloria': { pos: 'noun', def: 'glory' }, 'gloriae': { pos: 'noun', def: 'glory' }, 'gloriam': { pos: 'noun', def: 'glory' },
        'fama': { pos: 'noun', def: 'fame, rumor' }, 'famae': { pos: 'noun', def: 'fame' }, 'famam': { pos: 'noun', def: 'fame' },
        'laus': { pos: 'noun', def: 'praise' }, 'laudis': { pos: 'noun', def: 'praise' }, 'laude': { pos: 'noun', def: 'praise' }, 'laudes': { pos: 'noun', def: 'praises' },
        'dolor': { pos: 'noun', def: 'pain, grief' }, 'doloris': { pos: 'noun', def: 'pain' }, 'dolore': { pos: 'noun', def: 'pain' },
        'furor': { pos: 'noun', def: 'rage, madness' }, 'furoris': { pos: 'noun', def: 'rage' }, 'furore': { pos: 'noun', def: 'rage' },
        'ira': { pos: 'noun', def: 'anger' }, 'irae': { pos: 'noun', def: 'anger' }, 'iram': { pos: 'noun', def: 'anger' }, 'iris': { pos: 'noun', def: 'angers' },
        'amor': { pos: 'noun', def: 'love' }, 'amoris': { pos: 'noun', def: 'love' }, 'amore': { pos: 'noun', def: 'love' },
        'metus': { pos: 'noun', def: 'fear' }, 'metus': { pos: 'noun', def: 'fear' }, 'metu': { pos: 'noun', def: 'fear' },
        'spes': { pos: 'noun', def: 'hope' }, 'spei': { pos: 'noun', def: 'hope' }, 'spem': { pos: 'noun', def: 'hope' }, 'spe': { pos: 'noun', def: 'hope' },
        'labor': { pos: 'noun', def: 'labor, toil' }, 'laboris': { pos: 'noun', def: 'labor' }, 'labore': { pos: 'noun', def: 'labor' }, 'labores': { pos: 'noun', def: 'labors' },
        'opus': { pos: 'noun', def: 'work, deed' }, 'operis': { pos: 'noun', def: 'work' }, 'opere': { pos: 'noun', def: 'work' }, 'opera': { pos: 'noun', def: 'works' },
        
        // Body parts and physical
        'corpus': { pos: 'noun', def: 'body' }, 'corporis': { pos: 'noun', def: 'body' }, 'corpore': { pos: 'noun', def: 'body' }, 'corpora': { pos: 'noun', def: 'bodies' },
        'caput': { pos: 'noun', def: 'head' }, 'capitis': { pos: 'noun', def: 'head' }, 'capite': { pos: 'noun', def: 'head' }, 'capita': { pos: 'noun', def: 'heads' },
        'oculus': { pos: 'noun', def: 'eye' }, 'oculi': { pos: 'noun', def: 'eye' }, 'oculo': { pos: 'noun', def: 'eye' }, 'oculum': { pos: 'noun', def: 'eye' }, 'oculos': { pos: 'noun', def: 'eyes' }, 'oculis': { pos: 'noun', def: 'eyes' },
        'manus': { pos: 'noun', def: 'hand' }, 'manus': { pos: 'noun', def: 'hand' }, 'manui': { pos: 'noun', def: 'hand' }, 'manum': { pos: 'noun', def: 'hand' }, 'manu': { pos: 'noun', def: 'hand' }, 'manibus': { pos: 'noun', def: 'hands' },
        'pes': { pos: 'noun', def: 'foot' }, 'pedis': { pos: 'noun', def: 'foot' }, 'pedi': { pos: 'noun', def: 'foot' }, 'pedem': { pos: 'noun', def: 'foot' }, 'pede': { pos: 'noun', def: 'foot' }, 'pedes': { pos: 'noun', def: 'feet' },
        'vox': { pos: 'noun', def: 'voice' }, 'vocis': { pos: 'noun', def: 'voice' }, 'vocem': { pos: 'noun', def: 'voice' }, 'voce': { pos: 'noun', def: 'voice' },
        'sanguis': { pos: 'noun', def: 'blood' }, 'sanguinis': { pos: 'noun', def: 'blood' }, 'sanguine': { pos: 'noun', def: 'blood' },
        'vulnus': { pos: 'noun', def: 'wound' }, 'vulneris': { pos: 'noun', def: 'wound' }, 'vulnere': { pos: 'noun', def: 'wound' }, 'vulnera': { pos: 'noun', def: 'wounds' },
        
        // Time and numbers
        'tempus': { pos: 'noun', def: 'time' }, 'temporis': { pos: 'noun', def: 'time' }, 'tempore': { pos: 'noun', def: 'time' }, 'tempora': { pos: 'noun', def: 'times' },
        'hora': { pos: 'noun', def: 'hour' }, 'horae': { pos: 'noun', def: 'hour' }, 'horam': { pos: 'noun', def: 'hour' }, 'horis': { pos: 'noun', def: 'hours' },
        'dies': { pos: 'noun', def: 'day' }, 'diei': { pos: 'noun', def: 'day' }, 'diem': { pos: 'noun', def: 'day' }, 'die': { pos: 'noun', def: 'day' }, 'dierum': { pos: 'noun', def: 'days' },
        'nox': { pos: 'noun', def: 'night' }, 'noctis': { pos: 'noun', def: 'night' }, 'noctem': { pos: 'noun', def: 'night' }, 'nocte': { pos: 'noun', def: 'night' }, 'noctes': { pos: 'noun', def: 'nights' },
        'lux': { pos: 'noun', def: 'light' }, 'lucis': { pos: 'noun', def: 'light' }, 'lucem': { pos: 'noun', def: 'light' }, 'luce': { pos: 'noun', def: 'light' },
        'annus': { pos: 'noun', def: 'year' }, 'anni': { pos: 'noun', def: 'year' }, 'anno': { pos: 'noun', def: 'year' }, 'annum': { pos: 'noun', def: 'year' }, 'annos': { pos: 'noun', def: 'years' },
        'unus': { pos: 'adjective', def: 'one' }, 'una': { pos: 'adjective', def: 'one' }, 'unum': { pos: 'adjective', def: 'one' },
        'duo': { pos: 'adjective', def: 'two' }, 'duae': { pos: 'adjective', def: 'two' }, 'duos': { pos: 'adjective', def: 'two' },
        'tres': { pos: 'adjective', def: 'three' }, 'tria': { pos: 'adjective', def: 'three' },
        'multus': { pos: 'adjective', def: 'much, many' }, 'multa': { pos: 'adjective', def: 'much, many' }, 'multum': { pos: 'adjective', def: 'much, many' }, 'multi': { pos: 'adjective', def: 'many' }, 'multos': { pos: 'adjective', def: 'many' }, 'multis': { pos: 'adjective', def: 'many' },
        'maximus': { pos: 'adjective', def: 'greatest, very great' }, 'maxima': { pos: 'adjective', def: 'greatest, very great' }, 'maximum': { pos: 'adjective', def: 'greatest, very great', case: 'acc sg (or nom/acc sg neuter)' }, 
        'maximas': { pos: 'adjective', def: 'very great, greatest', case: 'acc pl' }, 'maximo': { pos: 'adjective', def: 'very great', case: 'dat/abl sg' }, 'maximis': { pos: 'adjective', def: 'very great', case: 'dat/abl pl' },
        'proximus': { pos: 'adjective', def: 'nearest, next' }, 'proxima': { pos: 'adjective', def: 'nearest' }, 'proximorum': { pos: 'adjective', def: 'of the nearest' }, 'proximis': { pos: 'adjective', def: 'nearest, next', case: 'dat/abl pl' },
        'omnis': { pos: 'adjective', def: 'all, every', case: 'nom/gen sg' }, 'omne': { pos: 'adjective', def: 'all', case: 'nom/acc sg neut' }, 'omnes': { pos: 'adjective', def: 'all', case: 'nom/acc pl' }, 'omnia': { pos: 'adjective', def: 'all', case: 'nom/acc pl neut' }, 'omnium': { pos: 'adjective', def: 'all', case: 'gen pl' },
        'totus': { pos: 'adjective', def: 'whole, entire' }, 'tota': { pos: 'adjective', def: 'whole' }, 'totum': { pos: 'adjective', def: 'whole' },
        'nullus': { pos: 'adjective', def: 'no, none' }, 'nulla': { pos: 'adjective', def: 'no' }, 'nullum': { pos: 'adjective', def: 'no' },
        
        // Common connecting words and particles
        'atque': { pos: 'conjunction', def: 'and' }, 'ac': { pos: 'conjunction', def: 'and' },
        'que': { pos: 'particle', def: 'and' },
        'vel': { pos: 'conjunction', def: 'or' },
        'aut': { pos: 'conjunction', def: 'or' },
        'nam': { pos: 'conjunction', def: 'for' },
        'enim': { pos: 'particle', def: 'for, indeed' },
        'autem': { pos: 'conjunction', def: 'but, however' },
        'tamen': { pos: 'adverb', def: 'nevertheless, however' },
        'ergo': { pos: 'adverb', def: 'therefore' },
        'igitur': { pos: 'adverb', def: 'therefore' },
        'itaque': { pos: 'adverb', def: 'and so, therefore' }
    };

    function lookupDefinition(word) {
        const n = normalizeLatin(word);
        return LEXICON[n]?.def;
    }

    // === API FALLBACK SYSTEM FOR UNKNOWN WORDS ===
    
    // Local cache for API lookups
    const WORD_CACHE_KEY = 'latinWordCache';
    const CACHE_EXPIRY_DAYS = 30;
    
    function getWordCache() {
        try {
            const cache = localStorage.getItem(WORD_CACHE_KEY);
            if (!cache) return {};
            const parsed = JSON.parse(cache);
            // Check if cache is expired
            if (parsed.timestamp && (Date.now() - parsed.timestamp > CACHE_EXPIRY_DAYS * 24 * 60 * 60 * 1000)) {
                localStorage.removeItem(WORD_CACHE_KEY);
                return {};
            }
            return parsed.words || {};
        } catch (e) {
            return {};
        }
    }
    
    function setWordCache(cache) {
        try {
            localStorage.setItem(WORD_CACHE_KEY, JSON.stringify({
                timestamp: Date.now(),
                words: cache
            }));
        } catch (e) {
            console.warn('Could not save word cache to localStorage');
        }
    }
    
    function cacheWord(word, data) {
        const cache = getWordCache();
        cache[word] = data;
        setWordCache(cache);
    }
    
    // Fallback API lookup using Whitaker's Words approach
    async function lookupWordAPI(word) {
        const normalized = normalizeLatin(word);
        console.log('[API LOOKUP] Starting lookup for:', word, '→', normalized);
        
        // Check cache first
        const cache = getWordCache();
        if (cache[normalized]) {
            console.log('[API LOOKUP] Found in cache:', normalized, '→', cache[normalized]);
            return cache[normalized];
        }
        
        console.log('[API LOOKUP] Not in cache, trying APIs...');
        
        // CORS proxy to enable browser-based API calls
        const CORS_PROXY = 'https://corsproxy.io/?';
        
        try {
            // Option 1: Try Perseus Digital Library API (comprehensive Lewis & Short)
            try {
                const perseusURL = `http://www.perseus.tufts.edu/hopper/xmlmorph?lang=lat&lookup=${encodeURIComponent(normalized)}`;
                const proxiedURL = CORS_PROXY + encodeURIComponent(perseusURL);
                console.log('[API LOOKUP] Trying Perseus Digital Library:', proxiedURL);
                
                const perseusResponse = await fetch(proxiedURL, {
                    method: 'GET',
                    signal: AbortSignal.timeout(10000) // 10 second timeout
                });
                
                if (perseusResponse.ok) {
                    const xmlText = await perseusResponse.text();
                    console.log('[API LOOKUP] Perseus response received, parsing...');
                    
                    // Parse XML response
                    const parser = new DOMParser();
                    const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                    
                    // Get all analyses
                    const analyses = xmlDoc.getElementsByTagName('analysis');
                    
                    if (analyses.length > 0) {
                        // Get the first analysis
                        const firstAnalysis = analyses[0];
                        
                        // Extract lemma (base form)
                        const lemmaEl = firstAnalysis.getElementsByTagName('lemma')[0];
                        const lemma = lemmaEl ? lemmaEl.textContent : normalized;
                        
                        // Extract part of speech
                        const posEl = firstAnalysis.getElementsByTagName('pofs')[0];
                        let pos = posEl ? posEl.textContent : 'unknown';
                        
                        // Normalize POS to our format
                        const posMap = {
                            'noun': 'noun',
                            'verb': 'verb',
                            'adjective': 'adjective',
                            'adverb': 'adverb',
                            'pronoun': 'pronoun',
                            'preposition': 'preposition',
                            'conjunction': 'conjunction',
                            'particle': 'particle',
                            'numeral': 'numeral',
                            'participle': 'participle',
                            'part': 'participle'
                        };
                        pos = posMap[pos.toLowerCase()] || determinePosMorphologically(normalized);
                        
                        // Extract definition (prefer actual English definitions over Latin lemmas)
                        let definition = lemma; // fallback to lemma
                        
                        // Try to get English definition from <def> element first
                        const dictEl = firstAnalysis.getElementsByTagName('dict')[0];
                        const shortDefEl = dictEl ? dictEl.getElementsByTagName('def')[0] : null;
                        if (shortDefEl && shortDefEl.textContent) {
                            // Clean up definition (remove numbers, parentheses, etc.)
                            let shortDef = shortDefEl.textContent.trim();
                            shortDef = shortDef.replace(/^\d+\.\s*/, ''); // Remove leading numbers
                            shortDef = shortDef.split(',')[0]; // Take first meaning
                            shortDef = shortDef.split(';')[0]; // Take first part
                            if (shortDef.length > 0 && shortDef.length < 100) {
                                definition = shortDef;
                            }
                        }
                        
                        // If we still have Latin (lemma), try <hdwd> element
                        if (definition === lemma) {
                            const hdwdEl = dictEl ? dictEl.getElementsByTagName('hdwd')[0] : null;
                            if (hdwdEl && hdwdEl.textContent && hdwdEl.textContent !== lemma) {
                                definition = hdwdEl.textContent;
                            }
                        }
                        
                        const result = {
                            pos: pos,
                            def: definition,
                            found: true,
                            lemma: lemma
                        };
                        
                        cacheWord(normalized, result);
                        console.log('✓ Found via Perseus:', normalized, '→', result.def, `(${pos})`);
                        return result;
                    }
                }
            } catch (e) {
                console.log('Perseus API error:', e.message);
            }
            
            // Option 2: Try Latinitium API (fallback)
            try {
                const latinitiumURL = `https://api.latinitium.com/api/v1/words/${encodeURIComponent(normalized)}`;
                const proxiedURL = CORS_PROXY + encodeURIComponent(latinitiumURL);
                console.log('[API LOOKUP] Trying Latinitium (fallback):', proxiedURL);
                const latinitiumResponse = await fetch(proxiedURL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    },
                    signal: AbortSignal.timeout(8000)
                });
                
                if (latinitiumResponse.ok) {
                    const data = await latinitiumResponse.json();
                    if (data && data.definitions && data.definitions.length > 0) {
                        const result = {
                            pos: data.pos || determinePosMorphologically(normalized),
                            def: data.definitions[0].meaning || data.definitions[0],
                            found: true
                        };
                        cacheWord(normalized, result);
                        console.log('✓ Found via Latinitium:', normalized, '→', result.def);
                        return result;
                    }
                }
            } catch (e) {
                console.log('Latinitium API unavailable:', e.message);
            }
            
        } catch (error) {
            console.log('All API lookups failed for:', word, error);
        }
        
        // If all APIs fail, use morphological analysis as last resort
        const morphResult = analyzeMorphologically(normalized);
        if (morphResult.pos !== 'unknown') {
            // DON'T cache morphological results - they're not reliable definitions
            // This allows the system to retry with APIs later
            console.log('[API LOOKUP] Using morphological fallback (not cached):', morphResult);
            return morphResult;
        }
        
        // If everything fails, DON'T cache it - allow retries in future sessions
        const unknownResult = { pos: 'unknown', def: 'unknown', found: false };
        console.log('[API LOOKUP] All methods failed, returning unknown (not cached)');
        return unknownResult;
    }
    
    // Morphological analysis fallback
    // This identifies the likely part of speech but doesn't provide real definitions
    function analyzeMorphologically(word) {
        let pos = 'unknown';
        let def = 'unknown'; // Keep definition as "unknown" since morphology can't give meanings
        
        // Verb patterns (just identify POS, not definition)
        if (/^(sum|es|est|sumus|estis|sunt)$/i.test(word)) {
            pos = 'verb';
        } else if (/re$/i.test(word)) {
            pos = 'verb';
        } else if (/(o|or|m)$/i.test(word) && word.length > 2) {
            pos = 'verb';
        } else if (/t$/i.test(word) && !/nt$/i.test(word) && word.length > 2) {
            pos = 'verb';
        } else if (/nt$/i.test(word)) {
            pos = 'verb';
        }
        // Noun patterns
        else if (/(us|i|o|um|os|orum|is)$/i.test(word)) {
            pos = 'noun';
        } else if (/(a|ae|am|arum|as)$/i.test(word)) {
            pos = 'noun';
        } else if (/(em|es|e|ibus)$/i.test(word)) {
            pos = 'noun';
        }
        // Adjective patterns
        else if (/(issimus|issima|issimum|ior|ius)$/i.test(word)) {
            pos = 'adjective';
        }
        
        return { pos, def, found: false };
    }
    
    function determinePosMorphologically(word) {
        const result = analyzeMorphologically(word);
        return result.pos;
    }
    
    // Enhanced definition lookup with API fallback
    function lookupDefinitionWithFallback(word) {
        const n = normalizeLatin(word);
        const localDef = LEXICON[n]?.def;
        
        if (localDef) {
            return localDef;
        }
        
        // Check cache for API result
        const cache = getWordCache();
        if (cache[n]) {
            return cache[n].def;
        }
        
        // Return undefined if not in local lexicon or cache
        // The API lookup will happen asynchronously later if needed
        return undefined;
    }
    
    // Function to enhance unknown words with API data
    async function enhanceUnknownWords(tokens) {
        console.log('[API ENHANCE] Called with', tokens.length, 'total tokens');
        
        // Only lookup truly unknown words - skip words already in lexicon
        const unknownTokens = tokens.filter(t => {
            if (!t.normalized) return false;
            
            // Check if word is in lexicon with a good definition
            const lexEntry = LEXICON[t.normalized];
            if (lexEntry && lexEntry.def && lexEntry.def !== 'unknown') {
                return false;
            }

            // If we have POS but no definition, still treat as unknown so API can fill it in
            if (t.pos && t.pos !== 'unknown' && (!t.definition || t.definition === 'unknown')) {
                return true;
            }

            if (lexEntry && (!lexEntry.def || lexEntry.def === 'unknown')) {
                return true;
            }

            if (t.pos === 'verb' && (!t.definition || t.definition === 'unknown')) {
                return true;
            }

            if (lexEntry && !lexEntry.def) {
                console.log('[API ENHANCE] Skipping', t.normalized, '- already in lexicon with definition:', lexEntry.def);
                return false;
            }
            
            // Only include if truly unknown
            return (t.pos === 'unknown' || !t.definition || t.definition === 'unknown');
        });
        
        console.log('[API ENHANCE] Found', unknownTokens.length, 'unknown tokens:', 
            unknownTokens.map(t => t.normalized).join(', '));
        
        if (unknownTokens.length === 0) {
            console.log('[API ENHANCE] No unknown tokens, skipping API lookup');
            return;
        }
        
        // Lookup unknown words via API (with rate limiting)
        const lookupPromises = unknownTokens.slice(0, 10).map(async (t) => {
            console.log('[API ENHANCE] Looking up:', t.normalized);
            const apiResult = await lookupWordAPI(t.normalized);
            console.log('[API ENHANCE] Result for', t.normalized, ':', apiResult);
            if (apiResult.found) {
                t.pos = apiResult.pos;
                t.definition = apiResult.def;
                
                // Don't overwrite lexicon if it already has this word
                if (!LEXICON[t.normalized]) {
                    LEXICON[t.normalized] = { pos: apiResult.pos, def: apiResult.def };
                    console.log('[API ENHANCE] Added to lexicon:', t.normalized);
                } else {
                    console.log('[API ENHANCE] Token updated but lexicon preserved for:', t.normalized);
                }
            } else {
                console.log('[API ENHANCE] No definition found for:', t.normalized);
            }
        });
        
        await Promise.all(lookupPromises);
        console.log('[API ENHANCE] All lookups complete');
    }
    
    // Hook into the analyze function to enhance with API data
    const originalAnalyze = analyze;
    async function analyzeWithAPI(rawText, opts) {
        console.log('[ANALYZE WITH API] Called for text:', rawText);
        const result = originalAnalyze(rawText, opts);
        console.log('[ANALYZE WITH API] Analysis complete, tokens:', result.tokens.length);
        
        // Asynchronously enhance unknown words
        console.log('[ANALYZE WITH API] Starting async enhancement...');
        enhanceUnknownWords(result.tokens).then(() => {
            console.log('[ANALYZE WITH API] Enhancement complete, updating display...');
            // Update display if there were changes
            if (STATE.overlayActive && STATE.tokens === result.tokens) {
                renderOverlay(rawText, STATE.tokens, STATE.groups);
                console.log('[ANALYZE WITH API] Display updated');
            } else {
                console.log('[ANALYZE WITH API] Display not updated (overlay inactive or tokens changed)');
            }
        }).catch(err => {
            console.error('[ANALYZE WITH API] Enhancement failed:', err);
        });
        
        return result;
    }
    
    // API fallback is now ENABLED
    // The system will try multiple Latin dictionary APIs when words are not found locally
    // If all APIs fail, it falls back to morphological analysis
    // All results are cached locally for 30 days to improve performance

    // Initialize counts
    updateWordCount();
})();
    </script>
</body>
</html>

